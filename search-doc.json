{"searchDocs":[{"title":"Examples","type":0,"sectionRef":"#","url":"/0.1.0/examples/","content":"","keywords":"","version":"0.1.0"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.1.0/examples/#basic-examples","content":" Empty ResourceGroup (Noop) Explore the simplest form of a ResourceGroup that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.1.0","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.1.0/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGroups, including the necessary Deployment, Service, and ConfigMap. Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGroups, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGroups, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGroup. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGroup. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGroup, showcasing the use of multiple resources with dependencies. ","version":"0.1.0","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.1.0/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGroup, the project's fundamental custom resource. ResourceGroup specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGroup instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGroup is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGroup for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGroupspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGroup, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. Do I need to have an AWS account to use this? No, you can use kro with any Kubernetes cluster. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGroup CRD and other APIs used in this project are not solidified and highly subject to change. Will this be built into Amazon Elastic Kubernetes Service (EKS)? This project is a public experiment, and not currently integrated into Amazon EKS. We welcome your feedback and want to hear about what works and what doesn't for your use cases, please let us know what you think.","keywords":"","version":"0.1.0"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.1.0/api/out","content":"","keywords":"","version":"0.1.0"},{"title":"Packages​","type":1,"pageTitle":"API Reference","url":"/0.1.0/api/out#packages","content":" kro.run/v1alpha1  ","version":"0.1.0","tagName":"h2"},{"title":"kro.run/v1alpha1​","type":1,"pageTitle":"API Reference","url":"/0.1.0/api/out#krorunv1alpha1","content":" Package v1alpha1 contains API Schema definitions for the x v1alpha1 API group  ","version":"0.1.0","tagName":"h2"},{"title":"Resource Types​","type":1,"pageTitle":"API Reference","url":"/0.1.0/api/out#resource-types","content":" ResourceGroupResourceGroupList  Condition​  Condition is the common struct used by all CRDs managed by ACK service controllers to indicate terminal states of the CR and its backend AWS service API resource  Appears in:  ResourceGroupStatus  Field\tDescription\tDefault\tValidationtype ConditionType\tType is the type of the Condition status ConditionStatus\tStatus of the condition, one of True, False, Unknown. lastTransitionTime Time\tLast time the condition transitioned from one status to another. reason string\tThe reason for the condition's last transition. message string\tA human readable message indicating details about the transition. observedGeneration integer\tobservedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance. Minimum: 0   ConditionType​  Underlying type: string  Appears in:  Condition  Definition​  Appears in:  ResourceGroupSpec  Field\tDescription\tDefault\tValidationspec RawExtension status RawExtension types RawExtension validation string array   Resource​  Appears in:  ResourceGroupSpec  Field\tDescription\tDefault\tValidationname string Required: definition RawExtension Required:   ResourceGroup​  ResourceGroup is the Schema for the resourcegroups API  Appears in:  ResourceGroupList  Field\tDescription\tDefault\tValidationapiVersion string\tkro.run/v1alpha1 kind string\tResourceGroup kind string\tKind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds apiVersion string\tAPIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources metadata ObjectMeta\tRefer to Kubernetes API documentation for fields of metadata. spec ResourceGroupSpec status ResourceGroupStatus   ResourceGroupList​  ResourceGroupList contains a list of ResourceGroup  Field\tDescription\tDefault\tValidationapiVersion string\tkro.run/v1alpha1 kind string\tResourceGroupList kind string\tKind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds apiVersion string\tAPIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources metadata ListMeta\tRefer to Kubernetes API documentation for fields of metadata. items ResourceGroup array   ResourceGroupSpec​  ResourceGroupSpec defines the desired state of ResourceGroup  Appears in:  ResourceGroup  Field\tDescription\tDefault\tValidationkind string Required: apiVersion string Required: definition Definition Required: resources Resource array Optional:   ResourceGroupState​  Underlying type: string  Appears in:  ResourceGroupStatus  ResourceGroupStatus​  ResourceGroupStatus defines the observed state of ResourceGroup  Appears in:  ResourceGroup  Field\tDescription\tDefault\tValidationstate ResourceGroupState\tState is the state of the resourcegroup topologicalOrder string array\tTopologicalOrder is the topological order of the resourcegroup graph conditions Condition array\tConditions represent the latest available observations of an object's state  ","version":"0.1.0","tagName":"h3"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.1.0/docs/concepts/instances","content":"","keywords":"","version":"0.1.0"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.1.0/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.1.0","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.1.0/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.1.0","tagName":"h2"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.1.0/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"0.1.0","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.1.0/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status Running: All resources are readyProgressing: Working towards desired stateFailed: Error occurredTerminating: Being deleted Conditions: Detailed status information Ready: Instance is fully operationalProgressing: Changes are being appliedDegraded: Operating but not optimalError: Problems detected Resource Status: Status from your resources Values you defined in your ResourceGroup's status sectionAutomatically updated as resources change  ","version":"0.1.0","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.1.0/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.1.0","tagName":"h2"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.1.0/docs/concepts/simple-schema","content":"","keywords":"","version":"0.1.0"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.1.0","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesnumber: Decimal numbers  For example:  name: string age: integer enabled: boolean price: number   ","version":"0.1.0","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.1.0","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.1.0","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]number&quot;   ","version":"0.1.0","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.1.0","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbers  Multiple markers can be combined using the | separator.  For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot;   ","version":"0.1.0","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources existUpdates values when the underlying resources change  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} endpoint: ${service.status.loadBalancer.ingress[0].hostname}   ","version":"0.1.0","tagName":"h2"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.1.0","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;Progressing&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string reason: string message: string   Common condition types:  Ready: Instance is fully reconciledProgressing: Working towards desired stateDegraded: Operational but not optimalError: Reconciliation error occurred  ","version":"0.1.0","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.1.0/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # Ready, Progressing, Degraded, Unknown, Deleting   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values. ","version":"0.1.0","tagName":"h3"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.1.0/docs/overview","content":"","keywords":"","version":"0.1.0"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.1.0/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Fugure 1: End user interface - Custom API  ","version":"0.1.0","tagName":"h3"},{"title":"ResourceGroup​","type":1,"pageTitle":"What is kro?","url":"/0.1.0/docs/overview#resourcegroup","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGroup (RG). The Platform, Security, and Compliance teams, can collaborate to create custom APIs by defining Custom Resources for the ResourceGroup CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RG is applied to the cluster, a new API of kind ApplicationStack is created and available for Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Fugure 2: ResourceGroup (RG) - Platform Team Interface  ","version":"0.1.0","tagName":"h3"},{"title":"ResourceGroup Instance​","type":1,"pageTitle":"What is kro?","url":"/0.1.0/docs/overview#resourcegroup-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Fugure 3: ResourceGroup Instance (RGI)  Why kro?  ","version":"0.1.0","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.1.0/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.1.0","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.1.0/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.1.0","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.1.0/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.1.0","tagName":"h3"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.1.0/examples/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.1.0"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.1.0/docs/getting-started/Installation","content":"","keywords":"","version":"0.1.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.1.0/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.1.0","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.1.0/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.1.0","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.1.0/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/awslabs/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://public.ecr.aws/kro/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   ","version":"0.1.0","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.1.0/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.1.0","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.1.0/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://public.ecr.aws/kro/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and re-apply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.1.0","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.1.0/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGroup CRD and any other custom resources you may have created. ","version":"0.1.0","tagName":"h2"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.1.0/examples/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.1.0"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.2.0/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.2.0"},{"title":"Empty ResourceGroup","type":0,"sectionRef":"#","url":"/0.1.0/examples/noop","content":"Empty ResourceGroup noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: kro.run/v1alpha1 spec: apiVersion: v1alpha1 kind: NoOp definition: spec: name: string | required=true resources: [] ","keywords":"","version":"0.1.0"},{"title":"ResourceGroups","type":0,"sectionRef":"#","url":"/0.1.0/docs/concepts/resource-groups","content":"","keywords":"","version":"0.1.0"},{"title":"What is a ResourceGroup?​","type":1,"pageTitle":"ResourceGroups","url":"/0.1.0/docs/concepts/resource-groups#what-is-a-resourcegroup","content":" A ResourceGroup is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGroup, kro generates a new API (a.k.a Custom Resource Defintion) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.1.0","tagName":"h2"},{"title":"Anatomy of a ResourceGroup​","type":1,"pageTitle":"ResourceGroups","url":"/0.1.0/docs/concepts/resource-groups#anatomy-of-a-resourcegroup","content":" A ResourceGroup, like any Kubernetes resource, consists of three main parts:  Metadata: name, namespace, labels, etc.Spec: Defines the structure and properties of the ResourceGroupStatus: Reflects the current state of the ResourceGroup  The spec section of a ResourceGroup contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteria  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: my-resourcegroup # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.1.0","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGroups","url":"/0.1.0/docs/concepts/resource-groups#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions}   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGroup. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.1.0","tagName":"h2"},{"title":"ResourceGroup Processing​","type":1,"pageTitle":"ResourceGroups","url":"/0.1.0/docs/concepts/resource-groups#resourcegroup-processing","content":" When you create a ResourceGroup, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGroup to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acycled Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGroup defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource states  For instance, when you create a WebApplication ResourceGroup, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGroup for changes, updating the API and its behavior accordingly.  ","version":"0.1.0","tagName":"h2"},{"title":"ResourceGroup Instance Example​","type":1,"pageTitle":"ResourceGroups","url":"/0.1.0/docs/concepts/resource-groups#resourcegroup-instance-example","content":" After the ResourceGroup is validated and registered in the cluster, users can can create instances of it. Here's an example of how an instance for theSimpleWebApp might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: SimpleWebApp metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3  ","version":"0.1.0","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.2.0/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.2.0"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.2.0/docs/concepts/simple-schema","content":"","keywords":"","version":"0.2.0"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.2.0","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesnumber: Decimal numbers  For example:  name: string age: integer enabled: boolean price: number   ","version":"0.2.0","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.2.0","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.2.0","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]number&quot;   ","version":"0.2.0","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.2.0","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbers  Multiple markers can be combined using the | separator.  For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot;   ","version":"0.2.0","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources existUpdates values when the underlying resources change  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} endpoint: ${service.status.loadBalancer.ingress[0].hostname}   ","version":"0.2.0","tagName":"h2"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.2.0","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;Progressing&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string reason: string message: string   Common condition types:  Ready: Instance is fully reconciledProgressing: Working towards desired stateDegraded: Operational but not optimalError: Reconciliation error occurred  ","version":"0.2.0","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.2.0/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # Ready, Progressing, Degraded, Unknown, Deleting   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values. ","version":"0.2.0","tagName":"h3"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.2.0/docs/getting-started/Installation","content":"","keywords":"","version":"0.2.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.2.0/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.2.0","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.2.0/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.2.0","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.2.0/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kro-run/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   ","version":"0.2.0","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.2.0/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.2.0","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.2.0/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and re-apply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.2.0","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.2.0/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.2.0","tagName":"h2"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.1.0/examples/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: deploymentservice spec: apiVersion: v1alpha1 kind: DeploymentService definition: spec: name: string resources: - id: deployment definition: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service definition: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.1.0"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.2.0/docs/concepts/instances","content":"","keywords":"","version":"0.2.0"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.2.0/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.2.0","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.2.0/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.2.0","tagName":"h2"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.2.0/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"0.2.0","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.2.0/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status Running: All resources are readyProgressing: Working towards desired stateFailed: Error occurredTerminating: Being deleted Conditions: Detailed status information Ready: Instance is fully operationalProgressing: Changes are being appliedDegraded: Operating but not optimalError: Problems detected Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.2.0","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.2.0/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.2.0","tagName":"h2"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.1.0/examples/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.1.0"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.2.0/examples/","content":"","keywords":"","version":"0.2.0"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.2.0/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.2.0","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.2.0/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies. ","version":"0.2.0","tagName":"h2"},{"title":"Deploy Your First ResourceGroup","type":0,"sectionRef":"#","url":"/0.1.0/docs/getting-started/deploy-a-resource-group","content":"","keywords":"","version":"0.1.0"},{"title":"What is a ResourceGroup?​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/0.1.0/docs/getting-started/deploy-a-resource-group#what-is-a-resourcegroup","content":" A ResourceGroup lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGroup that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGroup, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.1.0","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/0.1.0/docs/getting-started/deploy-a-resource-group#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.1.0","tagName":"h2"},{"title":"Create your Application ResourceGroup​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/0.1.0/docs/getting-started/deploy-a-resource-group#create-your-application-resourcegroup","content":" Let's create a Resource Group that combines a Deployment, a Service andIngress. Save this as resourcegroup.yaml:  resourcegroup.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RG (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.1.0","tagName":"h2"},{"title":"Deploy the ResourceGroup​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/0.1.0/docs/getting-started/deploy-a-resource-group#deploy-the-resourcegroup","content":" Create a ResourceGroup manifest file: Create a new file with theResourceGroup definition. You can use the example above. Apply the ResourceGroup: Use the kubectl command to deploy the ResourceGroup to your Kubernetes cluster: kubectl apply -f resourcegroup.yaml Inpsect the ResourceGroup: Check the status of the resources created by the ResourceGroup using the kubectl command: kubectl get rg my-application -owide You should see the ResourceGroup in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.1.0","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/0.1.0/docs/getting-started/deploy-a-resource-group#create-your-application-instance","content":" Now that your ResourceGroup is created, kro has generated a new API (Application) that orchestrates creation of the a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.1.0","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/0.1.0/docs/getting-started/deploy-a-resource-group#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.1.0","tagName":"h3"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.1.0/examples/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployement on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.1.0"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.2.0/docs/overview","content":"","keywords":"","version":"0.2.0"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.2.0/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Fugure 1: End user interface - Custom API  ","version":"0.2.0","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.2.0/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams, can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RG is applied to the cluster, a new API of kind ApplicationStack is created and available for Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Fugure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.2.0","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.2.0/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Fugure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.2.0","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.2.0/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.2.0","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.2.0/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.2.0","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.2.0/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.2.0","tagName":"h3"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.2.0/examples/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.2.0"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.1.0/examples/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RG (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.1.0"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.2.0/examples/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: kro.run/v1alpha1 spec: apiVersion: v1alpha1 kind: NoOp definition: spec: name: string | required=true resources: [] ","keywords":"","version":"0.2.0"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.1.0/examples/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: deploymentandawspostgres spec: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres # CRD Definition definition: spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance definition: apiVersion: rds.saervices.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod definition: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.1.0"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.2.0/examples/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres # CRD Definition definition: spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance definition: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod definition: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.2.0"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.2.0/examples/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: apiVersion: v1alpha1 kind: DeploymentService definition: spec: name: string resources: - id: deployment definition: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service definition: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.2.0"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.2.1/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.2.1"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.2.1/docs/concepts/instances","content":"","keywords":"","version":"0.2.1"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.2.1/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.2.1","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.2.1/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.2.1","tagName":"h2"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.2.1/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"0.2.1","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.2.1/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status Running: All resources are readyProgressing: Working towards desired stateFailed: Error occurredTerminating: Being deleted Conditions: Detailed status information Ready: Instance is fully operationalProgressing: Changes are being appliedDegraded: Operating but not optimalError: Problems detected Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.2.1","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.2.1/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.2.1","tagName":"h2"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.2.1/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.2.1"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.1/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Defintion) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.2.1","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.1/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, namespace, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteria  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.2.1","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.1/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions}   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.2.1","tagName":"h2"},{"title":"ResourceGraphDefinition Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.1/docs/concepts/resource-group-definitions#resourcegraphdefinition-processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acycled Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource states  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.2.1","tagName":"h2"},{"title":"ResourceGraphDefinition Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.1/docs/concepts/resource-group-definitions#resourcegraphdefinition-instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can can create instances of it. Here's an example of how an instance for theSimpleWebApp might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: SimpleWebApp metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3  ","version":"0.2.1","tagName":"h2"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.2.0/examples/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.2.0"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.2.0/examples/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RG (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.2.0"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.2.1/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.2.1"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.2.0/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.2.0"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.0/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.2.0","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.0/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.2.0","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.0/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RG (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.2.0","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.0/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inpsect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rg my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.2.0","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.0/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates creation of the a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.2.0","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.0/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.2.0","tagName":"h3"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.2.1/examples/","content":"","keywords":"","version":"0.2.1"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.2.1/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.2.1","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.2.1/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.2.1","tagName":"h2"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.2.0/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.2.0"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.0/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Defintion) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.2.0","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.0/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, namespace, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteria  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.2.0","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.0/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions}   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.2.0","tagName":"h2"},{"title":"ResourceGraphDefinition Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.0/docs/concepts/resource-group-definitions#resourcegraphdefinition-processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acycled Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource states  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.2.0","tagName":"h2"},{"title":"ResourceGraphDefinition Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.0/docs/concepts/resource-group-definitions#resourcegraphdefinition-instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can can create instances of it. Here's an example of how an instance for theSimpleWebApp might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: SimpleWebApp metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3  ","version":"0.2.0","tagName":"h2"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.2.1/docs/getting-started/Installation","content":"","keywords":"","version":"0.2.1"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.2.1/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.2.1","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.2.1/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.2.1","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.2.1/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kro-run/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   ","version":"0.2.1","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.2.1/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.2.1","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.2.1/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and re-apply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.2.1","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.2.1/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.2.1","tagName":"h2"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/0.2.1/examples/aws/aws-examples","content":"AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.2.1"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.2.1/docs/concepts/simple-schema","content":"","keywords":"","version":"0.2.1"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.2.1","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesnumber: Decimal numbers  For example:  name: string age: integer enabled: boolean price: number   ","version":"0.2.1","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.2.1","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.2.1","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]number&quot;   ","version":"0.2.1","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.2.1","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbers  Multiple markers can be combined using the | separator.  For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot;   ","version":"0.2.1","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources existUpdates values when the underlying resources change  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} endpoint: ${service.status.loadBalancer.ingress[0].hostname}   ","version":"0.2.1","tagName":"h2"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.2.1","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;Progressing&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string reason: string message: string   Common condition types:  Ready: Instance is fully reconciledProgressing: Working towards desired stateDegraded: Operational but not optimalError: Reconciliation error occurred  ","version":"0.2.1","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.2.1/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # Ready, Progressing, Degraded, Unknown, Deleting   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values. ","version":"0.2.1","tagName":"h3"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.2.1/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.2.1"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.2.1/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.2.1"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.1.0/examples/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.1.0"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.2.1/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.2.1"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.2.1/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.2.1"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.1/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.2.1","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.1/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.2.1","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.1/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.2.1","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.1/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inpsect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.2.1","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.1/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates creation of the a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.2.1","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.1/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.2.1","tagName":"h3"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.2.1/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.2.1"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.2.0/examples/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.2.0"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.2.1/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.2.1"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.2.1/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.2.1"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.2.2/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.2.2"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.2.0/examples/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployement on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.2.0"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/0.2.2/docs/concepts/access-control","content":"","keywords":"","version":"0.2.2"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/0.2.2/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"0.2.2","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/0.2.2/docs/concepts/access-control#aggregation-access","content":" In the aggreagation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"0.2.2","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/0.2.2/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"0.2.2","tagName":"h3"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.2.2/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.2.2"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.2/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Defintion) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.2.2","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.2/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, namespace, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteria  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.2.2","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.2/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions}   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.2.2","tagName":"h2"},{"title":"ResourceGraphDefinition Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.2/docs/concepts/resource-group-definitions#resourcegraphdefinition-processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acycled Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource states  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.2.2","tagName":"h2"},{"title":"ResourceGraphDefinition Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.2.2/docs/concepts/resource-group-definitions#resourcegraphdefinition-instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can can create instances of it. Here's an example of how an instance for theWebApplication might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3  ","version":"0.2.2","tagName":"h2"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.2.1/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.2.1"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.2.2/docs/concepts/simple-schema","content":"","keywords":"","version":"0.2.2"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.2.2","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesnumber: Decimal numbers  For example:  name: string age: integer enabled: boolean price: number   ","version":"0.2.2","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.2.2","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.2.2","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]number&quot;   ","version":"0.2.2","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.2.2","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbers  Multiple markers can be combined using the | separator.  For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot;   ","version":"0.2.2","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources existUpdates values when the underlying resources change  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} endpoint: ${service.status.loadBalancer.ingress[0].hostname}   ","version":"0.2.2","tagName":"h2"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.2.2","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;Progressing&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string reason: string message: string   Common condition types:  Ready: Instance is fully reconciledProgressing: Working towards desired stateDegraded: Operational but not optimalError: Reconciliation error occurred  ","version":"0.2.2","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.2.2/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # Ready, Progressing, Degraded, Unknown, Deleting   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values. ","version":"0.2.2","tagName":"h3"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/0.2.1/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.2.1"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/0.2.1/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.2.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/0.2.1/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.2.1","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.2.2/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.2.2"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.2.2/docs/overview","content":"","keywords":"","version":"0.2.2"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.2.2/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Fugure 1: End user interface - Custom API  ","version":"0.2.2","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.2.2/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Fugure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.2.2","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.2.2/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Fugure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.2.2","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.2.2/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.2.2","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.2.2/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.2.2","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.2.2/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.2.2","tagName":"h3"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.2.0/examples/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.2.0"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/0.2.1/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.2.1"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/0.2.1/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.2.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/0.2.1/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.2.1","tagName":"h2"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.2.1/docs/overview","content":"","keywords":"","version":"0.2.1"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.2.1/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Fugure 1: End user interface - Custom API  ","version":"0.2.1","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.2.1/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams, can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Fugure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.2.1","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.2.1/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Fugure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.2.1","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.2.1/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.2.1","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.2.1/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.2.1","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.2.1/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.2.1","tagName":"h3"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.2.2/examples/","content":"","keywords":"","version":"0.2.2"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.2.2/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.2.2","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.2.2/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.2.2","tagName":"h2"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.2.2/docs/getting-started/Installation","content":"","keywords":"","version":"0.2.2"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.2.2/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.2.2","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.2.2/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.2.2","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.2.2/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kro-run/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   Troubleshooting Helm Install Note that authentication is not required for pulling charts from public GHCR (GitHub Container Registry) repositories. Helm install download failures occur due to expired local credentials. To resolve this issue, clear your local credentials cache by running helm registry logout ghcr.io in your terminal, then retry the installation.  ","version":"0.2.2","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.2.2/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.2.2","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.2.2/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and re-apply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.2.2","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.2.2/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.2.2","tagName":"h2"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.2.1/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.2.1"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.2.2/docs/concepts/instances","content":"","keywords":"","version":"0.2.2"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.2.2/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.2.2","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.2.2/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.2.2","tagName":"h2"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.2.2/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"0.2.2","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.2.2/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status Running: All resources are readyProgressing: Working towards desired stateFailed: Error occurredTerminating: Being deleted Conditions: Detailed status information Ready: Instance is fully operationalProgressing: Changes are being appliedDegraded: Operating but not optimalError: Problems detected Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.2.2","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.2.2/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.2.2","tagName":"h2"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.2.2/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.2.2"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.2/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.2.2","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.2/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.2.2","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.2/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.2.2","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.2/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inpsect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.2.2","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.2/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates creation of the a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.2.2","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.2.2/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.2.2","tagName":"h3"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.2.2/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.2.2"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.2.2/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.2.2"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/0.2.1/examples/gcp/eventarc","content":"","keywords":"","version":"0.2.1"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.2.1/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.2.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.2.1/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.2.1","tagName":"h2"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.2.2/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.2.2"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.2.2/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.2.2"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.2.2/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.2.2"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.3.0/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.3.0"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/0.3.0/docs/concepts/access-control","content":"","keywords":"","version":"0.3.0"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/0.3.0/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"0.3.0","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/0.3.0/docs/concepts/access-control#aggregation-access","content":" In the aggreagation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"0.3.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/0.3.0/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"0.3.0","tagName":"h3"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.3.0/docs/concepts/instances","content":"","keywords":"","version":"0.3.0"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.3.0/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.3.0","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.3.0/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.3.0","tagName":"h2"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.3.0/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"0.3.0","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.3.0/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status Running: All resources are readyProgressing: Working towards desired stateFailed: Error occurredTerminating: Being deleted Conditions: Detailed status information Ready: Instance is fully operationalProgressing: Changes are being appliedDegraded: Operating but not optimalError: Problems detected Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.3.0","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.3.0/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.3.0","tagName":"h2"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.3.0/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.3.0"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.3.0/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Defintion) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.3.0","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.3.0/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, namespace, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteriaExternal References  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.3.0","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.3.0/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions} validation: # Validating admission policies added to the new API type's CRD - expression: &quot;${ self.image == 'nginx' || !self.ingress.enabled }&quot; message: &quot;Only nginx based applications can have ingress enabled&quot;   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.3.0","tagName":"h2"},{"title":"ResourceGraphDefinition Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.3.0/docs/concepts/resource-group-definitions#resourcegraphdefinition-processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acycled Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource states  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.3.0","tagName":"h2"},{"title":"ResourceGraphDefinition Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.3.0/docs/concepts/resource-group-definitions#resourcegraphdefinition-instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can can create instances of it. Here's an example of how an instance for theWebApplication might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   ","version":"0.3.0","tagName":"h2"},{"title":"ResourceGraphDefinition More about Resources​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.3.0/docs/concepts/resource-group-definitions#resourcegraphdefinition-more-about-resources","content":" Users can specify more controls in resources in .spec.resources[]  spec: resources: - id: template || externalRef: readyWhen: includeWhen:   Using externalRef An user can specify if the object is something that is created out-of-band and needs to be referenced in the RGD. An external reference could be specified like this:  resources: id: projectConfig externalRef: apiVersion: corp.platform.com/v1 kind: Project metadata: name: default-project namespace: # optional, if empty uses instance namespace   As part of the processing the Resource Graph, the instance reconciler waits for the externalRef object to be present and reads the object from the cluster as a node in the graph. Subsequent resources can use data from this node. ","version":"0.3.0","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.3.0/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.3.0"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.2.2/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.2.2"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/0.2.2/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.2.2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.3.0/examples/","content":"","keywords":"","version":"0.3.0"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.3.0/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.3.0","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.3.0/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.3.0","tagName":"h2"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.3.0/docs/getting-started/Installation","content":"","keywords":"","version":"0.3.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.3.0/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.3.0","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.3.0/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.3.0","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.3.0/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kro-run/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   Troubleshooting Helm Install Note that authentication is not required for pulling charts from public GHCR (GitHub Container Registry) repositories. Helm install download failures occur due to expired local credentials. To resolve this issue, clear your local credentials cache by running helm registry logout ghcr.io in your terminal, then retry the installation.  ","version":"0.3.0","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.3.0/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.3.0","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.3.0/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and re-apply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.3.0","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.3.0/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.3.0","tagName":"h2"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.2.1/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployement on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.2.1"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.3.0/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.3.0"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.2.2/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployement on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.2.2"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/0.3.0/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.3.0"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.3.0/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.3.0"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.3.0/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.3.0"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.2.2/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.2.2"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.3.0/docs/overview","content":"","keywords":"","version":"0.3.0"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.3.0/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Fugure 1: End user interface - Custom API  ","version":"0.3.0","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.3.0/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Fugure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.3.0","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.3.0/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Fugure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.3.0","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.3.0/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.3.0","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.3.0/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.3.0","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.3.0/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.3.0","tagName":"h3"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.3.0/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.3.0"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.3.0/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.3.0"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.3.0/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.3.0"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.3.0/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.3.0"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/0.2.2/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.2.2"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/0.2.2/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.2.2","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/0.2.2/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.2.2","tagName":"h2"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.4.0/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.4.0"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.3.0/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployement on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.3.0"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/0.3.0/examples/gcp/eventarc","content":"","keywords":"","version":"0.3.0"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.3.0/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.3.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.3.0/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.3.0","tagName":"h2"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/0.4.0/docs/concepts/access-control","content":"","keywords":"","version":"0.4.0"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/0.4.0/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"0.4.0","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/0.4.0/docs/concepts/access-control#aggregation-access","content":" In the aggregation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"0.4.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/0.4.0/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"0.4.0","tagName":"h3"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.4.0/docs/concepts/instances","content":"","keywords":"","version":"0.4.0"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.4.0/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.4.0","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.4.0/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.4.0","tagName":"h2"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.4.0/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"0.4.0","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.4.0/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status Running: All resources are readyProgressing: Working towards desired stateFailed: Error occurredTerminating: Being deleted Conditions: Detailed status information Ready: Instance is fully operationalProgressing: Changes are being appliedDegraded: Operating but not optimalError: Problems detected Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.4.0","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.4.0/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.4.0","tagName":"h2"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/0.3.0/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.3.0"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/0.3.0/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.3.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/0.3.0/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.3.0","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.4.0/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.4.0"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/0.3.0/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.3.0"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/0.3.0/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.3.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/0.3.0/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.3.0","tagName":"h2"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.3.0/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.3.0"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.3.0/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.3.0","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.3.0/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.3.0","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.3.0/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.3.0","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.3.0/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inpsect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.3.0","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.3.0/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates creation of the a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.3.0","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.3.0/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.3.0","tagName":"h3"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/0.2.2/examples/gcp/eventarc","content":"","keywords":"","version":"0.2.2"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.2.2/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.2.2","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.2.2/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.2.2","tagName":"h2"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.4.0/docs/getting-started/Installation","content":"","keywords":"","version":"0.4.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.4.0/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.4.0","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.4.0/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.4.0","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.4.0/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kro-run/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   Troubleshooting Helm Install Note that authentication is not required for pulling charts from public GHCR (GitHub Container Registry) repositories. Helm install download failures occur due to expired local credentials. To resolve this issue, clear your local credentials cache by running helm registry logout ghcr.io in your terminal, then retry the installation.  ","version":"0.4.0","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.4.0/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.4.0","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.4.0/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and reapply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.4.0","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.4.0/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.4.0","tagName":"h2"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.4.0/docs/overview","content":"","keywords":"","version":"0.4.0"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.4.0/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Figure 1: End user interface - Custom API  ","version":"0.4.0","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.4.0/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for the Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Figure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.4.0","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.4.0/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Figure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.4.0","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.4.0/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.4.0","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.4.0/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.4.0","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.4.0/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.4.0","tagName":"h3"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.4.0/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.4.0"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.0/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Definition) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.4.0","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.0/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, namespace, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteriaExternal References  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.4.0","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.0/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions} validation: # Validating admission policies added to the new API type's CRD - expression: &quot;${ self.image == 'nginx' || !self.ingress.enabled }&quot; message: &quot;Only nginx based applications can have ingress enabled&quot; additionalPrinterColumns: # Printer columns shown for the created custom resource - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.4.0","tagName":"h2"},{"title":"ResourceGraphDefinition Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.0/docs/concepts/resource-group-definitions#resourcegraphdefinition-processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acyclic Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource states  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.4.0","tagName":"h2"},{"title":"ResourceGraphDefinition Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.0/docs/concepts/resource-group-definitions#resourcegraphdefinition-instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can create instances of it. Here's an example of how an instance for theWebApplication might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   ","version":"0.4.0","tagName":"h2"},{"title":"ResourceGraphDefinition More about Resources​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.0/docs/concepts/resource-group-definitions#resourcegraphdefinition-more-about-resources","content":" Users can specify more controls in resources in .spec.resources[]  spec: resources: - id: template || externalRef: readyWhen: includeWhen:   Using externalRef An user can specify if the object is something that is created out-of-band and needs to be referenced in the RGD. An external reference could be specified like this:  resources: id: projectConfig externalRef: apiVersion: corp.platform.com/v1 kind: Project metadata: name: default-project namespace: # optional, if empty uses instance namespace   As part of processing the Resource Graph, the instance reconciler waits for the externalRef object to be present and reads the object from the cluster as a node in the graph. Subsequent resources can use data from this node. ","version":"0.4.0","tagName":"h2"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.3.0/docs/concepts/simple-schema","content":"","keywords":"","version":"0.3.0"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.3.0","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesfloat: Decimal numbers  For example:  name: string age: integer enabled: boolean price: float   ","version":"0.3.0","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.3.0","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.3.0","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]float&quot;   ","version":"0.3.0","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#custom-types","content":" Custom types are specified in the separate types section. They provide a map of names to type specifications, that follow the simple schema.  Example:  schema: types: Person: name: string age: integer spec: people: '[]Person | required=true`   ","version":"0.3.0","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.3.0","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbers  Multiple markers can be combined using the | separator.  For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 price: float | minimum=0.01 maximum=999.99 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.3.0","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources existUpdates values when the underlying resources change  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} endpoint: ${service.status.loadBalancer.ingress[0].hostname}   ","version":"0.3.0","tagName":"h2"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.3.0","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;Progressing&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string reason: string message: string   Common condition types:  Ready: Instance is fully reconciledProgressing: Working towards desired stateDegraded: Operational but not optimalError: Reconciliation error occurred  ","version":"0.3.0","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.3.0/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # Ready, Progressing, Degraded, Unknown, Deleting   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values. ","version":"0.3.0","tagName":"h3"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.4.0/examples/","content":"","keywords":"","version":"0.4.0"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.4.0/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.4.0","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.4.0/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.4.0","tagName":"h2"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.2.2/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.2.2"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.4.0/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.4.0"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.4.0/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.4.0"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/0.4.0/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.4.0"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.3.0/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.3.0"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.4.0/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.4.0"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.0/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.4.0","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.0/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.4.0","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.0/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.4.0","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.0/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inspect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.4.0","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.0/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates the creation of a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.4.0","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.0/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.4.0","tagName":"h3"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.4.0/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.4.0"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.4.0/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.4.0"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.4.0/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.4.0"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/0.2.2/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.2.2"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/0.2.2/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.2.2","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/0.2.2/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.2.2","tagName":"h2"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.4.1/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.4.1"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.4.0/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.4.0"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/0.4.1/docs/concepts/access-control","content":"","keywords":"","version":"0.4.1"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/0.4.1/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"0.4.1","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/0.4.1/docs/concepts/access-control#aggregation-access","content":" In the aggregation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"0.4.1","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/0.4.1/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"0.4.1","tagName":"h3"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.4.1/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.4.1"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.4.1/docs/concepts/instances","content":"","keywords":"","version":"0.4.1"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.4.1/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.4.1","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.4.1/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.4.1","tagName":"h2"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.4.1/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"0.4.1","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.4.1/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status ACTIVE: Indicates that the instance is successfully running and active.IN_PROGRESS: Indicates that the instance is currently being processed or reconciled.FAILED: Indicates that the instance has failed to be properly reconciled.DELETING: Indicates that the instance is in the process of being deleted.ERROR: Indicates that an error occurred during instance processing. Conditions: Detailed status information Ready: Instance is fully operationalProgressing: Changes are being appliedDegraded: Operating but not optimalError: Problems detected Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.4.1","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.4.1/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.4.1","tagName":"h2"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/0.4.0/examples/gcp/eventarc","content":"","keywords":"","version":"0.4.0"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.4.0/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.4.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.4.0/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.4.0","tagName":"h2"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/0.4.0/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.4.0"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/0.4.0/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.4.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/0.4.0/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.4.0","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.4.1/examples/","content":"","keywords":"","version":"0.4.1"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.4.1/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.4.1","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.4.1/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.4.1","tagName":"h2"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.4.1/docs/overview","content":"","keywords":"","version":"0.4.1"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.4.1/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Figure 1: End user interface - Custom API  ","version":"0.4.1","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.4.1/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for the Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Figure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.4.1","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.4.1/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Figure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.4.1","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.4.1/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.4.1","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.4.1/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.4.1","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.4.1/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.4.1","tagName":"h3"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.4.0/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.4.0"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.4.1/docs/getting-started/Installation","content":"","keywords":"","version":"0.4.1"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.4.1/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.4.1","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.4.1/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.4.1","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.4.1/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kro-run/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   Troubleshooting Helm Install Note that authentication is not required for pulling charts from public GHCR (GitHub Container Registry) repositories. Helm install download failures occur due to expired local credentials. To resolve this issue, clear your local credentials cache by running helm registry logout ghcr.io in your terminal, then retry the installation.  ","version":"0.4.1","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.4.1/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.4.1","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.4.1/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://ghcr.io/kro-run/kro/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and reapply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.4.1","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.4.1/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.4.1","tagName":"h2"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.4.1/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.4.1"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.1/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.4.1","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.1/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.4.1","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.1/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.4.1","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.1/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inspect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.4.1","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.1/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates the creation of a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.4.1","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.4.1/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.4.1","tagName":"h3"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.4.0/docs/concepts/simple-schema","content":"","keywords":"","version":"0.4.0"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.4.0","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesfloat: Decimal numbers  For example:  name: string age: integer enabled: boolean price: float   ","version":"0.4.0","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.4.0","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.4.0","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]float&quot;   ","version":"0.4.0","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#custom-types","content":" Custom types are specified in the separate types section. They provide a map of names to type specifications that follow the simple schema.  Example:  schema: types: Person: name: string age: integer spec: people: '[]Person | required=true`   ","version":"0.4.0","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.4.0","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbers  Multiple markers can be combined using the | separator.  For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 price: float | minimum=0.01 maximum=999.99 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.4.0","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources existUpdates values when the underlying resources change  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} endpoint: ${service.status.loadBalancer.ingress[0].hostname}   ","version":"0.4.0","tagName":"h2"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.4.0","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;Progressing&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string reason: string message: string   Common condition types:  Ready: Instance is fully reconciledProgressing: Working towards desired stateDegraded: Operational but not optimalError: Reconciliation error occurred  ","version":"0.4.0","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # Ready, Progressing, Degraded, Unknown, Deleting   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values.  ","version":"0.4.0","tagName":"h3"},{"title":"Additional Printer Columns​","type":1,"pageTitle":"Simple Schema","url":"/0.4.0/docs/concepts/simple-schema#additional-printer-columns","content":" You can define additionalPrinterColumns for the created CRD through the ResourceGraphDefinition by setting them on spec.schema.additionalPrinterColumns.  schema: spec: image: string | default=&quot;nginx&quot; status: availableReplicas: ${deployment.status.availableReplicas} additionalPrinterColumns: - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string  ","version":"0.4.0","tagName":"h2"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.4.1/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.4.1"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.4.1/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.4.1"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/0.4.1/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.4.1"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.4.1/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.4.1"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.4.1/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.4.1"},{"title":"Optional Values & External References","type":0,"sectionRef":"#","url":"/0.4.1/examples/basic/optionals","content":"Optional Values &amp; External References config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: ECHO_VALUE: &quot;Hello, World!&quot; deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: input externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $MY_VALUE &amp;&amp; sleep 3600&quot;] env: - name: MY_VALUE value: ${input.data.?ECHO_VALUE} ","keywords":"","version":"0.4.1"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.4.1/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.4.1"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.1/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Definition) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.4.1","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.1/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteriaExternal References  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.4.1","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.1/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions} validation: # Validating admission policies added to the new API type's CRD - expression: &quot;${ self.image == 'nginx' || !self.ingress.enabled }&quot; message: &quot;Only nginx based applications can have ingress enabled&quot; additionalPrinterColumns: # Printer columns shown for the created custom resource - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.4.1","tagName":"h2"},{"title":"Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.1/docs/concepts/resource-group-definitions#processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acyclic Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource states  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.4.1","tagName":"h2"},{"title":"Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.1/docs/concepts/resource-group-definitions#instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can create instances of it. Here's an example of how an instance for theWebApplication might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   ","version":"0.4.1","tagName":"h2"},{"title":"More about Resources​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.1/docs/concepts/resource-group-definitions#more-about-resources","content":" Users can specify more controls in resources in .spec.resources[]  spec: resources: - id: my-resource template || externalRef: {} # users can either template resources or reference objects outside the graph readyWhen: # users can specify CEL expressions to determine when a resource is ready - ${deployment.status.conditions.exists(x, x.type == 'Available' &amp;&amp; x.status == &quot;True&quot;)} includeWhen: # users can specify CEL expressions to determine when a resource should be included in the graph - ${schema.spec.value.enabled}   ","version":"0.4.1","tagName":"h2"},{"title":"Using externalRef to reference Objects outside the ResourceGraphDefinition.​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.1/docs/concepts/resource-group-definitions#using-externalref-to-reference-objects-outside-the-resourcegraphdefinition","content":" Users can specify if the object is something that is created out-of-band and needs to be referenced in the RGD. An external reference could be specified like this:  resources: id: projectConfig externalRef: apiVersion: corp.platform.com/v1 kind: Project metadata: name: default-project namespace: # optional, if empty uses instance namespace   As part of processing the Resource Graph, the instance reconciler waits for the externalRef object to be present and reads the object from the cluster as a node in the graph. Subsequent resources can use data from this node.  ","version":"0.4.1","tagName":"h3"},{"title":"Using Conditional CEL Expressions (?)​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.1/docs/concepts/resource-group-definitions#using-conditional-cel-expressions-","content":" KRO can make use of CEL Expressions (see this proposal for details or look at the CEL Implementation Reference) to define optional runtime conditions for resources based on the conditional operator ?.  This allows you to optionally define values that have no predefined schema or are not hard dependencies in the Graph.  Using ? for referencing schema-less objects like ConfigMap or Secret​  You can use the optional operator to reference objects that do not have a predefined schema in the ResourceGraphDefinition. This is useful for referencing objects that may or may not exist at runtime.  ⚠️ ? removes the ability of KRO to introspect the schema of the referenced object. Thus, it cannot wait for fields after the ? to be present. It is recommended to use conditional expressions only for objects that are not critical to the ResourceGraphDefinition's operation or when the schema cannot be known at design time.  A config map can be referenced like this:  config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: VALUE: &quot;foobar&quot;   external reference in ResourceGraphDefinition - id: external externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default   With this reference, you can access the data in your schema:  CEL Expression ${external.data.?VALUE}   ⚠️ KRO will only wait for the external reference to be present in the cluster, but it will not validate the schema of the referenced config. If the config map does not have the VALUE field, the expression will evaluate to null and might result in unexpected behavior in your application if not handled properly.  For a more detailed example, see the Optional Values &amp; External References documentation.  ","version":"0.4.1","tagName":"h3"},{"title":"Status Reporting​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.4.1/docs/concepts/resource-group-definitions#status-reporting","content":" The status section of a ResourceGraphDefinition provides information about the state of the graph and it's generated CustomResourceDefinition and controller.  status includes a stable Ready condition (as well as a set of technical status.conditions that provide more detailed information about the state of the graph and its resources).  info When the Ready condition status is True, it indicates that the ResourceGraphDefinition is valid and you can use it to create instances.  warning Try to only rely on the Ready condition, as other condition types may change frequently and are more technical in nature, can change their API over time and are generally more indicative of KRO's internal state.  Additionally, the ResourceGraphDefinition contains a topologicalOrder field that provides a list of resources in the order they should be processed. This is useful for understanding the dependencies between resources and their apply order.  Generally a status in ResourceGraphDefinition may look like  status: conditions: - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: resource graph and schema are valid observedGeneration: 1 reason: Valid status: &quot;True&quot; type: ResourceGraphAccepted - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: kind DeploymentService has been accepted and ready observedGeneration: 1 reason: Ready status: &quot;True&quot; type: KindReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: controller is running observedGeneration: 1 reason: Running status: &quot;True&quot; type: ControllerReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready state: Active topologicalOrder: - configmap - deployment  ","version":"0.4.1","tagName":"h2"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.4.1/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.4.1"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.4.1/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.4.1"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.4.1/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.4.1"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.5.0/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.5.0"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/0.5.0/docs/concepts/access-control","content":"","keywords":"","version":"0.5.0"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/0.5.0/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"0.5.0","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/0.5.0/docs/concepts/access-control#aggregation-access","content":" In the aggregation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"0.5.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/0.5.0/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"0.5.0","tagName":"h3"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/0.4.1/examples/gcp/eventarc","content":"","keywords":"","version":"0.4.1"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.4.1/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.4.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.4.1/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.4.1","tagName":"h2"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.5.0/docs/concepts/instances","content":"","keywords":"","version":"0.5.0"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.5.0/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.5.0","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.5.0/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.5.0","tagName":"h2"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.5.0/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"0.5.0","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.5.0/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status ACTIVE: Indicates that the instance is successfully running and active.IN_PROGRESS: Indicates that the instance is currently being processed or reconciled.FAILED: Indicates that the instance has failed to be properly reconciled.DELETING: Indicates that the instance is in the process of being deleted.ERROR: Indicates that an error occurred during instance processing. Conditions: Detailed status information Ready: Instance is fully operationalProgressing: Changes are being appliedDegraded: Operating but not optimalError: Problems detected Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.5.0","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.5.0/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.5.0","tagName":"h2"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.4.1/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployment on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.4.1"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.5.0/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.5.0"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.0/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Definition) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.5.0","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.0/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteriaExternal References  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.5.0","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.0/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions} validation: # Validating admission policies added to the new API type's CRD - expression: &quot;${ self.image == 'nginx' || !self.ingress.enabled }&quot; message: &quot;Only nginx based applications can have ingress enabled&quot; additionalPrinterColumns: # Printer columns shown for the created custom resource - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.5.0","tagName":"h2"},{"title":"Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.0/docs/concepts/resource-group-definitions#processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acyclic Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource states  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.5.0","tagName":"h2"},{"title":"Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.0/docs/concepts/resource-group-definitions#instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can create instances of it. Here's an example of how an instance for theWebApplication might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   ","version":"0.5.0","tagName":"h2"},{"title":"More about Resources​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.0/docs/concepts/resource-group-definitions#more-about-resources","content":" Users can specify more controls in resources in .spec.resources[]  spec: resources: - id: my-resource template || externalRef: {} # users can either template resources or reference objects outside the graph readyWhen: # users can specify CEL expressions to determine when a resource is ready - ${deployment.status.conditions.exists(x, x.type == 'Available' &amp;&amp; x.status == &quot;True&quot;)} includeWhen: # users can specify CEL expressions to determine when a resource should be included in the graph - ${schema.spec.value.enabled}   ","version":"0.5.0","tagName":"h2"},{"title":"Using externalRef to reference Objects outside the ResourceGraphDefinition.​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.0/docs/concepts/resource-group-definitions#using-externalref-to-reference-objects-outside-the-resourcegraphdefinition","content":" Users can specify if the object is something that is created out-of-band and needs to be referenced in the RGD. An external reference could be specified like this:  resources: id: projectConfig externalRef: apiVersion: corp.platform.com/v1 kind: Project metadata: name: default-project namespace: # optional, if empty uses instance namespace   As part of processing the Resource Graph, the instance reconciler waits for the externalRef object to be present and reads the object from the cluster as a node in the graph. Subsequent resources can use data from this node.  ","version":"0.5.0","tagName":"h3"},{"title":"Using Conditional CEL Expressions (?)​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.0/docs/concepts/resource-group-definitions#using-conditional-cel-expressions-","content":" KRO can make use of CEL Expressions (see this proposal for details or look at the CEL Implementation Reference) to define optional runtime conditions for resources based on the conditional operator ?.  This allows you to optionally define values that have no predefined schema or are not hard dependencies in the Graph.  Using ? for referencing schema-less objects like ConfigMap or Secret​  You can use the optional operator to reference objects that do not have a predefined schema in the ResourceGraphDefinition. This is useful for referencing objects that may or may not exist at runtime.  ⚠️ ? removes the ability of KRO to introspect the schema of the referenced object. Thus, it cannot wait for fields after the ? to be present. It is recommended to use conditional expressions only for objects that are not critical to the ResourceGraphDefinition's operation or when the schema cannot be known at design time.  A config map can be referenced like this:  config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: VALUE: &quot;foobar&quot;   external reference in ResourceGraphDefinition - id: external externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default   With this reference, you can access the data in your schema:  CEL Expression ${external.data.?VALUE}   ⚠️ KRO will only wait for the external reference to be present in the cluster, but it will not validate the schema of the referenced config. If the config map does not have the VALUE field, the expression will evaluate to null and might result in unexpected behavior in your application if not handled properly.  For a more detailed example, see the Optional Values &amp; External References documentation.  ","version":"0.5.0","tagName":"h3"},{"title":"Status Reporting​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.0/docs/concepts/resource-group-definitions#status-reporting","content":" The status section of a ResourceGraphDefinition provides information about the state of the graph and it's generated CustomResourceDefinition and controller.  status includes a stable Ready condition (as well as a set of technical status.conditions that provide more detailed information about the state of the graph and its resources).  info When the Ready condition status is True, it indicates that the ResourceGraphDefinition is valid and you can use it to create instances.  warning Try to only rely on the Ready condition, as other condition types may change frequently and are more technical in nature, can change their API over time and are generally more indicative of KRO's internal state.  Additionally, the ResourceGraphDefinition contains a topologicalOrder field that provides a list of resources in the order they should be processed. This is useful for understanding the dependencies between resources and their apply order.  Generally a status in ResourceGraphDefinition may look like  status: conditions: - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: resource graph and schema are valid observedGeneration: 1 reason: Valid status: &quot;True&quot; type: ResourceGraphAccepted - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: kind DeploymentService has been accepted and ready observedGeneration: 1 reason: Ready status: &quot;True&quot; type: KindReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: controller is running observedGeneration: 1 reason: Running status: &quot;True&quot; type: ControllerReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready state: Active topologicalOrder: - configmap - deployment  ","version":"0.5.0","tagName":"h2"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/0.4.1/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.4.1"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/0.4.1/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.4.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/0.4.1/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.4.1","tagName":"h2"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/0.4.0/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.4.0"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/0.4.0/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.4.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/0.4.0/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.4.0","tagName":"h2"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.4.0/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.4.0"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.4.1/docs/concepts/simple-schema","content":"","keywords":"","version":"0.4.1"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.4.1","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesfloat: Decimal numbers  For example:  name: string age: integer enabled: boolean price: float   ","version":"0.4.1","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.4.1","tagName":"h3"},{"title":"Unstructured Objects​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#unstructured-objects","content":" Unstructured objects are declared using object as a type.  warning This disables the field-validation normally offered by kro, and forwards the values to your RGD as-is. This is generally discouraged and should therefore be used with caution. In most cases, using a structured object is a better approach.  kind: ResourceGraphDefintion metadata: {} spec: schema: spec: additionalHelmChartValues: object   This allows you to pass data to your CRDs directly in cases where the schema is not known in advance. This type supports any valid object, and can mix and match different primitives as well as structured types.  apiVersion: kro.run/v1alpha1 kind: CRDWithUnstructuredObjects metadata: name: test-instance spec: additionalHelmChartValues: boolean-value: true numeric-value: 42 structural-type: with-additional: nested: fields string-value: my-string mapping-value: - item1 - item2 - item3   ","version":"0.4.1","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.4.1","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]float&quot;   ","version":"0.4.1","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#custom-types","content":" Custom types are specified in the separate types section. They provide a map of names to type specifications that follow the simple schema.  Example:  schema: types: Person: name: string age: integer spec: people: '[]Person | required=true`   ","version":"0.4.1","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.4.1","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbers  Multiple markers can be combined using the | separator.  For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 price: float | minimum=0.01 maximum=999.99 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.4.1","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources existUpdates values when the underlying resources change  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} endpoint: ${service.status.loadBalancer.ingress[0].hostname}   ","version":"0.4.1","tagName":"h2"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.4.1","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;Progressing&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string reason: string message: string   Common condition types:  Ready: Instance is fully reconciledProgressing: Working towards desired stateDegraded: Operational but not optimalError: Reconciliation error occurred  ","version":"0.4.1","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # Ready, Progressing, Degraded, Unknown, Deleting   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values.  ","version":"0.4.1","tagName":"h3"},{"title":"Additional Printer Columns​","type":1,"pageTitle":"Simple Schema","url":"/0.4.1/docs/concepts/simple-schema#additional-printer-columns","content":" You can define additionalPrinterColumns for the created CRD through the ResourceGraphDefinition by setting them on spec.schema.additionalPrinterColumns.  schema: spec: image: string | default=&quot;nginx&quot; status: availableReplicas: ${deployment.status.availableReplicas} additionalPrinterColumns: - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string  ","version":"0.4.1","tagName":"h2"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.5.0/docs/concepts/simple-schema","content":"","keywords":"","version":"0.5.0"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.5.0","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesfloat: Decimal numbers  For example:  name: string age: integer enabled: boolean price: float   ","version":"0.5.0","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.5.0","tagName":"h3"},{"title":"Unstructured Objects​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#unstructured-objects","content":" Unstructured objects are declared using object as a type.  warning This disables the field-validation normally offered by kro, and forwards the values to your RGD as-is. This is generally discouraged and should therefore be used with caution. In most cases, using a structured object is a better approach.  kind: ResourceGraphDefintion metadata: {} spec: schema: spec: additionalHelmChartValues: object   This allows you to pass data to your CRDs directly in cases where the schema is not known in advance. This type supports any valid object, and can mix and match different primitives as well as structured types.  apiVersion: kro.run/v1alpha1 kind: CRDWithUnstructuredObjects metadata: name: test-instance spec: additionalHelmChartValues: boolean-value: true numeric-value: 42 structural-type: with-additional: nested: fields string-value: my-string mapping-value: - item1 - item2 - item3   ","version":"0.5.0","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.5.0","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]float&quot;   ","version":"0.5.0","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#custom-types","content":" Custom types are specified in the separate types section. They provide a map of names to type specifications that follow the simple schema.  Example:  schema: types: Person: name: string age: integer spec: people: '[]Person | required=true`   ","version":"0.5.0","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.5.0","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbersimmutable=true: Field cannot be changed after creationpattern=&quot;regex&quot;: Regular expression pattern for string validationminLength=number: Minimum length for stringsmaxLength=number: Maximum length for stringsuniqueItems=true: Ensures array elements are uniqueminItems=number: Minimum number of items in arraysmaxItems=number: Maximum number of items in arrays  Multiple markers can be combined using the | separator.  ","version":"0.5.0","tagName":"h3"},{"title":"String Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#string-validation-markers","content":" String fields support additional validation markers:  pattern=&quot;regex&quot;: Validates the string against a regular expression patternminLength=number: Sets the minimum number of charactersmaxLength=number: Sets the maximum number of characters  Examples:  # Email validation email: string | pattern=&quot;^[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w+$&quot; required=true # Username with length constraints and pattern username: string | minLength=3 maxLength=15 pattern=&quot;^[a-zA-Z0-9_]+$&quot; # Country code format countryCode: string | pattern=&quot;^[A-Z]{2}$&quot; minLength=2 maxLength=2 # Password with minimum length password: string | minLength=8 description=&quot;Password must be at least 8 characters&quot;   ","version":"0.5.0","tagName":"h3"},{"title":"Array Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#array-validation-markers","content":" Array fields support validation markers to ensure data quality:  uniqueItems=true: Ensures all elements in the array are uniqueuniqueItems=false: Allows duplicate elements (default behavior)minItems=number: Sets the minimum number of elements required in the arraymaxItems=number: Sets the maximum number of elements allowed in the array  Examples:  # Unique tags with size constraints tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot; # Unique port numbers with minimum requirement ports: &quot;[]integer&quot; | uniqueItems=true minItems=1 description=&quot;At least one unique port&quot; # Allow duplicate comments with size limits comments: &quot;[]string&quot; | uniqueItems=false maxItems=50 description=&quot;Up to 50 comments&quot; # Complex validation with multiple markers roles: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=5 required=true description=&quot;1-5 unique user roles&quot; # Optional array with size constraints priorities: &quot;[]integer&quot; | minItems=0 maxItems=3 description=&quot;Up to 3 priority levels&quot;   For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; id: string | required=true immutable=true description=&quot;Unique identifier&quot; replicas: integer | default=3 minimum=1 maximum=10 price: float | minimum=0.01 maximum=999.99 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot; email: string | pattern=&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$&quot; description=&quot;Valid email address&quot; username: string | minLength=3 maxLength=20 pattern=&quot;^[a-zA-Z0-9_]+$&quot; tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot;   ","version":"0.5.0","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources existUpdates values when the underlying resources change  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} endpoint: ${service.status.loadBalancer.ingress[0].hostname}   ","version":"0.5.0","tagName":"h2"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.5.0","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;Progressing&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string reason: string message: string   Common condition types:  Ready: Instance is fully reconciledProgressing: Working towards desired stateDegraded: Operational but not optimalError: Reconciliation error occurred  ","version":"0.5.0","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # Ready, Progressing, Degraded, Unknown, Deleting   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values.  ","version":"0.5.0","tagName":"h3"},{"title":"Additional Printer Columns​","type":1,"pageTitle":"Simple Schema","url":"/0.5.0/docs/concepts/simple-schema#additional-printer-columns","content":" You can define additionalPrinterColumns for the created CRD through the ResourceGraphDefinition by setting them on spec.schema.additionalPrinterColumns.  schema: spec: image: string | default=&quot;nginx&quot; status: availableReplicas: ${deployment.status.availableReplicas} additionalPrinterColumns: - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string  ","version":"0.5.0","tagName":"h2"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.5.0/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.5.0"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.0/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.5.0","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.0/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.5.0","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.0/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.5.0","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.0/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inspect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.5.0","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.0/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates the creation of a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.5.0","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.0/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.5.0","tagName":"h3"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/0.4.1/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.4.1"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/0.4.1/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.4.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/0.4.1/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.4.1","tagName":"h2"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.5.0/docs/getting-started/Installation","content":"","keywords":"","version":"0.5.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.5.0/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.5.0","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.5.0/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.5.0","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.5.0/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kubernetes-sigs/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   Troubleshooting Helm Install Note that authentication is not required for pulling charts from public GHCR (GitHub Container Registry) repositories. Helm install download failures occur due to expired local credentials. To resolve this issue, clear your local credentials cache by running helm registry logout ghcr.io in your terminal, then retry the installation.  ","version":"0.5.0","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.5.0/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.5.0","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.5.0/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and reapply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.5.0","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.5.0/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.5.0","tagName":"h2"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.5.0/docs/overview","content":"","keywords":"","version":"0.5.0"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.5.0/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Figure 1: End user interface - Custom API  ","version":"0.5.0","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.5.0/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for the Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Figure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.5.0","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.5.0/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Figure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.5.0","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.5.0/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.5.0","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.5.0/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.5.0","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.5.0/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.5.0","tagName":"h3"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.5.0/examples/","content":"","keywords":"","version":"0.5.0"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.5.0/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.5.0","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.5.0/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.5.0","tagName":"h2"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.5.0/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.5.0"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.4.0/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployment on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.4.0"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.5.0/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.5.0"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.5.0/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. How do I use KRO resources with ArgoCD? To use KRO resources with ArgoCD, you need to add a specific tracking annotation to all templated resources in your ResourceGraphDefinition. The following code needs to be added to each templated resource: metadata: ownerReferences: - apiVersion: kro.run/v1alpha1 kind: ${schema.kind} name: ${schema.metadata.name} uid: ${schema.metadata.uid} blockOwnerDeletion: true controller: false annotations: argocd.argoproj.io/tracking-id: ${schema.metadata.?annotations[&quot;argocd.argoproj.io/tracking-id&quot;]} This annotation allows ArgoCD to properly track and manage the resources created by KRO instances. Note that the example shown above depicts ArgoCD's default resource tracking via annotations. You may choose to use annotation+label or just label and if so the example has to be modified to support your configuration. For more detailed information about ArgoCD resource tracking, please see theArgoCD documentation. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.5.0"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.5.0/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.5.0"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.5.0/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.5.0"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.5.0/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.5.0"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.5.1/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.5.1"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.5.0/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.5.0"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/0.5.0/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.5.0"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/0.5.1/docs/concepts/access-control","content":"","keywords":"","version":"0.5.1"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/0.5.1/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"0.5.1","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/0.5.1/docs/concepts/access-control#aggregation-access","content":" In the aggregation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"0.5.1","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/0.5.1/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"0.5.1","tagName":"h3"},{"title":"Optional Values & External References","type":0,"sectionRef":"#","url":"/0.5.0/examples/basic/optionals","content":"Optional Values &amp; External References config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: ECHO_VALUE: &quot;Hello, World!&quot; deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: input externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $MY_VALUE &amp;&amp; sleep 3600&quot;] env: - name: MY_VALUE value: ${input.data.?ECHO_VALUE} ","keywords":"","version":"0.5.0"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.5.0/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.5.0"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/0.5.0/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.5.0"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/0.5.0/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.5.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/0.5.0/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.5.0","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.5.1/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. How do I use KRO resources with ArgoCD? To use KRO resources with ArgoCD, you need to add a specific tracking annotation to all templated resources in your ResourceGraphDefinition. The following code needs to be added to each templated resource: metadata: ownerReferences: - apiVersion: kro.run/v1alpha1 kind: ${schema.kind} name: ${schema.metadata.name} uid: ${schema.metadata.uid} blockOwnerDeletion: true controller: false annotations: argocd.argoproj.io/tracking-id: ${schema.metadata.?annotations[&quot;argocd.argoproj.io/tracking-id&quot;]} This annotation allows ArgoCD to properly track and manage the resources created by KRO instances. Note that the example shown above depicts ArgoCD's default resource tracking via annotations. You may choose to use annotation+label or just label and if so the example has to be modified to support your configuration. For more detailed information about ArgoCD resource tracking, please see theArgoCD documentation. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.5.1"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.5.0/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.5.0"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.5.1/docs/concepts/instances","content":"","keywords":"","version":"0.5.1"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.5.1/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.5.1","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.5.1/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.5.1","tagName":"h2"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.5.1/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"0.5.1","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.5.1/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status ACTIVE: Indicates that the instance is successfully running and active.IN_PROGRESS: Indicates that the instance is currently being processed or reconciled.FAILED: Indicates that the instance has failed to be properly reconciled.DELETING: Indicates that the instance is in the process of being deleted.ERROR: Indicates that an error occurred during instance processing. Conditions: Detailed status information Ready: Instance is fully operationalProgressing: Changes are being appliedDegraded: Operating but not optimalError: Problems detected Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.5.1","tagName":"h3"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.5.1/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.5.1","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.5.1/examples/","content":"","keywords":"","version":"0.5.1"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.5.1/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.5.1","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.5.1/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.5.1","tagName":"h2"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.5.1/docs/overview","content":"","keywords":"","version":"0.5.1"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.5.1/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Figure 1: End user interface - Custom API  ","version":"0.5.1","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.5.1/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for the Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Figure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.5.1","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.5.1/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Figure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.5.1","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.5.1/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.5.1","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.5.1/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.5.1","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.5.1/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.5.1","tagName":"h3"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/0.5.0/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.5.0"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/0.5.0/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.5.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/0.5.0/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.5.0","tagName":"h2"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/0.5.0/examples/gcp/eventarc","content":"","keywords":"","version":"0.5.0"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.5.0/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.5.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.5.0/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.5.0","tagName":"h2"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.5.1/docs/concepts/simple-schema","content":"","keywords":"","version":"0.5.1"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.5.1","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesfloat: Decimal numbers  For example:  name: string age: integer enabled: boolean price: float   ","version":"0.5.1","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.5.1","tagName":"h3"},{"title":"Unstructured Objects​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#unstructured-objects","content":" Unstructured objects are declared using object as a type.  warning This disables the field-validation normally offered by kro, and forwards the values to your RGD as-is. This is generally discouraged and should therefore be used with caution. In most cases, using a structured object is a better approach.  kind: ResourceGraphDefintion metadata: {} spec: schema: spec: additionalHelmChartValues: object   This allows you to pass data to your CRDs directly in cases where the schema is not known in advance. This type supports any valid object, and can mix and match different primitives as well as structured types.  apiVersion: kro.run/v1alpha1 kind: CRDWithUnstructuredObjects metadata: name: test-instance spec: additionalHelmChartValues: boolean-value: true numeric-value: 42 structural-type: with-additional: nested: fields string-value: my-string mapping-value: - item1 - item2 - item3   ","version":"0.5.1","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.5.1","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]float&quot;   ","version":"0.5.1","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#custom-types","content":" Custom types are specified in the separate types section. They provide a map of names to type specifications that follow the simple schema.  Example:  schema: types: Person: name: string age: integer spec: people: '[]Person | required=true`   ","version":"0.5.1","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.5.1","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbersimmutable=true: Field cannot be changed after creationpattern=&quot;regex&quot;: Regular expression pattern for string validationminLength=number: Minimum length for stringsmaxLength=number: Maximum length for stringsuniqueItems=true: Ensures array elements are uniqueminItems=number: Minimum number of items in arraysmaxItems=number: Maximum number of items in arrays  Multiple markers can be combined using the | separator.  ","version":"0.5.1","tagName":"h3"},{"title":"String Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#string-validation-markers","content":" String fields support additional validation markers:  pattern=&quot;regex&quot;: Validates the string against a regular expression patternminLength=number: Sets the minimum number of charactersmaxLength=number: Sets the maximum number of characters  Examples:  # Email validation email: string | pattern=&quot;^[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w+$&quot; required=true # Username with length constraints and pattern username: string | minLength=3 maxLength=15 pattern=&quot;^[a-zA-Z0-9_]+$&quot; # Country code format countryCode: string | pattern=&quot;^[A-Z]{2}$&quot; minLength=2 maxLength=2 # Password with minimum length password: string | minLength=8 description=&quot;Password must be at least 8 characters&quot;   ","version":"0.5.1","tagName":"h3"},{"title":"Array Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#array-validation-markers","content":" Array fields support validation markers to ensure data quality:  uniqueItems=true: Ensures all elements in the array are uniqueuniqueItems=false: Allows duplicate elements (default behavior)minItems=number: Sets the minimum number of elements required in the arraymaxItems=number: Sets the maximum number of elements allowed in the array  Examples:  # Unique tags with size constraints tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot; # Unique port numbers with minimum requirement ports: &quot;[]integer&quot; | uniqueItems=true minItems=1 description=&quot;At least one unique port&quot; # Allow duplicate comments with size limits comments: &quot;[]string&quot; | uniqueItems=false maxItems=50 description=&quot;Up to 50 comments&quot; # Complex validation with multiple markers roles: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=5 required=true description=&quot;1-5 unique user roles&quot; # Optional array with size constraints priorities: &quot;[]integer&quot; | minItems=0 maxItems=3 description=&quot;Up to 3 priority levels&quot;   For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; id: string | required=true immutable=true description=&quot;Unique identifier&quot; replicas: integer | default=3 minimum=1 maximum=10 price: float | minimum=0.01 maximum=999.99 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot; email: string | pattern=&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$&quot; description=&quot;Valid email address&quot; username: string | minLength=3 maxLength=20 pattern=&quot;^[a-zA-Z0-9_]+$&quot; tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot;   ","version":"0.5.1","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources existUpdates values when the underlying resources change  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} endpoint: ${service.status.loadBalancer.ingress[0].hostname}   ","version":"0.5.1","tagName":"h2"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.5.1","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;Progressing&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string reason: string message: string   Common condition types:  Ready: Instance is fully reconciledProgressing: Working towards desired stateDegraded: Operational but not optimalError: Reconciliation error occurred  ","version":"0.5.1","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # Ready, Progressing, Degraded, Unknown, Deleting   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values.  ","version":"0.5.1","tagName":"h3"},{"title":"Additional Printer Columns​","type":1,"pageTitle":"Simple Schema","url":"/0.5.1/docs/concepts/simple-schema#additional-printer-columns","content":" You can define additionalPrinterColumns for the created CRD through the ResourceGraphDefinition by setting them on spec.schema.additionalPrinterColumns.  schema: spec: image: string | default=&quot;nginx&quot; status: availableReplicas: ${deployment.status.availableReplicas} additionalPrinterColumns: - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string  ","version":"0.5.1","tagName":"h2"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/0.5.1/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.5.1"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.4.1/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.4.1"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.5.1/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.5.1"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.5.1/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.5.1"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.5.1/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.5.1"},{"title":"Optional Values & External References","type":0,"sectionRef":"#","url":"/0.5.1/examples/basic/optionals","content":"Optional Values &amp; External References config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: ECHO_VALUE: &quot;Hello, World!&quot; deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: input externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $MY_VALUE &amp;&amp; sleep 3600&quot;] env: - name: MY_VALUE value: ${input.data.?ECHO_VALUE} ","keywords":"","version":"0.5.1"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.5.0/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployment on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.5.0"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.5.1/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.5.1"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.5.1/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.5.1"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.5.1/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.5.1"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.5.1/docs/getting-started/Installation","content":"","keywords":"","version":"0.5.1"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.5.1/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.5.1","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.5.1/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.5.1","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.5.1/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kubernetes-sigs/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   Troubleshooting Helm Install Note that authentication is not required for pulling charts from public GHCR (GitHub Container Registry) repositories. Helm install download failures occur due to expired local credentials. To resolve this issue, clear your local credentials cache by running helm registry logout ghcr.io in your terminal, then retry the installation.  ","version":"0.5.1","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.5.1/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.5.1","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.5.1/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and reapply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.5.1","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.5.1/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.5.1","tagName":"h2"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.6.0/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.6.0"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.5.1/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.5.1"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/0.6.0/docs/concepts/access-control","content":"","keywords":"","version":"0.6.0"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/0.6.0/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"0.6.0","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/0.6.0/docs/concepts/access-control#aggregation-access","content":" In the aggregation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"0.6.0","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/0.6.0/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"0.6.0","tagName":"h3"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.5.1/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.5.1"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.1/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.5.1","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.1/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.5.1","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.1/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.5.1","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.1/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inspect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.5.1","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.1/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates the creation of a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.5.1","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.5.1/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.5.1","tagName":"h3"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.6.0/docs/concepts/instances","content":"","keywords":"","version":"0.6.0"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.6.0/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.6.0","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.6.0/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.6.0","tagName":"h2"},{"title":"Reactive Reconciliation​","type":1,"pageTitle":"Instances","url":"/0.6.0/docs/concepts/instances#reactive-reconciliation","content":" kro automatically watches all resources managed by an instance and triggers reconciliation when any of them change. This means:  Child Resource Changes: When a managed resource (like a Deployment or Service) is modified, kro detects the change and reconciles the instance to ensure it matches the desired state defined in your ResourceGraphDefinition. Drift Detection: If a resource is manually modified or deleted, kro will detect the drift and automatically restore it to the desired state. Dependency Updates: Changes to resources propagate through the dependency graph, ensuring all dependent resources are updated accordingly.  This reactive behavior ensures your instances maintain consistency without requiring manual intervention or periodic full reconciliations.  ","version":"0.6.0","tagName":"h3"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.6.0/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: instance is properly managed with finalizers and labels observedGeneration: 1 reason: Managed status: &quot;True&quot; type: InstanceManaged - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: runtime graph created and all resources resolved observedGeneration: 1 reason: Resolved status: &quot;True&quot; type: GraphResolved - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: all resources are created and ready observedGeneration: 1 reason: AllResourcesReady status: &quot;True&quot; type: ResourcesReady - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready   ","version":"0.6.0","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.6.0/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status ACTIVE: Indicates that the instance is successfully running and active.IN_PROGRESS: Indicates that the instance is currently being processed or reconciled.FAILED: Indicates that the instance has failed to be properly reconciled.DELETING: Indicates that the instance is in the process of being deleted.ERROR: Indicates that an error occurred during instance processing. Conditions: Detailed status information structured hierarchically kro provides a top-level Ready condition that reflects the overall instance health. This condition is supported by three sub-conditions that track different phases of the reconciliation process: InstanceManaged: Instance finalizers and labels are properly set Ensures the instance is under kro's managementTracks whether cleanup handlers (finalizers) are configuredConfirms instance is labeled with ownership and version information GraphResolved: Runtime graph has been created and resources resolved Validates that the resource graph has been successfully parsedConfirms all resource templates have been resolvedEnsures dependencies between resources are properly understood ResourcesReady: All resources in the graph are created and ready Tracks the creation and readiness of all managed resourcesMonitors the health of resources in topological orderReports when all resources have reached their ready state Ready: Instance is fully operational (top-level condition) Aggregates the state of all sub-conditionsOnly becomes True when all sub-conditions are TrueThe primary condition to monitor and wait on for instance healthUse this condition in automation, CI/CD, and health checks tip Always use the Ready condition to determine instance health. The sub-conditions (InstanceManaged, GraphResolved, ResourcesReady) are provided for debugging purposes and may change in future versions. kro reserves the right to add, remove, or modify sub-conditions without breaking compatibility as long as the Ready condition behavior remains stable. Each condition includes: observedGeneration: Tracks which generation of the instance this condition reflectslastTransitionTime: When the condition last changed statereason: A programmatic identifier for the condition statemessage: A human-readable description of the current state Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.6.0","tagName":"h3"},{"title":"Debugging Instance Issues​","type":1,"pageTitle":"Instances","url":"/0.6.0/docs/concepts/instances#debugging-instance-issues","content":" When an instance is not in the expected state, the condition hierarchy helps you quickly identify where the problem occurred:  Check the Ready condition first kubectl get &lt;your-kind&gt; &lt;instance-name&gt; -o jsonpath='{.status.conditions[?(@.type==&quot;Ready&quot;)]}' If Ready is False, check the sub-conditions to identify which phase failed: If InstanceManaged is False: Check if there are issues with finalizers or instance labelsIf GraphResolved is False: The resource graph could not be created - check the ResourceGraphDefinition for syntax errors or invalid CEL expressionsIf ResourcesReady is False: One or more managed resources failed to become ready - check the error message for which resource failed Use kubectl describe to see all conditions and recent events: kubectl describe &lt;your-kind&gt; &lt;instance-name&gt; Check the observedGeneration field in conditions: If observedGeneration is less than metadata.generation, the controller hasn't processed the latest changes yetIf they match, the conditions reflect the current state of your instance  ","version":"0.6.0","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.6.0/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Focus on the Ready condition and its sub-conditions to understand the reconciliation state. Monitor observedGeneration: When making changes to an instance, verify thatobservedGeneration in the conditions matches metadata.generation to ensure kro has processed your changes. Leverage Reactive Reconciliation: kro automatically detects and corrects drift in managed resources. If you need to make manual changes to resources, update the instance specification instead to ensure changes persist and align with your desired state. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.6.0","tagName":"h2"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/0.5.1/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.5.1"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/0.5.1/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.5.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/0.5.1/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.5.1","tagName":"h2"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.5.1/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.5.1"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.1/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Definition) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.5.1","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.1/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteriaExternal References  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.5.1","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.1/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions} validation: # Validating admission policies added to the new API type's CRD - expression: &quot;${ self.image == 'nginx' || !self.ingress.enabled }&quot; message: &quot;Only nginx based applications can have ingress enabled&quot; additionalPrinterColumns: # Printer columns shown for the created custom resource - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.5.1","tagName":"h2"},{"title":"Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.1/docs/concepts/resource-group-definitions#processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acyclic Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource states  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.5.1","tagName":"h2"},{"title":"Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.1/docs/concepts/resource-group-definitions#instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can create instances of it. Here's an example of how an instance for theWebApplication might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   ","version":"0.5.1","tagName":"h2"},{"title":"More about Resources​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.1/docs/concepts/resource-group-definitions#more-about-resources","content":" Users can specify more controls in resources in .spec.resources[]  spec: resources: - id: my-resource template || externalRef: {} # users can either template resources or reference objects outside the graph readyWhen: # users can specify CEL expressions to determine when a resource is ready - ${deployment.status.conditions.exists(x, x.type == 'Available' &amp;&amp; x.status == &quot;True&quot;)} includeWhen: # users can specify CEL expressions to determine when a resource should be included in the graph - ${schema.spec.value.enabled}   ","version":"0.5.1","tagName":"h2"},{"title":"Using externalRef to reference Objects outside the ResourceGraphDefinition.​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.1/docs/concepts/resource-group-definitions#using-externalref-to-reference-objects-outside-the-resourcegraphdefinition","content":" Users can specify if the object is something that is created out-of-band and needs to be referenced in the RGD. An external reference could be specified like this:  resources: id: projectConfig externalRef: apiVersion: corp.platform.com/v1 kind: Project metadata: name: default-project namespace: # optional, if empty uses instance namespace   As part of processing the Resource Graph, the instance reconciler waits for the externalRef object to be present and reads the object from the cluster as a node in the graph. Subsequent resources can use data from this node.  ","version":"0.5.1","tagName":"h3"},{"title":"Using Conditional CEL Expressions (?)​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.1/docs/concepts/resource-group-definitions#using-conditional-cel-expressions-","content":" KRO can make use of CEL Expressions (see this proposal for details or look at the CEL Implementation Reference) to define optional runtime conditions for resources based on the conditional operator ?.  This allows you to optionally define values that have no predefined schema or are not hard dependencies in the Graph.  Using ? for referencing schema-less objects like ConfigMap or Secret​  You can use the optional operator to reference objects that do not have a predefined schema in the ResourceGraphDefinition. This is useful for referencing objects that may or may not exist at runtime.  ⚠️ ? removes the ability of KRO to introspect the schema of the referenced object. Thus, it cannot wait for fields after the ? to be present. It is recommended to use conditional expressions only for objects that are not critical to the ResourceGraphDefinition's operation or when the schema cannot be known at design time.  A config map can be referenced like this:  config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: VALUE: &quot;foobar&quot;   external reference in ResourceGraphDefinition - id: external externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default   With this reference, you can access the data in your schema:  CEL Expression ${external.data.?VALUE}   ⚠️ KRO will only wait for the external reference to be present in the cluster, but it will not validate the schema of the referenced config. If the config map does not have the VALUE field, the expression will evaluate to null and might result in unexpected behavior in your application if not handled properly.  For a more detailed example, see the Optional Values &amp; External References documentation.  ","version":"0.5.1","tagName":"h3"},{"title":"Status Reporting​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.5.1/docs/concepts/resource-group-definitions#status-reporting","content":" The status section of a ResourceGraphDefinition provides information about the state of the graph and it's generated CustomResourceDefinition and controller.  status includes a stable Ready condition (as well as a set of technical status.conditions that provide more detailed information about the state of the graph and its resources).  info When the Ready condition status is True, it indicates that the ResourceGraphDefinition is valid and you can use it to create instances.  warning Try to only rely on the Ready condition, as other condition types may change frequently and are more technical in nature, can change their API over time and are generally more indicative of KRO's internal state.  Additionally, the ResourceGraphDefinition contains a topologicalOrder field that provides a list of resources in the order they should be processed. This is useful for understanding the dependencies between resources and their apply order.  Generally a status in ResourceGraphDefinition may look like  status: conditions: - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: resource graph and schema are valid observedGeneration: 1 reason: Valid status: &quot;True&quot; type: ResourceGraphAccepted - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: kind DeploymentService has been accepted and ready observedGeneration: 1 reason: Ready status: &quot;True&quot; type: KindReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: controller is running observedGeneration: 1 reason: Running status: &quot;True&quot; type: ControllerReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready state: Active topologicalOrder: - configmap - deployment  ","version":"0.5.1","tagName":"h2"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.5.1/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployment on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.5.1"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.5.1/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.5.1"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.6.0/docs/getting-started/Installation","content":"","keywords":"","version":"0.6.0"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.6.0/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.6.0","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.6.0/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.6.0","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.6.0/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kubernetes-sigs/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   ","version":"0.6.0","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.6.0/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.6.0","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.6.0/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and reapply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.6.0","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.6.0/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.6.0","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.6.0/examples/","content":"","keywords":"","version":"0.6.0"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.6.0/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.6.0","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.6.0/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.6.0","tagName":"h2"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.6.0/docs/overview","content":"","keywords":"","version":"0.6.0"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.6.0/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Figure 1: End user interface - Custom API  ","version":"0.6.0","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.6.0/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for the Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Figure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.6.0","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.6.0/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Figure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.6.0","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.6.0/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.6.0","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.6.0/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.6.0","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.6.0/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.6.0","tagName":"h3"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/0.6.0/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.6.0"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.6.0/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.6.0"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.6.0/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. How do I use KRO resources with ArgoCD? To use KRO resources with ArgoCD, you need to add a specific tracking annotation to all templated resources in your ResourceGraphDefinition. The following code needs to be added to each templated resource: metadata: ownerReferences: - apiVersion: kro.run/v1alpha1 kind: ${schema.kind} name: ${schema.metadata.name} uid: ${schema.metadata.uid} blockOwnerDeletion: true controller: false annotations: argocd.argoproj.io/tracking-id: ${schema.metadata.?annotations[&quot;argocd.argoproj.io/tracking-id&quot;]} This annotation allows ArgoCD to properly track and manage the resources created by KRO instances. Note that the example shown above depicts ArgoCD's default resource tracking via annotations. You may choose to use annotation+label or just label and if so the example has to be modified to support your configuration. For more detailed information about ArgoCD resource tracking, please see theArgoCD documentation. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.6.0"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.6.0/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.6.0"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.0/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.6.0","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.0/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.6.0","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.0/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.6.0","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.0/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inspect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.6.0","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.0/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates the creation of a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.6.0","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.0/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.6.0","tagName":"h3"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.6.0/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.6.0"},{"title":"Optional Values & External References","type":0,"sectionRef":"#","url":"/0.6.0/examples/basic/optionals","content":"Optional Values &amp; External References config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: ECHO_VALUE: &quot;Hello, World!&quot; deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: input externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $MY_VALUE &amp;&amp; sleep 3600&quot;] env: - name: MY_VALUE value: ${input.data.?ECHO_VALUE} ","keywords":"","version":"0.6.0"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.6.0/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.6.0"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.6.0/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.6.0"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.6.0/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.6.0"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/0.5.1/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.5.1"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/0.5.1/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.5.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/0.5.1/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.5.1","tagName":"h2"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.6.1/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.6.1"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/0.6.1/docs/concepts/access-control","content":"","keywords":"","version":"0.6.1"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/0.6.1/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"0.6.1","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/0.6.1/docs/concepts/access-control#aggregation-access","content":" In the aggregation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"0.6.1","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/0.6.1/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"0.6.1","tagName":"h3"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.6.0/docs/concepts/simple-schema","content":"","keywords":"","version":"0.6.0"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.6.0","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesfloat: Decimal numbers  For example:  name: string age: integer enabled: boolean price: float   ","version":"0.6.0","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.6.0","tagName":"h3"},{"title":"Unstructured Objects​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#unstructured-objects","content":" Unstructured objects are declared using object as a type.  warning This disables the field-validation normally offered by kro, and forwards the values to your RGD as-is. This is generally discouraged and should therefore be used with caution. In most cases, using a structured object is a better approach.  kind: ResourceGraphDefintion metadata: {} spec: schema: spec: additionalHelmChartValues: object   This allows you to pass data to your CRDs directly in cases where the schema is not known in advance. This type supports any valid object, and can mix and match different primitives as well as structured types.  apiVersion: kro.run/v1alpha1 kind: CRDWithUnstructuredObjects metadata: name: test-instance spec: additionalHelmChartValues: boolean-value: true numeric-value: 42 structural-type: with-additional: nested: fields string-value: my-string mapping-value: - item1 - item2 - item3   ","version":"0.6.0","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.6.0","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]float&quot;   ","version":"0.6.0","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#custom-types","content":" Custom types are specified in the separate types section. They provide a map of names to type specifications that follow the simple schema.  Example:  schema: types: Person: name: string age: integer spec: people: '[]Person | required=true`   ","version":"0.6.0","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.6.0","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbersimmutable=true: Field cannot be changed after creationpattern=&quot;regex&quot;: Regular expression pattern for string validationminLength=number: Minimum length for stringsmaxLength=number: Maximum length for stringsuniqueItems=true: Ensures array elements are uniqueminItems=number: Minimum number of items in arraysmaxItems=number: Maximum number of items in arrays  Multiple markers can be combined using the | separator.  ","version":"0.6.0","tagName":"h3"},{"title":"String Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#string-validation-markers","content":" String fields support additional validation markers:  pattern=&quot;regex&quot;: Validates the string against a regular expression patternminLength=number: Sets the minimum number of charactersmaxLength=number: Sets the maximum number of characters  Examples:  # Email validation email: string | pattern=&quot;^[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w+$&quot; required=true # Username with length constraints and pattern username: string | minLength=3 maxLength=15 pattern=&quot;^[a-zA-Z0-9_]+$&quot; # Country code format countryCode: string | pattern=&quot;^[A-Z]{2}$&quot; minLength=2 maxLength=2 # Password with minimum length password: string | minLength=8 description=&quot;Password must be at least 8 characters&quot;   ","version":"0.6.0","tagName":"h3"},{"title":"Array Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#array-validation-markers","content":" Array fields support validation markers to ensure data quality:  uniqueItems=true: Ensures all elements in the array are uniqueuniqueItems=false: Allows duplicate elements (default behavior)minItems=number: Sets the minimum number of elements required in the arraymaxItems=number: Sets the maximum number of elements allowed in the array  Examples:  # Unique tags with size constraints tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot; # Unique port numbers with minimum requirement ports: &quot;[]integer&quot; | uniqueItems=true minItems=1 description=&quot;At least one unique port&quot; # Allow duplicate comments with size limits comments: &quot;[]string&quot; | uniqueItems=false maxItems=50 description=&quot;Up to 50 comments&quot; # Complex validation with multiple markers roles: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=5 required=true description=&quot;1-5 unique user roles&quot; # Optional array with size constraints priorities: &quot;[]integer&quot; | minItems=0 maxItems=3 description=&quot;Up to 3 priority levels&quot;   For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; id: string | required=true immutable=true description=&quot;Unique identifier&quot; replicas: integer | default=3 minimum=1 maximum=10 price: float | minimum=0.01 maximum=999.99 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot; email: string | pattern=&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$&quot; description=&quot;Valid email address&quot; username: string | minLength=3 maxLength=20 pattern=&quot;^[a-zA-Z0-9_]+$&quot; tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot;   Floating Point Precision When using float or double types in CEL expressions (particularly in readyWhen or includeWhen conditions), be aware of floating point precision issues that could cause unexpected behavior. Avoid comparing floating point values for equality in conditional logic. Prefer using string, integer, or boolean types whenever possible to avoid precision-related oscillations in resource state.  ","version":"0.6.0","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources exist at ResourceGraphDefinition creation timeUpdates values when the underlying resources changeValidates type compatibility using CEL's native type system  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} # integer endpoint: ${service.status.loadBalancer.ingress[0].hostname} # string metadata: ${deployment.metadata} # object   ","version":"0.6.0","tagName":"h2"},{"title":"Single vs Multi-Expression Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#single-vs-multi-expression-fields","content":" Status fields can contain either a single CEL expression or multiple expressions concatenated together:  Single Expression Fields can be any type:  status: replicas: ${deployment.status.replicas} # integer metadata: ${deployment.metadata} # object name: ${deployment.metadata.name} # string ready: ${deployment.status.conditions.exists(c, c.type == 'Available')} # boolean   Multi-Expression Fields (string templating) must contain only string expressions:  status: # ✓ Valid - all expressions return strings endpoint: &quot;https://${service.metadata.name}.${service.metadata.namespace}.svc.cluster.local&quot; # ✓ Valid - explicit string conversion summary: &quot;Replicas: ${string(deployment.status.replicas)}, Ready: ${string(deployment.status.ready)}&quot; # ✗ Invalid - concatenating non-string types invalid: &quot;${deployment.status.replicas}-${deployment.metadata}&quot; # Will fail validation   Multi-expression fields are useful for string templating scenarios like constructing URLs, connection strings, or IAM policies:  status: iamPolicy: | { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Resource&quot;: &quot;arn:aws:s3:::${bucket.metadata.name}/*&quot;, &quot;Principal&quot;: &quot;${serviceAccount.metadata.name}&quot; }   tip Use explicit string() conversions when concatenating non-string values to ensure type compatibility. Alternatively, you can use CEL's built-in format() function for string formatting: status: endpoint: ${&quot;https://%s.%s.svc.cluster.local&quot;.format([service.metadata.name, service.metadata.namespace])} The ${...}${...} templating syntax is a kro convenience feature that makes common string concatenation patterns more readable.  ","version":"0.6.0","tagName":"h3"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.6.0","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;InstanceManaged&quot;, &quot;GraphResolved&quot;, &quot;ResourcesReady&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string observedGeneration: integer reason: string message: string   kro provides a hierarchical condition structure:  Ready: Top-level condition indicating the instance is fully operational InstanceManaged: Instance finalizers and labels are properly setGraphResolved: Runtime graph has been created and resources resolvedResourcesReady: All resources in the graph are created and ready  The Ready condition aggregates the state of all sub-conditions and only becomes True when all sub-conditions are True. Each condition includes an observedGeneration field that tracks which generation of the instance the condition reflects.  ","version":"0.6.0","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # ACTIVE, IN_PROGRESS, FAILED, DELETING, ERROR   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values.  ","version":"0.6.0","tagName":"h3"},{"title":"Additional Printer Columns​","type":1,"pageTitle":"Simple Schema","url":"/0.6.0/docs/concepts/simple-schema#additional-printer-columns","content":" You can define additionalPrinterColumns for the created CRD through the ResourceGraphDefinition by setting them on spec.schema.additionalPrinterColumns.  schema: spec: image: string | default=&quot;nginx&quot; status: availableReplicas: ${deployment.status.availableReplicas} additionalPrinterColumns: - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string  ","version":"0.6.0","tagName":"h2"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.6.0/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.6.0"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.6.1/docs/concepts/instances","content":"","keywords":"","version":"0.6.1"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.6.1/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.6.1","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.6.1/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.6.1","tagName":"h2"},{"title":"Reactive Reconciliation​","type":1,"pageTitle":"Instances","url":"/0.6.1/docs/concepts/instances#reactive-reconciliation","content":" kro automatically watches all resources managed by an instance and triggers reconciliation when any of them change. This means:  Child Resource Changes: When a managed resource (like a Deployment or Service) is modified, kro detects the change and reconciles the instance to ensure it matches the desired state defined in your ResourceGraphDefinition. Drift Detection: If a resource is manually modified or deleted, kro will detect the drift and automatically restore it to the desired state. Dependency Updates: Changes to resources propagate through the dependency graph, ensuring all dependent resources are updated accordingly.  This reactive behavior ensures your instances maintain consistency without requiring manual intervention or periodic full reconciliations.  ","version":"0.6.1","tagName":"h3"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.6.1/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: instance is properly managed with finalizers and labels observedGeneration: 1 reason: Managed status: &quot;True&quot; type: InstanceManaged - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: runtime graph created and all resources resolved observedGeneration: 1 reason: Resolved status: &quot;True&quot; type: GraphResolved - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: all resources are created and ready observedGeneration: 1 reason: AllResourcesReady status: &quot;True&quot; type: ResourcesReady - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready   ","version":"0.6.1","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.6.1/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status ACTIVE: Indicates that the instance is successfully running and active.IN_PROGRESS: Indicates that the instance is currently being processed or reconciled.FAILED: Indicates that the instance has failed to be properly reconciled.DELETING: Indicates that the instance is in the process of being deleted.ERROR: Indicates that an error occurred during instance processing. Conditions: Detailed status information structured hierarchically kro provides a top-level Ready condition that reflects the overall instance health. This condition is supported by three sub-conditions that track different phases of the reconciliation process: InstanceManaged: Instance finalizers and labels are properly set Ensures the instance is under kro's managementTracks whether cleanup handlers (finalizers) are configuredConfirms instance is labeled with ownership and version information GraphResolved: Runtime graph has been created and resources resolved Validates that the resource graph has been successfully parsedConfirms all resource templates have been resolvedEnsures dependencies between resources are properly understood ResourcesReady: All resources in the graph are created and ready Tracks the creation and readiness of all managed resourcesMonitors the health of resources in topological orderReports when all resources have reached their ready state Ready: Instance is fully operational (top-level condition) Aggregates the state of all sub-conditionsOnly becomes True when all sub-conditions are TrueThe primary condition to monitor and wait on for instance healthUse this condition in automation, CI/CD, and health checks tip Always use the Ready condition to determine instance health. The sub-conditions (InstanceManaged, GraphResolved, ResourcesReady) are provided for debugging purposes and may change in future versions. kro reserves the right to add, remove, or modify sub-conditions without breaking compatibility as long as the Ready condition behavior remains stable. Each condition includes: observedGeneration: Tracks which generation of the instance this condition reflectslastTransitionTime: When the condition last changed statereason: A programmatic identifier for the condition statemessage: A human-readable description of the current state Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.6.1","tagName":"h3"},{"title":"Debugging Instance Issues​","type":1,"pageTitle":"Instances","url":"/0.6.1/docs/concepts/instances#debugging-instance-issues","content":" When an instance is not in the expected state, the condition hierarchy helps you quickly identify where the problem occurred:  Check the Ready condition first kubectl get &lt;your-kind&gt; &lt;instance-name&gt; -o jsonpath='{.status.conditions[?(@.type==&quot;Ready&quot;)]}' If Ready is False, check the sub-conditions to identify which phase failed: If InstanceManaged is False: Check if there are issues with finalizers or instance labelsIf GraphResolved is False: The resource graph could not be created - check the ResourceGraphDefinition for syntax errors or invalid CEL expressionsIf ResourcesReady is False: One or more managed resources failed to become ready - check the error message for which resource failed Use kubectl describe to see all conditions and recent events: kubectl describe &lt;your-kind&gt; &lt;instance-name&gt; Check the observedGeneration field in conditions: If observedGeneration is less than metadata.generation, the controller hasn't processed the latest changes yetIf they match, the conditions reflect the current state of your instance  ","version":"0.6.1","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.6.1/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Focus on the Ready condition and its sub-conditions to understand the reconciliation state. Monitor observedGeneration: When making changes to an instance, verify thatobservedGeneration in the conditions matches metadata.generation to ensure kro has processed your changes. Leverage Reactive Reconciliation: kro automatically detects and corrects drift in managed resources. If you need to make manual changes to resources, update the instance specification instead to ensure changes persist and align with your desired state. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.6.1","tagName":"h2"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/0.6.0/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.6.0"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/0.6.0/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.6.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/0.6.0/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.6.0","tagName":"h2"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.6.0/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.6.0"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.0/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Definition) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.6.0","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.0/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteriaExternal References  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.6.0","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.0/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions} validation: # Validating admission policies added to the new API type's CRD - expression: &quot;${ self.image == 'nginx' || !self.ingress.enabled }&quot; message: &quot;Only nginx based applications can have ingress enabled&quot; additionalPrinterColumns: # Printer columns shown for the created custom resource - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.6.0","tagName":"h2"},{"title":"Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.0/docs/concepts/resource-group-definitions#processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acyclic Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions using CEL's native type system Validates field references exist in the actual resource schemasEnsures expressions return types compatible with their target fieldsValidates that CEL functions called in expressions exist and are used correctlyChecks expression correctness and type compatibility statically without executing expressions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and their managed resources: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource statesAutomatically detects and reconciles drift in managed resourcesTriggers reconciliation when any managed resource changes  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.6.0","tagName":"h2"},{"title":"Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.0/docs/concepts/resource-group-definitions#instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can create instances of it. Here's an example of how an instance for theWebApplication might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   ","version":"0.6.0","tagName":"h2"},{"title":"More about Resources​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.0/docs/concepts/resource-group-definitions#more-about-resources","content":" Users can specify more controls in resources in .spec.resources[]  spec: resources: - id: my-resource template || externalRef: {} # users can either template resources or reference objects outside the graph readyWhen: # users can specify CEL expressions to determine when a resource is ready - ${deployment.status.conditions.exists(x, x.type == 'Available' &amp;&amp; x.status == &quot;True&quot;)} includeWhen: # users can specify CEL expressions to determine when a resource should be included in the graph - ${schema.spec.value.enabled}   ","version":"0.6.0","tagName":"h2"},{"title":"Using externalRef to reference Objects outside the ResourceGraphDefinition.​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.0/docs/concepts/resource-group-definitions#using-externalref-to-reference-objects-outside-the-resourcegraphdefinition","content":" Users can specify if the object is something that is created out-of-band and needs to be referenced in the RGD. An external reference could be specified like this:  resources: id: projectConfig externalRef: apiVersion: corp.platform.com/v1 kind: Project metadata: name: default-project namespace: # optional, if empty uses instance namespace   As part of processing the Resource Graph, the instance reconciler waits for the externalRef object to be present and reads the object from the cluster as a node in the graph. Subsequent resources can use data from this node.  ","version":"0.6.0","tagName":"h3"},{"title":"Using Conditional CEL Expressions (?)​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.0/docs/concepts/resource-group-definitions#using-conditional-cel-expressions-","content":" KRO can make use of CEL Expressions (see this proposal for details or look at the CEL Implementation Reference) to define optional runtime conditions for resources based on the conditional operator ?.  This allows you to optionally define values that have no predefined schema or are not hard dependencies in the Graph.  Using ? for referencing schema-less objects like ConfigMap or Secret​  You can use the optional operator to reference objects that do not have a predefined schema in the ResourceGraphDefinition. This is useful for referencing objects that may or may not exist at runtime.  ⚠️ ? removes the ability of KRO to introspect the schema of the referenced object. Thus, it cannot wait for fields after the ? to be present. It is recommended to use conditional expressions only for objects that are not critical to the ResourceGraphDefinition's operation or when the schema cannot be known at design time.  A config map can be referenced like this:  config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: VALUE: &quot;foobar&quot;   external reference in ResourceGraphDefinition - id: external externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default   With this reference, you can access the data in your schema:  CEL Expression ${external.data.?VALUE}   ⚠️ KRO will only wait for the external reference to be present in the cluster, but it will not validate the schema of the referenced config. If the config map does not have the VALUE field, the expression will evaluate to null and might result in unexpected behavior in your application if not handled properly.  For a more detailed example, see the Optional Values &amp; External References documentation.  ","version":"0.6.0","tagName":"h3"},{"title":"Status Reporting​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.0/docs/concepts/resource-group-definitions#status-reporting","content":" The status section of a ResourceGraphDefinition provides information about the state of the graph and it's generated CustomResourceDefinition and controller.  status includes a stable Ready condition (as well as a set of technical status.conditions that provide more detailed information about the state of the graph and its resources).  info When the Ready condition status is True, it indicates that the ResourceGraphDefinition is valid and you can use it to create instances.  warning Try to only rely on the Ready condition, as other condition types may change frequently and are more technical in nature, can change their API over time and are generally more indicative of KRO's internal state.  Additionally, the ResourceGraphDefinition contains a topologicalOrder field that provides a list of resources in the order they should be processed. This is useful for understanding the dependencies between resources and their apply order.  Generally a status in ResourceGraphDefinition may look like  status: conditions: - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: resource graph and schema are valid observedGeneration: 1 reason: Valid status: &quot;True&quot; type: ResourceGraphAccepted - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: kind DeploymentService has been accepted and ready observedGeneration: 1 reason: Ready status: &quot;True&quot; type: KindReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: controller is running observedGeneration: 1 reason: Running status: &quot;True&quot; type: ControllerReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready state: Active topologicalOrder: - configmap - deployment  ","version":"0.6.0","tagName":"h2"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.6.0/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.6.0"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.6.1/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. How do I use KRO resources with ArgoCD? To use KRO resources with ArgoCD, you need to add a specific tracking annotation to all templated resources in your ResourceGraphDefinition. The following code needs to be added to each templated resource: metadata: ownerReferences: - apiVersion: kro.run/v1alpha1 kind: ${schema.kind} name: ${schema.metadata.name} uid: ${schema.metadata.uid} blockOwnerDeletion: true controller: false annotations: argocd.argoproj.io/tracking-id: ${schema.metadata.?annotations[&quot;argocd.argoproj.io/tracking-id&quot;]} This annotation allows ArgoCD to properly track and manage the resources created by KRO instances. Note that the example shown above depicts ArgoCD's default resource tracking via annotations. You may choose to use annotation+label or just label and if so the example has to be modified to support your configuration. For more detailed information about ArgoCD resource tracking, please see theArgoCD documentation. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.6.1"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.6.1/docs/getting-started/Installation","content":"","keywords":"","version":"0.6.1"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.6.1/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.6.1","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.6.1/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.6.1","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.6.1/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kubernetes-sigs/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   ","version":"0.6.1","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.6.1/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.6.1","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.6.1/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and reapply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.6.1","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.6.1/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.6.1","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.6.1/examples/","content":"","keywords":"","version":"0.6.1"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.6.1/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.6.1","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.6.1/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.6.1","tagName":"h2"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.6.1/docs/overview","content":"","keywords":"","version":"0.6.1"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.6.1/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Figure 1: End user interface - Custom API  ","version":"0.6.1","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.6.1/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for the Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Figure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.6.1","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.6.1/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Figure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.6.1","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.6.1/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.6.1","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.6.1/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.6.1","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.6.1/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.6.1","tagName":"h3"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/0.5.1/examples/gcp/eventarc","content":"","keywords":"","version":"0.5.1"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.5.1/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.5.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.5.1/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.5.1","tagName":"h2"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.6.0/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployment on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.6.0"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.6.1/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.6.1"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/0.6.0/examples/gcp/eventarc","content":"","keywords":"","version":"0.6.0"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.6.0/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.6.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.6.0/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.6.0","tagName":"h2"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.6.0/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.6.0"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/0.6.1/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.6.1"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.6.1/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.6.1"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.6.1/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.6.1"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/0.6.0/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.6.0"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/0.6.0/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.6.0","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/0.6.0/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.6.0","tagName":"h2"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.6.1/docs/concepts/simple-schema","content":"","keywords":"","version":"0.6.1"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.6.1","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesfloat: Decimal numbers  For example:  name: string age: integer enabled: boolean price: float   ","version":"0.6.1","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.6.1","tagName":"h3"},{"title":"Unstructured Objects​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#unstructured-objects","content":" Unstructured objects are declared using object as a type.  warning This disables the field-validation normally offered by kro, and forwards the values to your RGD as-is. This is generally discouraged and should therefore be used with caution. In most cases, using a structured object is a better approach.  kind: ResourceGraphDefintion metadata: {} spec: schema: spec: additionalHelmChartValues: object   This allows you to pass data to your CRDs directly in cases where the schema is not known in advance. This type supports any valid object, and can mix and match different primitives as well as structured types.  apiVersion: kro.run/v1alpha1 kind: CRDWithUnstructuredObjects metadata: name: test-instance spec: additionalHelmChartValues: boolean-value: true numeric-value: 42 structural-type: with-additional: nested: fields string-value: my-string mapping-value: - item1 - item2 - item3   ","version":"0.6.1","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.6.1","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]float&quot;   ","version":"0.6.1","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#custom-types","content":" Custom types are specified in the separate types section. They provide a map of names to type specifications that follow the simple schema.  Example:  schema: types: Person: name: string age: integer spec: people: '[]Person | required=true`   ","version":"0.6.1","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.6.1","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbersimmutable=true: Field cannot be changed after creationpattern=&quot;regex&quot;: Regular expression pattern for string validationminLength=number: Minimum length for stringsmaxLength=number: Maximum length for stringsuniqueItems=true: Ensures array elements are uniqueminItems=number: Minimum number of items in arraysmaxItems=number: Maximum number of items in arrays  Multiple markers can be combined using the | separator.  ","version":"0.6.1","tagName":"h3"},{"title":"String Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#string-validation-markers","content":" String fields support additional validation markers:  pattern=&quot;regex&quot;: Validates the string against a regular expression patternminLength=number: Sets the minimum number of charactersmaxLength=number: Sets the maximum number of characters  Examples:  # Email validation email: string | pattern=&quot;^[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w+$&quot; required=true # Username with length constraints and pattern username: string | minLength=3 maxLength=15 pattern=&quot;^[a-zA-Z0-9_]+$&quot; # Country code format countryCode: string | pattern=&quot;^[A-Z]{2}$&quot; minLength=2 maxLength=2 # Password with minimum length password: string | minLength=8 description=&quot;Password must be at least 8 characters&quot;   ","version":"0.6.1","tagName":"h3"},{"title":"Array Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#array-validation-markers","content":" Array fields support validation markers to ensure data quality:  uniqueItems=true: Ensures all elements in the array are uniqueuniqueItems=false: Allows duplicate elements (default behavior)minItems=number: Sets the minimum number of elements required in the arraymaxItems=number: Sets the maximum number of elements allowed in the array  Examples:  # Unique tags with size constraints tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot; # Unique port numbers with minimum requirement ports: &quot;[]integer&quot; | uniqueItems=true minItems=1 description=&quot;At least one unique port&quot; # Allow duplicate comments with size limits comments: &quot;[]string&quot; | uniqueItems=false maxItems=50 description=&quot;Up to 50 comments&quot; # Complex validation with multiple markers roles: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=5 required=true description=&quot;1-5 unique user roles&quot; # Optional array with size constraints priorities: &quot;[]integer&quot; | minItems=0 maxItems=3 description=&quot;Up to 3 priority levels&quot;   For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; id: string | required=true immutable=true description=&quot;Unique identifier&quot; replicas: integer | default=3 minimum=1 maximum=10 price: float | minimum=0.01 maximum=999.99 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot; email: string | pattern=&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$&quot; description=&quot;Valid email address&quot; username: string | minLength=3 maxLength=20 pattern=&quot;^[a-zA-Z0-9_]+$&quot; tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot;   Floating Point Precision When using float or double types in CEL expressions (particularly in readyWhen or includeWhen conditions), be aware of floating point precision issues that could cause unexpected behavior. Avoid comparing floating point values for equality in conditional logic. Prefer using string, integer, or boolean types whenever possible to avoid precision-related oscillations in resource state.  ","version":"0.6.1","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources exist at ResourceGraphDefinition creation timeUpdates values when the underlying resources changeValidates type compatibility using CEL's native type system  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} # integer endpoint: ${service.status.loadBalancer.ingress[0].hostname} # string metadata: ${deployment.metadata} # object   ","version":"0.6.1","tagName":"h2"},{"title":"Single vs Multi-Expression Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#single-vs-multi-expression-fields","content":" Status fields can contain either a single CEL expression or multiple expressions concatenated together:  Single Expression Fields can be any type:  status: replicas: ${deployment.status.replicas} # integer metadata: ${deployment.metadata} # object name: ${deployment.metadata.name} # string ready: ${deployment.status.conditions.exists(c, c.type == 'Available')} # boolean   Multi-Expression Fields (string templating) must contain only string expressions:  status: # ✓ Valid - all expressions return strings endpoint: &quot;https://${service.metadata.name}.${service.metadata.namespace}.svc.cluster.local&quot; # ✓ Valid - explicit string conversion summary: &quot;Replicas: ${string(deployment.status.replicas)}, Ready: ${string(deployment.status.ready)}&quot; # ✗ Invalid - concatenating non-string types invalid: &quot;${deployment.status.replicas}-${deployment.metadata}&quot; # Will fail validation   Multi-expression fields are useful for string templating scenarios like constructing URLs, connection strings, or IAM policies:  status: iamPolicy: | { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Resource&quot;: &quot;arn:aws:s3:::${bucket.metadata.name}/*&quot;, &quot;Principal&quot;: &quot;${serviceAccount.metadata.name}&quot; }   tip Use explicit string() conversions when concatenating non-string values to ensure type compatibility. Alternatively, you can use CEL's built-in format() function for string formatting: status: endpoint: ${&quot;https://%s.%s.svc.cluster.local&quot;.format([service.metadata.name, service.metadata.namespace])} The ${...}${...} templating syntax is a kro convenience feature that makes common string concatenation patterns more readable.  ","version":"0.6.1","tagName":"h3"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.6.1","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;InstanceManaged&quot;, &quot;GraphResolved&quot;, &quot;ResourcesReady&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string observedGeneration: integer reason: string message: string   kro provides a hierarchical condition structure:  Ready: Top-level condition indicating the instance is fully operational InstanceManaged: Instance finalizers and labels are properly setGraphResolved: Runtime graph has been created and resources resolvedResourcesReady: All resources in the graph are created and ready  The Ready condition aggregates the state of all sub-conditions and only becomes True when all sub-conditions are True. Each condition includes an observedGeneration field that tracks which generation of the instance the condition reflects.  ","version":"0.6.1","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # ACTIVE, IN_PROGRESS, FAILED, DELETING, ERROR   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values.  ","version":"0.6.1","tagName":"h3"},{"title":"Additional Printer Columns​","type":1,"pageTitle":"Simple Schema","url":"/0.6.1/docs/concepts/simple-schema#additional-printer-columns","content":" You can define additionalPrinterColumns for the created CRD through the ResourceGraphDefinition by setting them on spec.schema.additionalPrinterColumns.  schema: spec: image: string | default=&quot;nginx&quot; status: availableReplicas: ${deployment.status.availableReplicas} additionalPrinterColumns: - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string  ","version":"0.6.1","tagName":"h2"},{"title":"Optional Values & External References","type":0,"sectionRef":"#","url":"/0.6.1/examples/basic/optionals","content":"Optional Values &amp; External References config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: ECHO_VALUE: &quot;Hello, World!&quot; deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: input externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $MY_VALUE &amp;&amp; sleep 3600&quot;] env: - name: MY_VALUE value: ${input.data.?ECHO_VALUE} ","keywords":"","version":"0.6.1"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.6.1/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.6.1"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.6.1/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.6.1"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/0.6.2/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.6.2"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.6.1/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.6.1"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.6.1/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.6.1"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.1/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.6.1","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.1/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.6.1","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.1/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.6.1","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.1/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inspect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.6.1","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.1/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates the creation of a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.6.1","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.1/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.6.1","tagName":"h3"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/0.6.2/docs/concepts/access-control","content":"","keywords":"","version":"0.6.2"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/0.6.2/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"0.6.2","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/0.6.2/docs/concepts/access-control#aggregation-access","content":" In the aggregation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"0.6.2","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/0.6.2/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"0.6.2","tagName":"h3"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/0.6.1/examples/gcp/eventarc","content":"","keywords":"","version":"0.6.1"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.6.1/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.6.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.6.1/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.6.1","tagName":"h2"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.6.1/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.6.1"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/0.6.2/docs/overview","content":"","keywords":"","version":"0.6.2"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/0.6.2/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Figure 1: End user interface - Custom API  ","version":"0.6.2","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/0.6.2/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for the Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Figure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.6.2","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/0.6.2/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Figure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.6.2","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/0.6.2/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.6.2","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/0.6.2/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.6.2","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/0.6.2/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.6.2","tagName":"h3"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/0.6.2/docs/getting-started/Installation","content":"","keywords":"","version":"0.6.2"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/0.6.2/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.6.2","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/0.6.2/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.6.2","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/0.6.2/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kubernetes-sigs/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   ","version":"0.6.2","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/0.6.2/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.6.2","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/0.6.2/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and reapply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.6.2","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/0.6.2/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.6.2","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/0.6.2/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. How do I use KRO resources with ArgoCD? To use KRO resources with ArgoCD, you need to add a specific tracking annotation to all templated resources in your ResourceGraphDefinition. The following code needs to be added to each templated resource: metadata: ownerReferences: - apiVersion: kro.run/v1alpha1 kind: ${schema.kind} name: ${schema.metadata.name} uid: ${schema.metadata.uid} blockOwnerDeletion: true controller: false annotations: argocd.argoproj.io/tracking-id: ${schema.metadata.?annotations[&quot;argocd.argoproj.io/tracking-id&quot;]} This annotation allows ArgoCD to properly track and manage the resources created by KRO instances. Note that the example shown above depicts ArgoCD's default resource tracking via annotations. You may choose to use annotation+label or just label and if so the example has to be modified to support your configuration. For more detailed information about ArgoCD resource tracking, please see theArgoCD documentation. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.6.2"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.6.2/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.6.2"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.2/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Definition) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.6.2","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.2/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteriaExternal References  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.6.2","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.2/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions} validation: # Validating admission policies added to the new API type's CRD - expression: &quot;${ self.image == 'nginx' || !self.ingress.enabled }&quot; message: &quot;Only nginx based applications can have ingress enabled&quot; additionalPrinterColumns: # Printer columns shown for the created custom resource - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.6.2","tagName":"h2"},{"title":"Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.2/docs/concepts/resource-group-definitions#processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acyclic Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions using CEL's native type system Validates field references exist in the actual resource schemasEnsures expressions return types compatible with their target fieldsValidates that CEL functions called in expressions exist and are used correctlyChecks expression correctness and type compatibility statically without executing expressions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and their managed resources: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource statesAutomatically detects and reconciles drift in managed resourcesTriggers reconciliation when any managed resource changes  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.6.2","tagName":"h2"},{"title":"Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.2/docs/concepts/resource-group-definitions#instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can create instances of it. Here's an example of how an instance for theWebApplication might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   ","version":"0.6.2","tagName":"h2"},{"title":"More about Resources​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.2/docs/concepts/resource-group-definitions#more-about-resources","content":" Users can specify more controls in resources in .spec.resources[]  spec: resources: - id: my-resource template || externalRef: {} # users can either template resources or reference objects outside the graph readyWhen: # users can specify CEL expressions to determine when a resource is ready - ${deployment.status.conditions.exists(x, x.type == 'Available' &amp;&amp; x.status == &quot;True&quot;)} includeWhen: # users can specify CEL expressions to determine when a resource should be included in the graph - ${schema.spec.value.enabled}   ","version":"0.6.2","tagName":"h2"},{"title":"Using externalRef to reference Objects outside the ResourceGraphDefinition.​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.2/docs/concepts/resource-group-definitions#using-externalref-to-reference-objects-outside-the-resourcegraphdefinition","content":" Users can specify if the object is something that is created out-of-band and needs to be referenced in the RGD. An external reference could be specified like this:  resources: id: projectConfig externalRef: apiVersion: corp.platform.com/v1 kind: Project metadata: name: default-project namespace: # optional, if empty uses instance namespace   As part of processing the Resource Graph, the instance reconciler waits for the externalRef object to be present and reads the object from the cluster as a node in the graph. Subsequent resources can use data from this node.  ","version":"0.6.2","tagName":"h3"},{"title":"Using Conditional CEL Expressions (?)​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.2/docs/concepts/resource-group-definitions#using-conditional-cel-expressions-","content":" KRO can make use of CEL Expressions (see this proposal for details or look at the CEL Implementation Reference) to define optional runtime conditions for resources based on the conditional operator ?.  This allows you to optionally define values that have no predefined schema or are not hard dependencies in the Graph.  Using ? for referencing schema-less objects like ConfigMap or Secret​  You can use the optional operator to reference objects that do not have a predefined schema in the ResourceGraphDefinition. This is useful for referencing objects that may or may not exist at runtime.  ⚠️ ? removes the ability of KRO to introspect the schema of the referenced object. Thus, it cannot wait for fields after the ? to be present. It is recommended to use conditional expressions only for objects that are not critical to the ResourceGraphDefinition's operation or when the schema cannot be known at design time.  A config map can be referenced like this:  config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: VALUE: &quot;foobar&quot;   external reference in ResourceGraphDefinition - id: external externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default   With this reference, you can access the data in your schema:  CEL Expression ${external.data.?VALUE}   ⚠️ KRO will only wait for the external reference to be present in the cluster, but it will not validate the schema of the referenced config. If the config map does not have the VALUE field, the expression will evaluate to null and might result in unexpected behavior in your application if not handled properly.  For a more detailed example, see the Optional Values &amp; External References documentation.  ","version":"0.6.2","tagName":"h3"},{"title":"Status Reporting​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.2/docs/concepts/resource-group-definitions#status-reporting","content":" The status section of a ResourceGraphDefinition provides information about the state of the graph and it's generated CustomResourceDefinition and controller.  status includes a stable Ready condition (as well as a set of technical status.conditions that provide more detailed information about the state of the graph and its resources).  info When the Ready condition status is True, it indicates that the ResourceGraphDefinition is valid and you can use it to create instances.  warning Try to only rely on the Ready condition, as other condition types may change frequently and are more technical in nature, can change their API over time and are generally more indicative of KRO's internal state.  Additionally, the ResourceGraphDefinition contains a topologicalOrder field that provides a list of resources in the order they should be processed. This is useful for understanding the dependencies between resources and their apply order.  Generally a status in ResourceGraphDefinition may look like  status: conditions: - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: resource graph and schema are valid observedGeneration: 1 reason: Valid status: &quot;True&quot; type: ResourceGraphAccepted - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: kind DeploymentService has been accepted and ready observedGeneration: 1 reason: Ready status: &quot;True&quot; type: KindReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: controller is running observedGeneration: 1 reason: Running status: &quot;True&quot; type: ControllerReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready state: Active topologicalOrder: - configmap - deployment  ","version":"0.6.2","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/0.6.2/examples/","content":"","keywords":"","version":"0.6.2"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/0.6.2/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.6.2","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/0.6.2/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.6.2","tagName":"h2"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/0.6.1/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.6.1"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/0.6.1/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.6.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/0.6.1/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.6.1","tagName":"h2"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.6.1/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.6.1"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.6.2/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.6.2"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.2/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.6.2","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.2/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.6.2","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.2/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.6.2","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.2/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inspect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.6.2","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.2/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates the creation of a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.6.2","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/0.6.2/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.6.2","tagName":"h3"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/0.6.2/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.6.2"},{"title":"Instances","type":0,"sectionRef":"#","url":"/0.6.2/docs/concepts/instances","content":"","keywords":"","version":"0.6.2"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/0.6.2/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.6.2","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/0.6.2/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.6.2","tagName":"h2"},{"title":"Reactive Reconciliation​","type":1,"pageTitle":"Instances","url":"/0.6.2/docs/concepts/instances#reactive-reconciliation","content":" kro automatically watches all resources managed by an instance and triggers reconciliation when any of them change. This means:  Child Resource Changes: When a managed resource (like a Deployment or Service) is modified, kro detects the change and reconciles the instance to ensure it matches the desired state defined in your ResourceGraphDefinition. Drift Detection: If a resource is manually modified or deleted, kro will detect the drift and automatically restore it to the desired state. Dependency Updates: Changes to resources propagate through the dependency graph, ensuring all dependent resources are updated accordingly.  This reactive behavior ensures your instances maintain consistency without requiring manual intervention or periodic full reconciliations.  ","version":"0.6.2","tagName":"h3"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/0.6.2/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: instance is properly managed with finalizers and labels observedGeneration: 1 reason: Managed status: &quot;True&quot; type: InstanceManaged - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: runtime graph created and all resources resolved observedGeneration: 1 reason: Resolved status: &quot;True&quot; type: GraphResolved - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: all resources are created and ready observedGeneration: 1 reason: AllResourcesReady status: &quot;True&quot; type: ResourcesReady - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready   ","version":"0.6.2","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/0.6.2/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status ACTIVE: Indicates that the instance is successfully running and active.IN_PROGRESS: Indicates that the instance is currently being processed or reconciled.FAILED: Indicates that the instance has failed to be properly reconciled.DELETING: Indicates that the instance is in the process of being deleted.ERROR: Indicates that an error occurred during instance processing. Conditions: Detailed status information structured hierarchically kro provides a top-level Ready condition that reflects the overall instance health. This condition is supported by three sub-conditions that track different phases of the reconciliation process: InstanceManaged: Instance finalizers and labels are properly set Ensures the instance is under kro's managementTracks whether cleanup handlers (finalizers) are configuredConfirms instance is labeled with ownership and version information GraphResolved: Runtime graph has been created and resources resolved Validates that the resource graph has been successfully parsedConfirms all resource templates have been resolvedEnsures dependencies between resources are properly understood ResourcesReady: All resources in the graph are created and ready Tracks the creation and readiness of all managed resourcesMonitors the health of resources in topological orderReports when all resources have reached their ready state Ready: Instance is fully operational (top-level condition) Aggregates the state of all sub-conditionsOnly becomes True when all sub-conditions are TrueThe primary condition to monitor and wait on for instance healthUse this condition in automation, CI/CD, and health checks tip Always use the Ready condition to determine instance health. The sub-conditions (InstanceManaged, GraphResolved, ResourcesReady) are provided for debugging purposes and may change in future versions. kro reserves the right to add, remove, or modify sub-conditions without breaking compatibility as long as the Ready condition behavior remains stable. Each condition includes: observedGeneration: Tracks which generation of the instance this condition reflectslastTransitionTime: When the condition last changed statereason: A programmatic identifier for the condition statemessage: A human-readable description of the current state Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.6.2","tagName":"h3"},{"title":"Debugging Instance Issues​","type":1,"pageTitle":"Instances","url":"/0.6.2/docs/concepts/instances#debugging-instance-issues","content":" When an instance is not in the expected state, the condition hierarchy helps you quickly identify where the problem occurred:  Check the Ready condition first kubectl get &lt;your-kind&gt; &lt;instance-name&gt; -o jsonpath='{.status.conditions[?(@.type==&quot;Ready&quot;)]}' If Ready is False, check the sub-conditions to identify which phase failed: If InstanceManaged is False: Check if there are issues with finalizers or instance labelsIf GraphResolved is False: The resource graph could not be created - check the ResourceGraphDefinition for syntax errors or invalid CEL expressionsIf ResourcesReady is False: One or more managed resources failed to become ready - check the error message for which resource failed Use kubectl describe to see all conditions and recent events: kubectl describe &lt;your-kind&gt; &lt;instance-name&gt; Check the observedGeneration field in conditions: If observedGeneration is less than metadata.generation, the controller hasn't processed the latest changes yetIf they match, the conditions reflect the current state of your instance  ","version":"0.6.2","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/0.6.2/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Focus on the Ready condition and its sub-conditions to understand the reconciliation state. Monitor observedGeneration: When making changes to an instance, verify thatobservedGeneration in the conditions matches metadata.generation to ensure kro has processed your changes. Leverage Reactive Reconciliation: kro automatically detects and corrects drift in managed resources. If you need to make manual changes to resources, update the instance specification instead to ensure changes persist and align with your desired state. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.6.2","tagName":"h2"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/0.6.2/docs/concepts/simple-schema","content":"","keywords":"","version":"0.6.2"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.6.2","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesfloat: Decimal numbers  For example:  name: string age: integer enabled: boolean price: float   ","version":"0.6.2","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.6.2","tagName":"h3"},{"title":"Unstructured Objects​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#unstructured-objects","content":" Unstructured objects are declared using object as a type.  warning This disables the field-validation normally offered by kro, and forwards the values to your RGD as-is. This is generally discouraged and should therefore be used with caution. In most cases, using a structured object is a better approach.  kind: ResourceGraphDefintion metadata: {} spec: schema: spec: additionalHelmChartValues: object   This allows you to pass data to your CRDs directly in cases where the schema is not known in advance. This type supports any valid object, and can mix and match different primitives as well as structured types.  apiVersion: kro.run/v1alpha1 kind: CRDWithUnstructuredObjects metadata: name: test-instance spec: additionalHelmChartValues: boolean-value: true numeric-value: 42 structural-type: with-additional: nested: fields string-value: my-string mapping-value: - item1 - item2 - item3   ","version":"0.6.2","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.6.2","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]float&quot;   ","version":"0.6.2","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#custom-types","content":" Custom types are specified in the separate types section. They provide a map of names to type specifications that follow the simple schema.  Example:  schema: types: Person: name: string age: integer spec: people: '[]Person | required=true`   ","version":"0.6.2","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.6.2","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbersimmutable=true: Field cannot be changed after creationpattern=&quot;regex&quot;: Regular expression pattern for string validationminLength=number: Minimum length for stringsmaxLength=number: Maximum length for stringsuniqueItems=true: Ensures array elements are uniqueminItems=number: Minimum number of items in arraysmaxItems=number: Maximum number of items in arrays  Multiple markers can be combined using the | separator.  ","version":"0.6.2","tagName":"h3"},{"title":"String Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#string-validation-markers","content":" String fields support additional validation markers:  pattern=&quot;regex&quot;: Validates the string against a regular expression patternminLength=number: Sets the minimum number of charactersmaxLength=number: Sets the maximum number of characters  Examples:  # Email validation email: string | pattern=&quot;^[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w+$&quot; required=true # Username with length constraints and pattern username: string | minLength=3 maxLength=15 pattern=&quot;^[a-zA-Z0-9_]+$&quot; # Country code format countryCode: string | pattern=&quot;^[A-Z]{2}$&quot; minLength=2 maxLength=2 # Password with minimum length password: string | minLength=8 description=&quot;Password must be at least 8 characters&quot;   ","version":"0.6.2","tagName":"h3"},{"title":"Array Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#array-validation-markers","content":" Array fields support validation markers to ensure data quality:  uniqueItems=true: Ensures all elements in the array are uniqueuniqueItems=false: Allows duplicate elements (default behavior)minItems=number: Sets the minimum number of elements required in the arraymaxItems=number: Sets the maximum number of elements allowed in the array  Examples:  # Unique tags with size constraints tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot; # Unique port numbers with minimum requirement ports: &quot;[]integer&quot; | uniqueItems=true minItems=1 description=&quot;At least one unique port&quot; # Allow duplicate comments with size limits comments: &quot;[]string&quot; | uniqueItems=false maxItems=50 description=&quot;Up to 50 comments&quot; # Complex validation with multiple markers roles: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=5 required=true description=&quot;1-5 unique user roles&quot; # Optional array with size constraints priorities: &quot;[]integer&quot; | minItems=0 maxItems=3 description=&quot;Up to 3 priority levels&quot;   For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; id: string | required=true immutable=true description=&quot;Unique identifier&quot; replicas: integer | default=3 minimum=1 maximum=10 price: float | minimum=0.01 maximum=999.99 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot; email: string | pattern=&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$&quot; description=&quot;Valid email address&quot; username: string | minLength=3 maxLength=20 pattern=&quot;^[a-zA-Z0-9_]+$&quot; tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot;   Floating Point Precision When using float or double types in CEL expressions (particularly in readyWhen or includeWhen conditions), be aware of floating point precision issues that could cause unexpected behavior. Avoid comparing floating point values for equality in conditional logic. Prefer using string, integer, or boolean types whenever possible to avoid precision-related oscillations in resource state.  ","version":"0.6.2","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources exist at ResourceGraphDefinition creation timeUpdates values when the underlying resources changeValidates type compatibility using CEL's native type system  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} # integer endpoint: ${service.status.loadBalancer.ingress[0].hostname} # string metadata: ${deployment.metadata} # object   ","version":"0.6.2","tagName":"h2"},{"title":"Single vs Multi-Expression Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#single-vs-multi-expression-fields","content":" Status fields can contain either a single CEL expression or multiple expressions concatenated together:  Single Expression Fields can be any type:  status: replicas: ${deployment.status.replicas} # integer metadata: ${deployment.metadata} # object name: ${deployment.metadata.name} # string ready: ${deployment.status.conditions.exists(c, c.type == 'Available')} # boolean   Multi-Expression Fields (string templating) must contain only string expressions:  status: # ✓ Valid - all expressions return strings endpoint: &quot;https://${service.metadata.name}.${service.metadata.namespace}.svc.cluster.local&quot; # ✓ Valid - explicit string conversion summary: &quot;Replicas: ${string(deployment.status.replicas)}, Ready: ${string(deployment.status.ready)}&quot; # ✗ Invalid - concatenating non-string types invalid: &quot;${deployment.status.replicas}-${deployment.metadata}&quot; # Will fail validation   Multi-expression fields are useful for string templating scenarios like constructing URLs, connection strings, or IAM policies:  status: iamPolicy: | { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Resource&quot;: &quot;arn:aws:s3:::${bucket.metadata.name}/*&quot;, &quot;Principal&quot;: &quot;${serviceAccount.metadata.name}&quot; }   tip Use explicit string() conversions when concatenating non-string values to ensure type compatibility. Alternatively, you can use CEL's built-in format() function for string formatting: status: endpoint: ${&quot;https://%s.%s.svc.cluster.local&quot;.format([service.metadata.name, service.metadata.namespace])} The ${...}${...} templating syntax is a kro convenience feature that makes common string concatenation patterns more readable.  ","version":"0.6.2","tagName":"h3"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.6.2","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;InstanceManaged&quot;, &quot;GraphResolved&quot;, &quot;ResourcesReady&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string observedGeneration: integer reason: string message: string   kro provides a hierarchical condition structure:  Ready: Top-level condition indicating the instance is fully operational InstanceManaged: Instance finalizers and labels are properly setGraphResolved: Runtime graph has been created and resources resolvedResourcesReady: All resources in the graph are created and ready  The Ready condition aggregates the state of all sub-conditions and only becomes True when all sub-conditions are True. Each condition includes an observedGeneration field that tracks which generation of the instance the condition reflects.  ","version":"0.6.2","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # ACTIVE, IN_PROGRESS, FAILED, DELETING, ERROR   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values.  ","version":"0.6.2","tagName":"h3"},{"title":"Additional Printer Columns​","type":1,"pageTitle":"Simple Schema","url":"/0.6.2/docs/concepts/simple-schema#additional-printer-columns","content":" You can define additionalPrinterColumns for the created CRD through the ResourceGraphDefinition by setting them on spec.schema.additionalPrinterColumns.  schema: spec: image: string | default=&quot;nginx&quot; status: availableReplicas: ${deployment.status.availableReplicas} additionalPrinterColumns: - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string  ","version":"0.6.2","tagName":"h2"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/0.6.2/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.6.2"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/0.6.1/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.6.1"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/0.6.1/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.6.1","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/0.6.1/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.6.1","tagName":"h2"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/0.6.1/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.6.1"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.1/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Definition) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.6.1","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.1/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteriaExternal References  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.6.1","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.1/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions} validation: # Validating admission policies added to the new API type's CRD - expression: &quot;${ self.image == 'nginx' || !self.ingress.enabled }&quot; message: &quot;Only nginx based applications can have ingress enabled&quot; additionalPrinterColumns: # Printer columns shown for the created custom resource - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.6.1","tagName":"h2"},{"title":"Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.1/docs/concepts/resource-group-definitions#processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acyclic Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions using CEL's native type system Validates field references exist in the actual resource schemasEnsures expressions return types compatible with their target fieldsValidates that CEL functions called in expressions exist and are used correctlyChecks expression correctness and type compatibility statically without executing expressions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and their managed resources: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource statesAutomatically detects and reconciles drift in managed resourcesTriggers reconciliation when any managed resource changes  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.6.1","tagName":"h2"},{"title":"Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.1/docs/concepts/resource-group-definitions#instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can create instances of it. Here's an example of how an instance for theWebApplication might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   ","version":"0.6.1","tagName":"h2"},{"title":"More about Resources​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.1/docs/concepts/resource-group-definitions#more-about-resources","content":" Users can specify more controls in resources in .spec.resources[]  spec: resources: - id: my-resource template || externalRef: {} # users can either template resources or reference objects outside the graph readyWhen: # users can specify CEL expressions to determine when a resource is ready - ${deployment.status.conditions.exists(x, x.type == 'Available' &amp;&amp; x.status == &quot;True&quot;)} includeWhen: # users can specify CEL expressions to determine when a resource should be included in the graph - ${schema.spec.value.enabled}   ","version":"0.6.1","tagName":"h2"},{"title":"Using externalRef to reference Objects outside the ResourceGraphDefinition.​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.1/docs/concepts/resource-group-definitions#using-externalref-to-reference-objects-outside-the-resourcegraphdefinition","content":" Users can specify if the object is something that is created out-of-band and needs to be referenced in the RGD. An external reference could be specified like this:  resources: id: projectConfig externalRef: apiVersion: corp.platform.com/v1 kind: Project metadata: name: default-project namespace: # optional, if empty uses instance namespace   As part of processing the Resource Graph, the instance reconciler waits for the externalRef object to be present and reads the object from the cluster as a node in the graph. Subsequent resources can use data from this node.  ","version":"0.6.1","tagName":"h3"},{"title":"Using Conditional CEL Expressions (?)​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.1/docs/concepts/resource-group-definitions#using-conditional-cel-expressions-","content":" KRO can make use of CEL Expressions (see this proposal for details or look at the CEL Implementation Reference) to define optional runtime conditions for resources based on the conditional operator ?.  This allows you to optionally define values that have no predefined schema or are not hard dependencies in the Graph.  Using ? for referencing schema-less objects like ConfigMap or Secret​  You can use the optional operator to reference objects that do not have a predefined schema in the ResourceGraphDefinition. This is useful for referencing objects that may or may not exist at runtime.  ⚠️ ? removes the ability of KRO to introspect the schema of the referenced object. Thus, it cannot wait for fields after the ? to be present. It is recommended to use conditional expressions only for objects that are not critical to the ResourceGraphDefinition's operation or when the schema cannot be known at design time.  A config map can be referenced like this:  config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: VALUE: &quot;foobar&quot;   external reference in ResourceGraphDefinition - id: external externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default   With this reference, you can access the data in your schema:  CEL Expression ${external.data.?VALUE}   ⚠️ KRO will only wait for the external reference to be present in the cluster, but it will not validate the schema of the referenced config. If the config map does not have the VALUE field, the expression will evaluate to null and might result in unexpected behavior in your application if not handled properly.  For a more detailed example, see the Optional Values &amp; External References documentation.  ","version":"0.6.1","tagName":"h3"},{"title":"Status Reporting​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/0.6.1/docs/concepts/resource-group-definitions#status-reporting","content":" The status section of a ResourceGraphDefinition provides information about the state of the graph and it's generated CustomResourceDefinition and controller.  status includes a stable Ready condition (as well as a set of technical status.conditions that provide more detailed information about the state of the graph and its resources).  info When the Ready condition status is True, it indicates that the ResourceGraphDefinition is valid and you can use it to create instances.  warning Try to only rely on the Ready condition, as other condition types may change frequently and are more technical in nature, can change their API over time and are generally more indicative of KRO's internal state.  Additionally, the ResourceGraphDefinition contains a topologicalOrder field that provides a list of resources in the order they should be processed. This is useful for understanding the dependencies between resources and their apply order.  Generally a status in ResourceGraphDefinition may look like  status: conditions: - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: resource graph and schema are valid observedGeneration: 1 reason: Valid status: &quot;True&quot; type: ResourceGraphAccepted - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: kind DeploymentService has been accepted and ready observedGeneration: 1 reason: Ready status: &quot;True&quot; type: KindReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: controller is running observedGeneration: 1 reason: Running status: &quot;True&quot; type: ControllerReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready state: Active topologicalOrder: - configmap - deployment  ","version":"0.6.1","tagName":"h2"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.6.1/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployment on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.6.1"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/0.6.2/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.6.2"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/0.6.2/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployment on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.6.2"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/0.6.2/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.6.2"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/0.6.2/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.6.2"},{"title":"Optional Values & External References","type":0,"sectionRef":"#","url":"/0.6.2/examples/basic/optionals","content":"Optional Values &amp; External References config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: ECHO_VALUE: &quot;Hello, World!&quot; deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: input externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $MY_VALUE &amp;&amp; sleep 3600&quot;] env: - name: MY_VALUE value: ${input.data.?ECHO_VALUE} ","keywords":"","version":"0.6.2"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/0.6.2/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.6.2"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/0.6.2/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.6.2"},{"title":"ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/next/api/crds/resourcegraphdefinition","content":"","keywords":"","version":"main"},{"title":"API Specification​","type":1,"pageTitle":"ResourceGraphDefinition","url":"/next/api/crds/resourcegraphdefinition#api-specification","content":" API Version kro.run/v1alpha1 Kind ResourceGraphDefinition Scope Cluster    ","version":"main","tagName":"h2"},{"title":"Fields Reference​","type":1,"pageTitle":"ResourceGraphDefinition","url":"/next/api/crds/resourcegraphdefinition#fields-reference","content":" Loading API reference... ","version":"main","tagName":"h2"},{"title":"Reference","type":0,"sectionRef":"#","url":"/next/api/reference","content":"","keywords":"","version":"main"},{"title":"CRDs​","type":1,"pageTitle":"Reference","url":"/next/api/reference#crds","content":" Custom Resource Definitions (CRDs) that extend Kubernetes with kro's functionality.  ResourceGraphDefinition - The core API for defining custom Kubernetes resources that orchestrate multiple underlying resources. Define your resource schemas, specify resource dependencies, and create reusable infrastructure patterns.  ","version":"main","tagName":"h2"},{"title":"Specifications​","type":1,"pageTitle":"Reference","url":"/next/api/reference#specifications","content":" Schema and language specifications used when authoring kro resources.  SimpleSchema - A concise schema definition language for defining resource structures in ResourceGraphDefinitions without writing verbose OpenAPI schemas. ","version":"main","tagName":"h2"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/next/docs/concepts/access-control","content":"","keywords":"","version":"main"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/next/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"main","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/next/docs/concepts/access-control#aggregation-access","content":" In the aggregation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"main","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/next/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"main","tagName":"h3"},{"title":"Instances","type":0,"sectionRef":"#","url":"/next/docs/concepts/instances","content":"","keywords":"","version":"main"},{"title":"What is an Instance?​","type":1,"pageTitle":"Instances","url":"/next/docs/concepts/instances#what-is-an-instance","content":" An instance represents your deployed application. When you create an instance, you provide configuration values and kro deploys all the resources defined in your ResourceGraphDefinition. The instance serves as the single source of truth for your application's desired state.  Here's an example instance:  apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"main","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/next/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe - Watches for changes to your instance or its resourcesCompare - Checks if current state matches desired stateAct - Creates, updates, or deletes resources as neededReport - Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing:  Self-healing if resources are modified or deletedAutomatic updates when you change the instanceConsistent state managementRich status tracking  ","version":"main","tagName":"h2"},{"title":"Reactive Reconciliation​","type":1,"pageTitle":"Instances","url":"/next/docs/concepts/instances#reactive-reconciliation","content":" kro automatically watches all resources managed by an instance and triggers reconciliation when any of them change:  Child Resource Changes - When a managed resource (like a Deployment or Service) is modified, kro detects the change and reconciles the instance to ensure it matches the desired state.Drift Detection - If a resource is manually modified or deleted, kro detects the drift and automatically restores it to the desired state.Dependency Updates - Changes to resources propagate through the dependency graph, ensuring all dependent resources are updated accordingly.  This reactive behavior ensures your instances maintain consistency without requiring manual intervention.  ","version":"main","tagName":"h3"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/next/docs/concepts/instances#monitoring-your-instances","content":" kro provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS READY AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from your resources conditions: # Detailed status conditions - type: InstanceManaged status: &quot;True&quot; reason: Managed message: instance is properly managed with finalizers and labels lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; observedGeneration: 1 - type: GraphResolved status: &quot;True&quot; reason: Resolved message: runtime graph created and all resources resolved lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; observedGeneration: 1 - type: ResourcesReady status: &quot;True&quot; reason: AllResourcesReady message: all resources are created and ready lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; observedGeneration: 1 - type: Ready status: &quot;True&quot; reason: Ready message: &quot;&quot; lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; observedGeneration: 1   ","version":"main","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/next/docs/concepts/instances#understanding-status","content":" Every instance includes three types of status information:  ","version":"main","tagName":"h2"},{"title":"1. State​","type":1,"pageTitle":"Instances","url":"/next/docs/concepts/instances#1-state","content":" High-level status showing what the instance is doing:  ACTIVE - Instance is successfully running and activeIN_PROGRESS - Instance is currently being processed or reconciledFAILED - Instance failed to reconcile properlyDELETING - Instance is being deletedERROR - An error occurred during processing  ","version":"main","tagName":"h3"},{"title":"2. Conditions​","type":1,"pageTitle":"Instances","url":"/next/docs/concepts/instances#2-conditions","content":" Detailed status information structured hierarchically. kro provides a top-level Ready condition that reflects overall instance health, supported by three sub-conditions that track different phases:  InstanceManaged - Instance finalizers and labels are properly set Ensures the instance is under kro's managementTracks whether cleanup handlers (finalizers) are configuredConfirms instance is labeled with ownership and version information GraphResolved - Runtime graph has been created and resources resolved Validates that the resource graph has been successfully parsedConfirms all resource templates have been resolvedEnsures dependencies between resources are properly understood ResourcesReady - All resources in the graph are created and ready Tracks the creation and readiness of all managed resourcesMonitors the health of resources in topological orderReports when all resources have reached their ready state Ready - Instance is fully operational (top-level condition) Aggregates the state of all sub-conditionsOnly becomes True when all sub-conditions are TrueThe primary condition to monitor for instance healthUse this condition in automation, CI/CD, and health checks  tip Always use the Ready condition to determine instance health. The sub-conditions (InstanceManaged, GraphResolved, ResourcesReady) are provided for debugging purposes and may change in future versions. kro reserves the right to add, remove, or modify sub-conditions without breaking compatibility as long as the Ready condition behavior remains stable.  Each condition includes:  observedGeneration - Tracks which generation of the instance this condition reflectslastTransitionTime - When the condition last changed statereason - A programmatic identifier for the condition statemessage - A human-readable description of the current state  ","version":"main","tagName":"h3"},{"title":"3. Resource Status​","type":1,"pageTitle":"Instances","url":"/next/docs/concepts/instances#3-resource-status","content":" Values you defined in your ResourceGraphDefinition's status section, automatically updated as resources change.  ","version":"main","tagName":"h3"},{"title":"Debugging Instance Issues​","type":1,"pageTitle":"Instances","url":"/next/docs/concepts/instances#debugging-instance-issues","content":" When an instance is not in the expected state, the condition hierarchy helps you quickly identify where the problem occurred:  1. Check the Ready condition first:  kubectl get &lt;your-kind&gt; &lt;instance-name&gt; -o jsonpath='{.status.conditions[?(@.type==&quot;Ready&quot;)]}'   2. If Ready is False, check the sub-conditions to identify which phase failed:  InstanceManaged is False - Check if there are issues with finalizers or instance labelsGraphResolved is False - The resource graph could not be created - check the ResourceGraphDefinition for syntax errors or invalid CEL expressionsResourcesReady is False - One or more managed resources failed to become ready - check the error message for which resource failed  3. Use kubectl describe to see all conditions and recent events:  kubectl describe &lt;your-kind&gt; &lt;instance-name&gt;   4. Check the observedGeneration field in conditions:  If observedGeneration is less than metadata.generation, the controller hasn't processed the latest changes yetIf they match, the conditions reflect the current state of your instance  ","version":"main","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/next/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history.  Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to sub-resources for easy identification.  Monitor the Ready Condition: Regularly check instance status beyond just &quot;Running&quot;. Watch the Ready condition and its sub-conditions to understand the reconciliation state and catch potential issues early.  Check observedGeneration: When making changes to an instance, verify that observedGeneration in the conditions matches metadata.generation to ensure kro has processed your changes.  Leverage Reactive Reconciliation: kro automatically detects and corrects drift in managed resources. If you need to make manual changes to resources, update the instance specification instead to ensure changes persist and align with your desired state.  Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"main","tagName":"h2"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/0.6.2/examples/gcp/eventarc","content":"","keywords":"","version":"0.6.2"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.6.2/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.6.2","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/0.6.2/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.6.2","tagName":"h2"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/0.6.2/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.6.2"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/0.6.2/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.6.2"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/0.6.2/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.6.2","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/0.6.2/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.6.2","tagName":"h2"},{"title":"Overview","type":0,"sectionRef":"#","url":"/next/docs/concepts/rgd/overview","content":"","keywords":"","version":"main"},{"title":"How it Works​","type":1,"pageTitle":"Overview","url":"/next/docs/concepts/rgd/overview#how-it-works","content":" You create an RGD defining a new API (like Application)kro generates a CRD for your APIUsers create instances of your APIkro creates and manages all the underlying resources    ","version":"main","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Overview","url":"/next/docs/concepts/rgd/overview#example","content":" Here's an RGD that creates a new Application API. When users create an Application, kro automatically creates a Deployment:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: application spec: schema: apiVersion: v1alpha1 kind: Application spec: name: string image: string | default=&quot;nginx:latest&quot; replicas: integer | default=3 resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: ${schema.spec.replicas} selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: app image: ${schema.spec.image}   Users can now create applications:  apiVersion: v1alpha1 kind: Application metadata: name: my-app spec: name: my-app image: nginx:1.27 replicas: 5   kro will create and manage the Deployment automatically.  ","version":"main","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"Overview","url":"/next/docs/concepts/rgd/overview#anatomy-of-a-resourcegraphdefinition","content":" An RGD has the standard Kubernetes resource structure:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: {} # Standard Kubernetes metadata spec: schema: {} # Define your custom API resources: [] # Define Kubernetes resources to create status: # Managed by kro conditions: [] state: &quot;&quot; topologicalOrder: []   metadata — Standard Kubernetes metadata (name, labels, annotations)spec.schema — Your custom API: what fields users can configure and what computed values to exposespec.resources — The Kubernetes resources to create and manage (Deployments, Services, etc.)status — Current state managed by kro: conditions, overall state, and computed creation order  ","version":"main","tagName":"h2"},{"title":"How kro Processes RGDs​","type":1,"pageTitle":"Overview","url":"/next/docs/concepts/rgd/overview#how-kro-processes-rgds","content":" kro performs extensive static analysis to catch errors before deployment. Rather than discovering issues when users create instances, kro validates everything upfront when you create the RGD. Type errors, non-existent fields, missing CRDs, syntax issues, and circular dependencies are all caught during RGD creation, giving you immediate feedback.    ","version":"main","tagName":"h2"},{"title":"Static Analysis and Validation​","type":1,"pageTitle":"Overview","url":"/next/docs/concepts/rgd/overview#static-analysis-and-validation","content":" kro validates your RGD before any instances are created. When you create a ResourceGraphDefinition:  Schema validation - Ensures your schema follows the SimpleSchema formatCRD verification - Validates that all referenced resource types (Deployments, Services, etc.) exist in your clusterCEL type checking - Parses and validates all CEL expressions, checking that: Referenced fields exist in the actual resource schemasExpression output types match their target field typesAll expressions are syntactically correct Dependency inference - Automatically analyzes CEL expressions to infer resource dependencies and compute the creation order  This validation happens at RGD creation time, catching errors early before any user creates an instance.  ","version":"main","tagName":"h3"},{"title":"Automatic Dependency Management​","type":1,"pageTitle":"Overview","url":"/next/docs/concepts/rgd/overview#automatic-dependency-management","content":" kro analyzes your CEL expressions to automatically infer dependencies between resources. For example, if a Service references ${deployment.metadata.name}, kro knows the Deployment must be created first. This dependency graph is used to:  Compute creation order - Resources are created in topological orderCompute deletion order - Resources are deleted in reverse topological orderDetect circular dependencies - kro rejects RGDs with circular dependenciesShow the order - The computed order appears in status.topologicalOrder  See Dependencies &amp; Ordering for details on how this works.  ","version":"main","tagName":"h3"},{"title":"Generated CRDs and Controllers​","type":1,"pageTitle":"Overview","url":"/next/docs/concepts/rgd/overview#generated-crds-and-controllers","content":" When your RGD is validated and accepted:  CRD generation - kro generates a CustomResourceDefinition for your API and registers it with the Kubernetes API serverDynamic controller - kro configures itself to watch for instances of your new APILifecycle management - The controller creates resources in dependency order, evaluates CEL expressions, manages status updates, and handles deletion  ","version":"main","tagName":"h3"},{"title":"What RGDs Provide​","type":1,"pageTitle":"Overview","url":"/next/docs/concepts/rgd/overview#what-rgds-provide","content":" Type safety: All CEL expressions are validated when you create the RGDDependency management: kro automatically determines the order to create resourcesValidation: Users get immediate feedback if they provide invalid valuesReusability: Define once, use many times across teams  ","version":"main","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Overview","url":"/next/docs/concepts/rgd/overview#next-steps","content":" Explore the details of ResourceGraphDefinitions:  Schema - Define your custom API structureResource Basics - Define resources with CEL expressionsConditional Creation - Create resources conditionally with includeWhenReadiness - Control when resources are considered readyExternal References - Reference resources outside your RGDCEL Expressions - Reference data between resourcesDependencies &amp; Ordering - How kro infers dependencies and determines creation orderStatic Type Checking - How kro validates RGDs before instances are created ","version":"main","tagName":"h2"},{"title":"Conditionals","type":0,"sectionRef":"#","url":"/next/docs/concepts/rgd/resource-definitions/conditional-creation","content":"","keywords":"","version":"main"},{"title":"Basic Example​","type":1,"pageTitle":"Conditionals","url":"/next/docs/concepts/rgd/resource-definitions/conditional-creation#basic-example","content":" Here's a simple example where an Ingress resource is only created if the user enables it in their instance spec:  resources: - id: ingress includeWhen: - ${schema.spec.ingress.enabled} template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name} # ... rest of ingress configuration   When a user creates an instance:  apiVersion: example.com/v1 kind: Application metadata: name: my-app spec: name: my-app ingress: enabled: true # Ingress will be created   If ingress.enabled is false or not provided, the Ingress resource is skipped entirely.  ","version":"main","tagName":"h2"},{"title":"How includeWhen Works​","type":1,"pageTitle":"Conditionals","url":"/next/docs/concepts/rgd/resource-definitions/conditional-creation#how-includewhen-works","content":" includeWhen is a list of CEL expressions that control whether a resource is created:  If all expressions evaluate to true, the resource is includedIf any expression evaluates to false, the resource is skippedEach expression must evaluate to a boolean value (true or false)  ","version":"main","tagName":"h2"},{"title":"What You Can Reference​","type":1,"pageTitle":"Conditionals","url":"/next/docs/concepts/rgd/resource-definitions/conditional-creation#what-you-can-reference","content":" Currently, includeWhen expressions can only reference schema.spec fields:  # ✓ Valid - references schema.spec and returns boolean includeWhen: - ${schema.spec.ingress.enabled} - ${schema.spec.environment == &quot;production&quot;} - ${schema.spec.replicas &gt; 3}   # ✗ Invalid - must return boolean includeWhen: - ${schema.spec.appName} # returns string, not boolean   kro validates includeWhen expressions when you create the ResourceGraphDefinition, ensuring they reference valid fields and return boolean values.  note Currently, includeWhen can only reference schema.spec because conditions are evaluated before any resources are created. Support for conditional inclusion based on other resources' states is planned for future releases.  ","version":"main","tagName":"h2"},{"title":"Dependencies and Skipped Resources​","type":1,"pageTitle":"Conditionals","url":"/next/docs/concepts/rgd/resource-definitions/conditional-creation#dependencies-and-skipped-resources","content":" When a resource is skipped (due to includeWhen conditions), all resources that depend on it are also skipped.    In this example, the Deployment on the left has includeWhen: ${true}, so it's included along with all its children (Service and Ingress). The Deployment on the right (shown in red) has a condition that evaluates to false, so it and all its dependencies are skipped.  This ensures that the resource graph remains consistent and prevents resources from referencing other resources that don't exist.  ","version":"main","tagName":"h2"},{"title":"Multiple Conditions​","type":1,"pageTitle":"Conditionals","url":"/next/docs/concepts/rgd/resource-definitions/conditional-creation#multiple-conditions","content":" All conditions in includeWhen must be true (logical AND):  resources: - id: certificate includeWhen: - ${schema.spec.ingress.enabled} - ${schema.spec.ingress.tls} template: apiVersion: cert-manager.io/v1 kind: Certificate # ... certificate config   The certificate is created only if:  ingress.enabled is true ANDingress.tls is true  For OR logic, combine in a single expression:  includeWhen: - ${schema.spec.env == &quot;staging&quot; || schema.spec.env == &quot;production&quot;}   ","version":"main","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Conditionals","url":"/next/docs/concepts/rgd/resource-definitions/conditional-creation#next-steps","content":" Readiness - Control when resources are considered readyResource Basics - Learn about resource template structure ","version":"main","tagName":"h2"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/0.6.2/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.6.2"},{"title":"External References","type":0,"sectionRef":"#","url":"/next/docs/concepts/rgd/resource-definitions/external-references","content":"","keywords":"","version":"main"},{"title":"Basic Example​","type":1,"pageTitle":"External References","url":"/next/docs/concepts/rgd/resource-definitions/external-references#basic-example","content":" Here's a simple example where an application references a shared ConfigMap that exists in the cluster:  resources: - id: sharedConfig externalRef: apiVersion: v1 kind: ConfigMap metadata: name: platform-config namespace: platform-system - id: app template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: template: spec: containers: - name: app image: ${schema.spec.image} env: - name: PLATFORM_URL value: ${sharedConfig.data.?platformUrl} - name: REGION value: ${sharedConfig.data.?region}   The app deployment won't be created until:  The platform-config ConfigMap exists in the platform-system namespacekro successfully reads the ConfigMap and makes its data available  This allows multiple instances to share the same configuration without duplicating it.  ","version":"main","tagName":"h2"},{"title":"How externalRef Works​","type":1,"pageTitle":"External References","url":"/next/docs/concepts/rgd/resource-definitions/external-references#how-externalref-works","content":" externalRef defines a resource that kro reads but doesn't manage:  kro reads the resource from the cluster and makes its data available to other resourceskro never creates, updates, or deletes the external resourceThe resource must exist for reconciliation to succeed—kro waits for it to be presentExternal resources participate in the dependency graph just like managed resourcesIf namespace is omitted, kro looks for the resource in the instance's namespace  ","version":"main","tagName":"h2"},{"title":"What You Can Reference​","type":1,"pageTitle":"External References","url":"/next/docs/concepts/rgd/resource-definitions/external-references#what-you-can-reference","content":" External references require these fields:  # Required fields - id: myExternal externalRef: apiVersion: v1 # Required: API version kind: ConfigMap # Required: Resource type metadata: name: my-config # Required: Resource name namespace: default # Optional: Defaults to instance namespace   You can reference any Kubernetes resource:  Namespaced resources: ConfigMaps, Secrets, Services (specify namespace or use instance namespace)Cluster-scoped resources: StorageClasses, ClusterIssuers (omit namespace)Custom resources: Any CRD in your cluster  ","version":"main","tagName":"h2"},{"title":"The Optional Operator (?)​","type":1,"pageTitle":"External References","url":"/next/docs/concepts/rgd/resource-definitions/external-references#the-optional-operator-","content":" ConfigMaps and Secrets don't have a predefined schema for their data fields. kro can't validate the structure at build time, so you must use the optional operator ? to safely access their fields:  # ✓ Safe: returns null if platformUrl doesn't exist value: ${config.data.?platformUrl} # ✗ Unsafe: might fail validation at RGD creation time value: ${config.data.platformUrl}   ","version":"main","tagName":"h2"},{"title":"Using orValue() for Defaults​","type":1,"pageTitle":"External References","url":"/next/docs/concepts/rgd/resource-definitions/external-references#using-orvalue-for-defaults","content":" Combine ? with .orValue() to provide defaults when keys don't exist:  env: - name: LOG_LEVEL value: ${config.data.?LOG_LEVEL.orValue(&quot;info&quot;)} - name: MAX_CONNECTIONS value: ${config.data.?MAX_CONNECTIONS.orValue(&quot;100&quot;)}   warning When you use ?, kro cannot validate the field exists at build time. If the ConfigMap doesn't have the expected key, the expression evaluates to null. Document the expected structure and use .orValue() to provide sensible defaults.  ","version":"main","tagName":"h3"},{"title":"Dependencies​","type":1,"pageTitle":"External References","url":"/next/docs/concepts/rgd/resource-definitions/external-references#dependencies","content":" External references participate in the dependency graph just like managed resources. If you reference an external resource's data, kro automatically creates a dependency:  resources: - id: platformConfig externalRef: apiVersion: v1 kind: ConfigMap metadata: name: platform-config - id: database template: spec: region: ${platformConfig.data.?region} - id: app template: spec: env: - name: DB_ENDPOINT value: ${database.status.endpoint}   Dependency chain:  platformConfig (external) → database → app   kro will:  Wait for platformConfig to existCreate database using the config dataWait for database to be readyCreate app  ","version":"main","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"External References","url":"/next/docs/concepts/rgd/resource-definitions/external-references#next-steps","content":" CEL Expressions - Learn more about the ? operatorDependencies &amp; Ordering - Understand how external refs affect dependency graphsReadiness - Use readyWhen with external references ","version":"main","tagName":"h2"},{"title":"Readiness","type":0,"sectionRef":"#","url":"/next/docs/concepts/rgd/resource-definitions/readiness","content":"","keywords":"","version":"main"},{"title":"Basic Example​","type":1,"pageTitle":"Readiness","url":"/next/docs/concepts/rgd/resource-definitions/readiness#basic-example","content":" Here's a simple example where a database must be fully ready before the application deployment is created:  resources: - id: database template: apiVersion: database.example.com/v1 kind: PostgreSQL metadata: name: ${schema.spec.name}-db spec: version: &quot;15&quot; readyWhen: - ${database.status.conditions.exists(c, c.type == &quot;Ready&quot; &amp;&amp; c.status == &quot;True&quot;)} - ${database.status.?endpoint != &quot;&quot;} - id: app template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: template: spec: containers: - name: app image: ${schema.spec.image} env: - name: DATABASE_HOST value: ${database.status.endpoint}   The app deployment won't be created until:  The database resource exists ANDThe database has a Ready condition with status True ANDThe database has an endpoint in its status  This ensures ${database.status.endpoint} has a valid value when the app is created.  ","version":"main","tagName":"h2"},{"title":"How readyWhen Works​","type":1,"pageTitle":"Readiness","url":"/next/docs/concepts/rgd/resource-definitions/readiness#how-readywhen-works","content":" readyWhen is a list of CEL expressions that control when a resource is considered ready:  Without readyWhen: Resources are ready as soon as they exist in the clusterWith readyWhen: Resources are created but remain in a waiting state until all conditions are trueIf all expressions evaluate to true, the resource is marked readyIf any expression evaluates to false, the resource continues waitingEach expression must evaluate to a boolean value (true or false)Dependent resources wait until all their dependencies are ready  ","version":"main","tagName":"h2"},{"title":"What You Can Reference​","type":1,"pageTitle":"Readiness","url":"/next/docs/concepts/rgd/resource-definitions/readiness#what-you-can-reference","content":" readyWhen expressions can only reference the resource itself (by its id):  # ✓ Valid - references the resource itself and returns boolean - id: deployment readyWhen: - ${deployment.status.availableReplicas &gt; 0} - ${deployment.status.conditions.exists(c, c.type == &quot;Available&quot; &amp;&amp; c.status == &quot;True&quot;)}   # ✗ Invalid - cannot reference other resources or schema - id: deployment readyWhen: - ${service.status.loadBalancer.ingress.size() &gt; 0} # Can't reference other resources - ${schema.spec.replicas &gt; 3} # Can't reference schema - ${deployment.status.availableReplicas} # Must return boolean   kro validates readyWhen expressions when you create the ResourceGraphDefinition, ensuring they reference valid fields and return boolean values.  important readyWhen determines when this specific resource is ready. It can't depend on other resources' states—that's handled automatically by the dependency graph when you reference other resources in your templates. This keeps readiness conditions local, deterministic, and easy to debug.  ","version":"main","tagName":"h2"},{"title":"Dependencies and Readiness​","type":1,"pageTitle":"Readiness","url":"/next/docs/concepts/rgd/resource-definitions/readiness#dependencies-and-readiness","content":" When a resource has a readyWhen condition, all resources that depend on it must wait until it's ready.  kro processes resources in the correct order based on references. If a resource references another resource's status field, kro:  Creates the referenced resource firstWaits for its readyWhen conditions (if any) to be satisfiedOnly then creates the dependent resource with the correct status values  This ensures your resources always have valid data and prevents race conditions.  ","version":"main","tagName":"h2"},{"title":"The Optional Operator (?)​","type":1,"pageTitle":"Readiness","url":"/next/docs/concepts/rgd/resource-definitions/readiness#the-optional-operator-","content":" Status fields often don't exist immediately after resource creation. Use the optional operator ? to safely access fields that might be missing:  readyWhen: # ✓ Safe: returns false if endpoint doesn't exist yet - ${database.status.?endpoint != &quot;&quot;} # ✓ Safe: returns false if field is missing - ${service.status.?loadBalancer.?ingress.size() &gt; 0} # ✗ Unsafe: will error if endpoint doesn't exist - ${database.status.endpoint != &quot;&quot;}   The ? operator returns null if the field doesn't exist instead of causing an error. This is essential for checking status fields in readyWhen conditions.  ","version":"main","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Readiness","url":"/next/docs/concepts/rgd/resource-definitions/readiness#next-steps","content":" Dependencies &amp; Ordering - Understand how kro determines resource creation orderConditional Resources - Control whether resources are createdCEL Expressions - Master expression syntax for readiness conditions ","version":"main","tagName":"h2"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/next/docs/overview","content":"","keywords":"","version":"main"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/next/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Figure 1: End user interface - Custom API  ","version":"main","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/next/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RGD). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created an RGD with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for the Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Figure 2: ResourceGraphDefinition (RGD) - Platform Team Interface  ","version":"main","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/next/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Figure 3: ResourceGraphDefinition Instance  Why kro?  ","version":"main","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/next/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"main","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/next/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"main","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/next/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"main","tagName":"h3"},{"title":"CEL Expressions","type":0,"sectionRef":"#","url":"/next/docs/concepts/rgd/cel-expressions","content":"","keywords":"","version":"main"},{"title":"What is CEL?​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#what-is-cel","content":" CEL (Common Expression Language) is an open-source expression language originally created by Google. It's the same language Kubernetes uses for validation rules, admission control, and field selectors.  ","version":"main","tagName":"h2"},{"title":"Why CEL is Safe​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#why-cel-is-safe","content":" CEL was designed specifically to be safe for executing user code. Unlike scripting languages where you'd never blindly execute user-provided code, you can safely execute user-written CEL expressions. This safety comes from:  No side effects: CEL expressions can't modify state, write files, or make network callsGuaranteed termination: No loops or recursion means expressions always completeResource bounded: Expressions are prevented from consuming excessive memory or CPUSandboxed execution: CEL can't access the filesystem or system resources  ","version":"main","tagName":"h3"},{"title":"Why CEL is Fast​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#why-cel-is-fast","content":" CEL is optimized for compile-once, evaluate-many workflows:  Parse and check expressions once at configuration time (when you create an RGD)Store the checked AST (Abstract Syntax Tree)Evaluate the stored AST repeatedly at runtime against different inputs  Because CEL prevents behaviors that would make it slower, expressions evaluate in nanoseconds to microseconds—making it ideal for performance-critical reconciliation loops.  ","version":"main","tagName":"h3"},{"title":"CEL's Design Principles​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#cels-design-principles","content":" Safe: Designed for executing untrusted user codeFast: Evaluates in microsecondsType-safe: Types are checked before executionSimple: Easy-to-read syntax similar to JavaScript/GoPortable: Platform-independent expression language  kro uses CEL throughout ResourceGraphDefinitions to make them dynamic and interconnected while maintaining safety and performance.  Learn more: CEL Overview | CEL Language Specification | CEL Go Documentation  ","version":"main","tagName":"h3"},{"title":"CEL Syntax in kro​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#cel-syntax-in-kro","content":" ","version":"main","tagName":"h2"},{"title":"Expression Delimiters​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#expression-delimiters","content":" In kro, CEL expressions are wrapped in ${ and }:  metadata: name: ${schema.spec.appName}   Everything between ${ and } is a CEL expression that gets evaluated at runtime.  ","version":"main","tagName":"h3"},{"title":"Two Types of Expressions​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#two-types-of-expressions","content":" 1. Standalone Expressions​  A standalone expression is a field whose value is exactly one expression - nothing else:  spec: replicas: ${schema.spec.replicaCount}   The expression result replaces the entire field value. The result type must match the field's expected type:  If the field expects an integer, the expression must return an integerIf the field expects an object, the expression must return an objectetc.  Examples:  # Integer field replicas: ${schema.spec.count} # String field image: ${schema.spec.containerImage} # Boolean field enabled: ${schema.spec.featureEnabled} # Object field env: ${configmap.data} # Array field volumes: ${schema.spec.volumeMounts}   2. String Templates​  A string template contains one or more expressions embedded in a string:  metadata: name: &quot;${schema.spec.prefix}-${schema.spec.name}&quot;   All expressions in a string template must return strings, and the result is always a string (concatenation of all parts).  Examples:  # Simple concatenation name: &quot;app-${schema.spec.name}&quot; # Multiple expressions connectionString: &quot;host=${database.status.endpoint}:${database.status.port}&quot; # With literal text message: &quot;Application ${schema.spec.name} is running version ${schema.spec.version}&quot;   warning Expressions in string templates must return strings. This won't work: name: &quot;app-${schema.spec.replicas}&quot; # Error: replicas is an integer Use .string() or format() to convert: name: &quot;app-${schema.spec.replicas.string()}&quot;   ","version":"main","tagName":"h3"},{"title":"Referencing Data​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#referencing-data","content":" ","version":"main","tagName":"h2"},{"title":"The schema Variable​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#the-schema-variable","content":" The schema variable represents the instance spec - the values users provide when creating an instance of your API.  Instance:  apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-app spec: appName: awesome-app replicas: 3   In your RGD, access via schema.spec:  resources: - id: deployment template: metadata: name: ${schema.spec.appName} # &quot;awesome-app&quot; spec: replicas: ${schema.spec.replicas} # 3   ","version":"main","tagName":"h3"},{"title":"Resource Variables​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#resource-variables","content":" Each resource in your RGD can be referenced by its id:  resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment # ... deployment spec - id: service template: apiVersion: v1 kind: Service spec: selector: # Reference the deployment's labels app: ${deployment.spec.template.metadata.labels.app}   This automatically creates a dependency: the service depends on the deployment. kro will create the deployment first. See Dependencies &amp; Ordering for details.  ","version":"main","tagName":"h3"},{"title":"Field Paths​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#field-paths","content":" Use dot notation to navigate nested fields:  # Access nested objects ${deployment.spec.template.spec.containers[0].image} # Access map values ${configmap.data.DATABASE_URL} # Access status fields ${deployment.status.availableReplicas}   ","version":"main","tagName":"h3"},{"title":"Array Indexing​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#array-indexing","content":" Access array elements using [index]:  # First container's image ${deployment.spec.template.spec.containers[0].image} # Second port ${service.spec.ports[1].port}   ","version":"main","tagName":"h3"},{"title":"The Optional Operator (?)​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#the-optional-operator-","content":" The ? operator makes a field access optional. If the field doesn't exist, the expression returns null instead of failing.  ","version":"main","tagName":"h2"},{"title":"When to Use ?​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#when-to-use-","content":" Use the optional operator when:  Referencing schema-less objects (ConfigMaps, Secrets without known structure)Accessing fields that might not exist (optional status fields)Working with dynamic data where structure isn't guaranteed  ","version":"main","tagName":"h3"},{"title":"Syntax​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#syntax","content":" Place ? before the field that might not exist:  ${configmap.data.?DATABASE_URL}   If data.DATABASE_URL doesn't exist, this returns null instead of erroring.  ","version":"main","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#examples","content":" Referencing a ConfigMap:  resources: - id: config externalRef: apiVersion: v1 kind: ConfigMap metadata: name: app-config - id: deployment template: spec: containers: - env: - name: DATABASE_URL # ConfigMap might not have this key value: ${config.data.?DATABASE_URL}   Optional status fields:  # Some resources might not have this status field immediately ready: ${deployment.status.?readyReplicas &gt; 0}   Chaining optional accessors:  # Multiple fields might not exist ${service.status.?loadBalancer.?ingress[0].?hostname}   warning The ? operator prevents kro from validating the field's existence at build time. Use it sparingly - prefer explicit schemas when possible.  ","version":"main","tagName":"h3"},{"title":"Available CEL Libraries​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#available-cel-libraries","content":" Library\tDocumentationLists\tcel-go/ext Strings\tcel-go/ext Encoders\tcel-go/ext Random\tkro custom  For the complete CEL language reference, see the CEL language definitions.  ","version":"main","tagName":"h2"},{"title":"Type Checking and Validation​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#type-checking-and-validation","content":" One of kro's key features is compile-time type checking of CEL expressions.  ","version":"main","tagName":"h2"},{"title":"How Type Checking Works​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#how-type-checking-works","content":" When you create an RGD, kro:  Fetches the OpenAPI schema for each resource type from the API serverValidates that every field path in your expressions existsChecks that expression output types match target field typesReports errors before any instances are created  Example:  spec: replicas: ${schema.spec.appName} # Error: appName is string, replicas expects integer   kro will reject this RGD with a clear error message.  ","version":"main","tagName":"h3"},{"title":"Type Compatibility​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#type-compatibility","content":" kro checks two forms of compatibility:  1. Exact Type Match​  # ✓ Correct: integer to integer replicas: ${schema.spec.replicaCount} # ✗ Wrong: string to integer replicas: ${schema.spec.appName}   2. Structural Compatibility (Duck Typing)​  kro supports structural compatibility for complex types through deep type inspection:  Map ↔ Struct compatibility:  # Map can be assigned to struct # Map keys must be strings matching struct field names # Map values must be compatible with corresponding field types labels: ${schema.spec.labelMap} # Struct can be assigned to map # Struct field names become string keys # Struct field types must be compatible with map value type annotations: ${deployment.metadata.labels}   Struct subset semantics:  # Output struct can have FEWER fields than expected (subset) # But cannot have EXTRA fields that expected doesn't have # Each field that exists must have compatible type   List and Map recursive checking:  Lists: Element types must be structurally compatibleMaps: Both key and value types must be structurally compatibleRecursively validated for nested structures  ","version":"main","tagName":"h3"},{"title":"Working with Dynamic Types​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#working-with-dynamic-types","content":" For resources with x-kubernetes-preserve-unknown-fields: true (like ConfigMap data), kro can't validate structure. Use the ? operator:  # kro can't validate ConfigMap.data structure value: ${configmap.data.?myKey}   ","version":"main","tagName":"h3"},{"title":"Common Patterns​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#common-patterns","content":" ","version":"main","tagName":"h2"},{"title":"Conditional Values​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#conditional-values","content":" Use ternary operator for conditional values:  # If-then-else image: ${schema.spec.env == &quot;prod&quot; ? &quot;nginx:stable&quot; : &quot;nginx:latest&quot;} # With optional replicas: ${schema.spec.?replicas.orValue(3)}   ","version":"main","tagName":"h3"},{"title":"Building Complex Objects​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#building-complex-objects","content":" Create objects inline:  env: - name: DATABASE_URL value: ${database.status.endpoint} - name: DATABASE_PORT value: ${database.status.port.string()}   Or use CEL to construct them:  labels: ${{&quot;app&quot;: schema.spec.name, &quot;env&quot;: schema.spec.environment}}   ","version":"main","tagName":"h3"},{"title":"String Formatting​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#string-formatting","content":" Build connection strings and URLs:  # Connection string connectionString: &quot;postgresql://${db.status.endpoint}:${db.status.port}/${schema.spec.dbName}&quot; # ARN format roleArn: &quot;arn:aws:iam::%s:role/%s&quot;.format([schema.spec.accountId, schema.spec.roleName])   ","version":"main","tagName":"h3"},{"title":"Working with Lists​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#working-with-lists","content":" Filter, map, and transform lists:  # Extract specific fields containerNames: ${deployment.spec.template.spec.containers.map(c, c.name)} # Filter by condition readyConditions: ${deployment.status.conditions.filter(c, c.status == &quot;True&quot;)} # Check all items allReady: ${schema.spec.services.all(s, s.enabled)}   ","version":"main","tagName":"h3"},{"title":"Aggregating Status​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#aggregating-status","content":" Collect status from multiple resources:  status: # From single resource endpoint: ${service.status.loadBalancer.ingress[0].hostname} # Computed from multiple allReady: ${deployment.status.availableReplicas == schema.spec.replicas &amp;&amp; service.status.loadBalancer.ingress.size() &gt; 0} # Complex aggregation totalPods: ${deployment.status.replicas + statefulset.status.replicas}   ","version":"main","tagName":"h3"},{"title":"Troubleshooting CEL Errors​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#troubleshooting-cel-errors","content":" ","version":"main","tagName":"h2"},{"title":"Common Errors​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#common-errors","content":" &quot;undeclared reference to 'X'&quot;​  The resource or field doesn't exist in the dependency graph.  Fix: Check the resource id or field path is correct.  &quot;expected type 'X' but found 'Y'&quot;​  Expression output type doesn't match the target field type.  Fix: Convert the type or fix the expression:  # Wrong replicas: ${schema.spec.count} # count is string # Right replicas: ${schema.spec.count.int()}   &quot;no such key: X&quot;​  Accessing a map key that doesn't exist.  Fix: Use the optional operator:  value: ${configmap.data.?KEY.orValue(&quot;default&quot;)}   &quot;index out of bounds&quot;​  Accessing an array index that doesn't exist.  Fix: Check array size first:  value: ${list.size() &gt; 0 ? list[0] : &quot;default&quot;}   ","version":"main","tagName":"h3"},{"title":"Debugging Tips​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#debugging-tips","content":" Start simple: Test expressions with literal values firstCheck schemas: Use kubectl explain to verify field paths existUse ? judiciously: Start without it, add only when neededRead error messages: kro's type checker provides detailed error messagesTest incrementally: Add one expression at a time  ","version":"main","tagName":"h3"},{"title":"Next Steps​","type":1,"pageTitle":"CEL Expressions","url":"/next/docs/concepts/rgd/cel-expressions#next-steps","content":" Dependencies &amp; Ordering - Learn how CEL expressions create dependenciesConditional Creation - Use CEL for includeWhen conditionsReadiness - Use CEL for readyWhen conditionsExternal References - Reference external resources with CEL ","version":"main","tagName":"h2"},{"title":"Graph Inference","type":0,"sectionRef":"#","url":"/next/docs/concepts/rgd/dependencies-ordering","content":"","keywords":"","version":"main"},{"title":"How It Works​","type":1,"pageTitle":"Graph Inference","url":"/next/docs/concepts/rgd/dependencies-ordering#how-it-works","content":" When you reference one resource from another using a CEL expression, you create a dependency:  resources: - id: configmap template: apiVersion: v1 kind: ConfigMap metadata: name: app-config data: DATABASE_URL: ${schema.spec.dbUrl} - id: deployment template: apiVersion: apps/v1 kind: Deployment spec: containers: - env: - name: DATABASE_URL value: ${configmap.data.DATABASE_URL}   The expression ${configmap.data.DATABASE_URL} creates a dependency: deployment depends on configmap. kro will create the configmap first, wait for the expression to be resolvable, then create the deployment.  ","version":"main","tagName":"h2"},{"title":"Dependency Graph (DAG)​","type":1,"pageTitle":"Graph Inference","url":"/next/docs/concepts/rgd/dependencies-ordering#dependency-graph-dag","content":" kro builds a Directed Acyclic Graph (DAG) where:  Nodes are resourcesEdges are dependenciesDirected means dependencies have direction (A depends on B)Acyclic means no circular dependencies  Simple chain:  schema → configmap → deployment → service → ingress   Multiple dependencies:   schema ↓ ┌─────┴─────┐ ↓ ↓ database cache └─────┬─────┘ ↓ app   ","version":"main","tagName":"h2"},{"title":"Topological Order​","type":1,"pageTitle":"Graph Inference","url":"/next/docs/concepts/rgd/dependencies-ordering#topological-order","content":" kro computes a topological order - the sequence resources can be processed such that all dependencies are satisfied.  Creation: Resources created in topological orderDeletion: Resources deleted in reverse order  View the computed order:  kubectl get rgd my-app -o jsonpath='{.status.topologicalOrder}'   Example output:  status: topologicalOrder: - configmap - deployment - service   ","version":"main","tagName":"h2"},{"title":"Circular Dependencies​","type":1,"pageTitle":"Graph Inference","url":"/next/docs/concepts/rgd/dependencies-ordering#circular-dependencies","content":" Circular dependencies are not allowed and will cause validation to fail:  # ✗ This will fail resources: - id: serviceA template: spec: targetPort: ${serviceB.spec.port} # A → B - id: serviceB template: spec: targetPort: ${serviceA.spec.port} # B → A (circular!)   Fix: Break the cycle by using schema.spec instead:  resources: - id: serviceA template: spec: targetPort: ${schema.spec.portA} # Use schema - id: serviceB template: spec: targetPort: ${serviceA.spec.port} # This is fine   ","version":"main","tagName":"h2"},{"title":"What Happens at Runtime​","type":1,"pageTitle":"Graph Inference","url":"/next/docs/concepts/rgd/dependencies-ordering#what-happens-at-runtime","content":" When kro reconciles an instance:  Evaluate static expressions - Expressions referencing only schema.spec are evaluated onceProcess in topological order - For each resource: Wait for all dependency expressions to be resolvableCreate or update the resourceMove to next resource in order Delete in reverse order - During deletion, process resources backwards  kro waits for CEL expressions to be resolvable before proceeding. This means the referenced resource exists and has the field being accessed.  ","version":"main","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Graph Inference","url":"/next/docs/concepts/rgd/dependencies-ordering#next-steps","content":" Readiness - Control when resources are considered ready with readyWhenCEL Expressions - Learn more about writing expressionsResource Basics - Learn about resource templates ","version":"main","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/next/examples/","content":"","keywords":"","version":"main"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/next/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"main","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/next/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"main","tagName":"h2"},{"title":"Schema Definition","type":0,"sectionRef":"#","url":"/next/docs/concepts/rgd/schema","content":"","keywords":"","version":"main"},{"title":"What the Schema Defines​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#what-the-schema-defines","content":" The schema section specifies:  API identification: The apiVersion, kind, and optionally group for your custom resourceSpec fields: What inputs users provide when creating instancesStatus fields: What runtime information kro surfaces from managed resourcesCustom types: Reusable type definitions for complex schemasAdditional printer columns: Custom columns for kubectl get output  ","version":"main","tagName":"h2"},{"title":"Basic Structure​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#basic-structure","content":" apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: application spec: schema: apiVersion: v1alpha1 # Your API version kind: Application # Your custom resource kind spec: # User-provided fields name: string replicas: integer image: string status: # Runtime fields from resources availableReplicas: ${deployment.status.availableReplicas} endpoint: ${service.status.loadBalancer.ingress[0].hostname}   ","version":"main","tagName":"h2"},{"title":"API Identification​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#api-identification","content":" ","version":"main","tagName":"h2"},{"title":"Group​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#group","content":" The group field sets the API group for your generated CRD. If omitted, it defaults to kro.run.  schema: apiVersion: v1alpha1 kind: Application group: mycompany.io # Creates applications.mycompany.io CRD   This allows you to organize your custom APIs under your own domain, making the full API mycompany.io/v1alpha1.  ","version":"main","tagName":"h3"},{"title":"The spec Section​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#the-spec-section","content":" The spec section defines what users can configure when they create an instance of your API. These are the input fields that control resource behavior.  ","version":"main","tagName":"h2"},{"title":"Defining Spec Fields​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#defining-spec-fields","content":" kro uses SimpleSchema syntax for defining types:  spec: # Basic types with validation name: string | required=true replicas: integer | default=3 minimum=1 maximum=100 enabled: boolean | default=false # Structured types ingress: enabled: boolean | default=false host: string | default=&quot;example.com&quot; path: string | default=&quot;/&quot; # Collections env: &quot;map[string]string&quot; ports: &quot;[]integer&quot;   Common validation markers:  required=true - Field must be provideddefault=value - Default value if omittedminimum=n / maximum=n - Numeric constraintsenum=&quot;val1,val2&quot; - Allowed valuespattern=&quot;regex&quot; - String pattern validationdescription=&quot;...&quot; - Field documentation  See SimpleSchema for complete syntax reference.  ","version":"main","tagName":"h3"},{"title":"The status Section​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#the-status-section","content":" The status section defines what runtime information kro exposes from your managed resources. Status fields use CEL expressions to reference values from the resources in your graph.  ","version":"main","tagName":"h2"},{"title":"Status Fields with CEL Expressions​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#status-fields-with-cel-expressions","content":" resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment # ... deployment spec ... - id: service template: apiVersion: v1 kind: Service # ... service spec ... schema: status: # Reference resource fields directly availableReplicas: ${deployment.status.availableReplicas} # Extract nested values serviceIP: ${service.spec.clusterIP} # Construct composite values endpoint: &quot;http://${service.status.loadBalancer.ingress[0].hostname}&quot;   kro automatically:  Infers proper types from CEL expressions by inspecting what the expression returns (integers, strings, objects, arrays, etc.)Validates expressions when you create the RGD (not at runtime)Type-checks expressions against actual Kubernetes schemasUpdates values whenever the underlying resources change  This means status fields have strongly-typed schemas in the generated CRD, not arbitrary objects. If a CEL expression returns an integer, the status field will be typed as an integer in the CRD.  ","version":"main","tagName":"h3"},{"title":"Structured Status Fields​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#structured-status-fields","content":" Status fields can be scalar values, structured objects, or arrays:  status: # Scalar values replicas: ${deployment.status.replicas} # Structured objects connection: host: ${service.spec.clusterIP} port: ${service.spec.ports[0].port} protocol: &quot;TCP&quot; # Arrays endpoints: - ${service.status.loadBalancer.ingress[0].hostname} - ${service.status.loadBalancer.ingress[1].hostname} # Nested structures deployment: metadata: name: ${deployment.metadata.name} namespace: ${deployment.metadata.namespace} status: ready: ${deployment.status.readyReplicas} total: ${deployment.status.replicas}   ","version":"main","tagName":"h3"},{"title":"Using CEL Functions in Status​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#using-cel-functions-in-status","content":" Status fields support the full power of CEL expressions, including built-in functions:  status: # Type conversions replicasAsString: ${string(deployment.status.replicas)} # Filtering arrays readyPods: ${deployment.status.conditions.filter(c, c.type == &quot;Ready&quot;)} # Mapping arrays podNames: ${pods.items.map(p, p.metadata.name)} # Conditional logic isHealthy: ${deployment.status.availableReplicas &gt;= deployment.spec.replicas} # Complex expressions healthStatus: ${deployment.status.availableReplicas &gt;= deployment.spec.replicas ? &quot;healthy&quot; : &quot;degraded&quot;} # Combining multiple operations activePodCount: ${pods.items.filter(p, p.status.phase == &quot;Running&quot;).size()}   ","version":"main","tagName":"h3"},{"title":"String Templating in Status​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#string-templating-in-status","content":" Status fields can use multiple CEL expressions for string construction:  status: # Single expression - can be any type replicas: ${deployment.status.replicas} # integer # Multiple expressions - must all be strings connectionString: &quot;postgresql://${secret.data.username}:${secret.data.password}@${service.spec.clusterIP}:5432&quot;   ","version":"main","tagName":"h3"},{"title":"Built-in Status Fields​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#built-in-status-fields","content":" kro automatically adds two fields to every instance status:  conditions: An array tracking the instance state  status: conditions: - type: Ready # Overall readiness status: &quot;True&quot; lastTransitionTime: &quot;...&quot; reason: &quot;...&quot; message: &quot;...&quot;   state: A high-level summary  status: state: ACTIVE # ACTIVE | IN_PROGRESS | FAILED | DELETING | ERROR   warning conditions and state are reserved fields. kro will override them if you define them in your schema.  ","version":"main","tagName":"h3"},{"title":"How kro Uses the Schema​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#how-kro-uses-the-schema","content":" ","version":"main","tagName":"h2"},{"title":"1. CRD Generation​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#1-crd-generation","content":" When you create an RGD, kro converts your SimpleSchema into an OpenAPI v3 schema and generates a CRD:  # Your RGD schema schema: apiVersion: v1alpha1 kind: Application spec: name: string | required=true   kro generates:  apiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: name: applications.v1alpha1 spec: versions: - name: v1alpha1 schema: openAPIV3Schema: properties: spec: properties: name: type: string required: [name]   ","version":"main","tagName":"h3"},{"title":"2. Instance Validation​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#2-instance-validation","content":" When users create instances, Kubernetes validates them against the generated CRD schema before kro processes them. This means:  Invalid instances are rejected immediatelyType mismatches are caught at admission timeRequired fields are enforced by Kubernetes itself  ","version":"main","tagName":"h3"},{"title":"3. Status Updates​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#3-status-updates","content":" kro continuously evaluates status expressions and updates instance status as resources change. If a deployment's replica count changes, the corresponding status field updates automatically.  ","version":"main","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#custom-types","content":" For complex schemas, you can define reusable custom types:  schema: types: ContainerConfig: image: string | required=true tag: string | default=&quot;latest&quot; env: &quot;map[string]string&quot; spec: primary: ContainerConfig sidecars: &quot;[]ContainerConfig&quot;   Custom types are expanded inline when kro generates the CRD.  ","version":"main","tagName":"h2"},{"title":"Additional Printer Columns​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#additional-printer-columns","content":" Control what kubectl get displays:  schema: spec: name: string replicas: integer status: availableReplicas: ${deployment.status.availableReplicas} additionalPrinterColumns: - name: Replicas type: integer jsonPath: .spec.replicas - name: Available type: integer jsonPath: .status.availableReplicas - name: Age type: date jsonPath: .metadata.creationTimestamp   This produces:  $ kubectl get applications NAME REPLICAS AVAILABLE AGE my-app 5 5 10m   ","version":"main","tagName":"h2"},{"title":"Complete Example​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#complete-example","content":" apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: web-application spec: schema: apiVersion: v1alpha1 kind: WebApplication spec: # Basic configuration name: string | required=true replicas: integer | default=3 minimum=1 image: string | required=true # Structured configuration ingress: enabled: boolean | default=false host: string path: string | default=&quot;/&quot; # Collections env: &quot;map[string]string&quot; ports: &quot;[]integer&quot; | default=[80] status: # Resource state availableReplicas: ${deployment.status.availableReplicas} serviceIP: ${service.spec.clusterIP} # Conditional fields (only present if ingress enabled) ingressHost: ${ingress.spec.rules[0].host} additionalPrinterColumns: - name: Replicas type: integer jsonPath: .spec.replicas - name: Available type: integer jsonPath: .status.availableReplicas - name: Image type: string jsonPath: .spec.image resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment # ... deployment configuration using ${schema.spec.*} ... - id: service template: apiVersion: v1 kind: Service # ... service configuration ... - id: ingress includeWhen: - ${schema.spec.ingress.enabled} template: apiVersion: networking.k8s.io/v1 kind: Ingress # ... ingress configuration ...   ","version":"main","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Schema Definition","url":"/next/docs/concepts/rgd/schema#next-steps","content":" SimpleSchema Reference - Complete syntax and validation rulesResource Definitions - Learn how to use schema values in resource templatesCEL Expressions - Master expression syntax for status fields ","version":"main","tagName":"h2"},{"title":"Basics","type":0,"sectionRef":"#","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics","content":"","keywords":"","version":"main"},{"title":"Resource Structure​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#resource-structure","content":" Every resource in an RGD requires an id and a template:  resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: my-app spec: replicas: 3 # ... rest of deployment spec ... - id: service template: apiVersion: v1 kind: Service metadata: name: my-app spec: # ... rest of service spec ...   Each template must be a valid Kubernetes resource with:  apiVersion - The API version (e.g., apps/v1, v1)kind - The resource type (e.g., Deployment, Service)metadata - At minimum, metadata fields like name  The id uniquely identifies the resource within your RGD and is used to reference it in other resources.  ID Naming Requirements Resource IDs must be in lowerCamelCase format because they're used as identifiers in CEL expressions. Dashes are not allowed, as they would be interpreted as subtraction operators in CEL. Valid IDs: deploymentwebServerpostgresDatabase Invalid IDs: web-server (dash would be treated as subtraction)WebServer (should start with lowercase)postgres_database (underscores discouraged, use camelCase)  ","version":"main","tagName":"h2"},{"title":"Resource Templates with CEL​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#resource-templates-with-cel","content":" Resource templates are structured Kubernetes manifests where specific fields contain CEL expressions that reference your schema or other resources:  resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: ${schema.spec.replicas} selector: matchLabels: app: ${schema.spec.name}   Unlike text-based templating, kro maintains valid YAML structure throughout. The CEL expressions ${...} are embedded directly in field values and are type-checked against actual Kubernetes schemas when you create the ResourceGraphDefinition.  important When you create a ResourceGraphDefinition, kro validates every template and CEL expression before your API even exists. It parses each template as a real Kubernetes manifest, extracts all CEL expressions, validates the CEL syntax, and type-checks expressions against actual Kubernetes OpenAPI schemas. This means errors are caught when you create the RGD, not when users try to deploy resources.  ","version":"main","tagName":"h2"},{"title":"What You Can Reference​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#what-you-can-reference","content":" CEL expressions in resource templates can reference three things:  schema.spec - User-provided configuration fields from the instanceschema.metadata - Instance metadata (name, namespace, labels, annotations)Other resources - Any field from other resources in your RGD, including their spec, metadata, and status  important When you reference another resource in a CEL expression, it automatically creates a dependency. This is an implicit way of declaring that one resource depends on another. kro uses these references to determine the correct creation order—ensuring the referenced resource exists before the one referencing it. Learn more about Dependencies and Ordering.  ","version":"main","tagName":"h2"},{"title":"Reference Examples​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#reference-examples","content":" Here's a simple example showing all types of references:  resources: - id: database template: apiVersion: database.example.com/v1 kind: PostgreSQL metadata: # Reference instance spec name: ${schema.spec.name}-db # Reference instance metadata namespace: ${schema.metadata.namespace} labels: ${schema.metadata.labels} spec: version: &quot;15&quot; storage: ${schema.spec.storageSize} replicas: 2 - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} namespace: ${schema.metadata.namespace} # Reference another resource's metadata annotations: ${database.metadata.annotations} spec: replicas: ${schema.spec.replicas} selector: matchLabels: app: ${schema.spec.name} template: spec: containers: - name: app image: ${schema.spec.image} env: # Reference another resource's status - name: DATABASE_HOST value: ${database.status.endpoint} # Reference another resource's spec - name: DATABASE_VERSION value: ${database.spec.version}   In this example:  database references schema.spec (name, storageSize) and schema.metadata (namespace, labels)deployment references schema.spec (name, replicas, image), schema.metadata.namespace, database.metadata.annotations, database.spec.version, and database.status.endpoint  important kro automatically determines that database must be created before deployment. The deployment waits for the database's status to be available before using the connection endpoint. Learn more about Dependencies and Ordering.  ","version":"main","tagName":"h2"},{"title":"CEL Property Verification​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#cel-property-verification","content":" kro performs extensive validation and type checking on CEL expressions before any instances are created.  ","version":"main","tagName":"h2"},{"title":"What kro Validates​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#what-kro-validates","content":" When you create a ResourceGraphDefinition, kro validates every CEL expression:  Template SyntaxCEL Expression SyntaxType CheckingField ExistenceSchema ValidationStatic Fields kro looks for ${ and expects to find a matching }. # ✓ Valid - kro finds ${ and matching } name: ${schema.spec.name} # ✓ Valid - no ${, treated as literal string name: &quot;my-app&quot; # ✗ Error - ${ found but missing closing } name: ${schema.spec.name # ✗ Error - nested expressions not allowed command: ${outer(${inner})} # ✓ Valid - nested ${} inside string literals is allowed command: ${outer(&quot;${inner}&quot;)}   For more details, see Static Type Checking.  ","version":"main","tagName":"h3"},{"title":"How kro Processes Templates​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#how-kro-processes-templates","content":" kro processes templates in several distinct phases:  ","version":"main","tagName":"h2"},{"title":"1. Validation Phase (RGD Creation)​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#1-validation-phase-rgd-creation","content":" When you create a ResourceGraphDefinition, kro parses all resource templates as Kubernetes manifests and extracts all CEL expressions from template fields. It validates CEL syntax, fetches actual Kubernetes OpenAPI schemas for referenced resource types, and type-checks expressions against real schemas. kro then verifies field existence in target resources, builds the dependency graph from expression references, and computes the topological order.  All of this happens before any instances exist. If validation fails, the RGD is rejected.  ","version":"main","tagName":"h3"},{"title":"2. Evaluation Phase (Instance Creation)​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#2-evaluation-phase-instance-creation","content":" When a user creates an instance, kro immediately evaluates expressions referencing schema.spec and processes resources in topological order (see Dependencies and Ordering). For each resource, kro waits for all dependency expressions to be resolvable, evaluates all CEL expressions in the template, substitutes evaluated values into the resource, and creates or updates the resource in Kubernetes. Throughout this process, kro tracks resource status and readiness.  ","version":"main","tagName":"h3"},{"title":"3. Update Phase (Instance Updates)​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#3-update-phase-instance-updates","content":" When an instance is updated, kro re-evaluates expressions with new instance values, determines which resources need updates, and updates them in topological order while preserving dependency relationships.  ","version":"main","tagName":"h3"},{"title":"Type Safety Examples​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#type-safety-examples","content":" Integer FieldsString FieldsObject/Map FieldsArray/List Fields # Deployment requires integer for replicas resources: - id: deployment template: spec: # ✓ Valid: integer expression replicas: ${schema.spec.replicas} # ✓ Valid: integer arithmetic replicas: ${schema.spec.replicas * 2} # ✗ Type error: string value for integer field replicas: ${schema.spec.name}   For more details, see Static Type Checking.  ","version":"main","tagName":"h2"},{"title":"Validation Errors​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#validation-errors","content":" When kro detects validation errors, the RGD is rejected with detailed error messages:  ","version":"main","tagName":"h2"},{"title":"Example: Type Mismatch​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#example-type-mismatch","content":" # RGD with type error resources: - id: deployment template: spec: replicas: ${schema.spec.name} # name is string, replicas needs integer   Error:  ResourceGraphDefinition validation failed: - Resource 'deployment' field 'spec.replicas': type mismatch: expected integer, got string   ","version":"main","tagName":"h3"},{"title":"Example: Missing Field​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#example-missing-field","content":" # RGD referencing non-existent field resources: - id: service template: spec: port: ${deployment.spec.nonExistentField}   Error:  ResourceGraphDefinition validation failed: - Resource 'service' expression '${deployment.spec.nonExistentField}': field 'nonExistentField' does not exist in Deployment spec   For more information about validation errors and type checking, see Static Type Checking.  ","version":"main","tagName":"h3"},{"title":"Next Steps​","type":1,"pageTitle":"Basics","url":"/next/docs/concepts/rgd/resource-definitions/resource-basics#next-steps","content":" CEL Expressions - Master CEL syntax and functionsDependencies &amp; Ordering - How templates create dependenciesSimpleSchema - Define your API schema ","version":"main","tagName":"h2"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/0.6.2/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.6.2"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/0.6.2/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.6.2","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/0.6.2/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.6.2","tagName":"h2"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/next/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"main"},{"title":"What is a ResourceGraphDefinition (RGD)?​","type":1,"pageTitle":"Quick Start","url":"/next/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition-rgd","content":" A ResourceGraphDefinition (RGD) lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we'll create an RGD that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create an RGD, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"main","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Quick Start","url":"/next/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"main","tagName":"h2"},{"title":"Create your Application RGD​","type":1,"pageTitle":"Quick Start","url":"/next/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-rgd","content":" Let's create an RGD that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: ${schema.spec.replicas} # Use the replicas provided by user selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-svc spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"main","tagName":"h2"},{"title":"Deploy the RGD​","type":1,"pageTitle":"Quick Start","url":"/next/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-rgd","content":" Create an RGD manifest file: Create a new file with the RGD definition. You can use the example above. Apply the RGD: Use the kubectl command to deploy the RGD to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inspect the RGD: Check the status of the RGD using the kubectl command: kubectl get rgd my-application -owide You should see the RGD in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"main","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Quick Start","url":"/next/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your RGD is created, kro has generated a new API (Application) that orchestrates the creation of a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: v1alpha1 kind: Application metadata: name: my-app-instance spec: name: my-app replicas: 1 ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE READY AGE my-app-instance Active True 10s When you create an instance, kro automatically creates and manages all the underlying resources: Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. Note the deployment has 1 replica as specified: NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-app 1/1 1 1 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-app-svc ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-app-ingress &lt;none&gt; * 80 62s   ","version":"main","tagName":"h3"},{"title":"Experiment with kro​","type":1,"pageTitle":"Quick Start","url":"/next/docs/getting-started/deploy-a-resource-graph-definition#experiment-with-kro","content":" kro continuously reconciles your resources. Try these experiments:  Change the replica count:  Edit instance.yaml to increase replicas to 3: instance.yaml apiVersion: v1alpha1 kind: Application metadata: name: my-app-instance spec: name: my-app replicas: 3 ingress: enabled: true Apply the change: kubectl apply -f instance.yaml Watch the deployment scale up: kubectl get deployment my-app   See kro's automatic reconciliation:  Delete the service: kubectl delete service my-app-svc Watch kro recreate it automatically: kubectl get service my-app-svc -w kro is watching and will instantly recreate the service to match your RGD definition.  ","version":"main","tagName":"h3"},{"title":"Clean Up​","type":1,"pageTitle":"Quick Start","url":"/next/docs/getting-started/deploy-a-resource-graph-definition#clean-up","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-app-instance Now, the resources created by the Application instance will be deleted. ","version":"main","tagName":"h3"},{"title":"Static Analysis","type":0,"sectionRef":"#","url":"/next/docs/concepts/rgd/static-type-checking","content":"","keywords":"","version":"main"},{"title":"The Validation Process​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#the-validation-process","content":" When you create or update a ResourceGraphDefinition, kro performs validation in multiple stages:    ","version":"main","tagName":"h2"},{"title":"Stage 1: Schema Validation​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#stage-1-schema-validation","content":" kro starts by validating your custom API schema:  Parses your SimpleSchema definition - Reads the schema from spec.schemaConverts to OpenAPI schema - Transforms SimpleSchema to standard OpenAPI formatValidates the CRD spec - Ensures the generated CRD specification is valid  spec: schema: spec: # kro validates this schema definition replicas: integer | default=3 ports: array labels: object   ","version":"main","tagName":"h3"},{"title":"Stage 2: Status Schema Inference​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#stage-2-status-schema-inference","content":" For your custom API's status field, kro automatically infers the schema from CEL expressions:  status: endpoint: ${service.status.loadBalancer.ingress[0].hostname} replicas: ${deployment.status.availableReplicas}   kro inspects these expressions, determines their output types, and generates the OpenAPI schema for your status field automatically. This means you don't need to manually define status field types—kro figures them out from your CEL expressions.  ","version":"main","tagName":"h3"},{"title":"Stage 3: Resource Naming Validation​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#stage-3-resource-naming-validation","content":" kro validates that all resource IDs are valid CEL identifiers. Resource IDs must be valid variable names in CEL—no hyphens, special characters, or starting with numbers.  Why? CEL uses resource IDs as variables (like ${deployment.spec.replicas}). Invalid identifiers would cause CEL syntax errors.  # ✓ Valid IDs resources: - id: deployment - id: configMap - id: servicePrimary # ✗ Invalid IDs resources: - id: my-deployment # Hyphens not allowed (CEL subtraction operator) - id: 1st-service # Can't start with number   ","version":"main","tagName":"h3"},{"title":"Stage 4: Resource Template Validation​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#stage-4-resource-template-validation","content":" For each resource template, kro:  Validates basic Kubernetes object structure - Ensures the template has required fields like apiVersion, kind, and metadataResolves the OpenAPI schema - Gets the schema from the API server for the resource type. This works for both built-in Kubernetes resources (like Deployments and Services) and Custom Resource Definitions installed in your cluster.Extracts CEL expressions and determines expected types - For each field in the template: If the field contains a CEL expression: kro extracts the expression and determines what type the target field expects based on the OpenAPI schemaIf the field is a literal value: kro performs standard OpenAPI validation, just like the kube-api-server does  resources: - id: deployment template: apiVersion: apps/v1 # kro fetches Deployment schema kind: Deployment # ... validates template against Deployment schema   ","version":"main","tagName":"h3"},{"title":"Stage 5: AST Analysis and Dependency Graph Building​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#stage-5-ast-analysis-and-dependency-graph-building","content":" kro analyzes the Abstract Syntax Tree (AST) of all CEL expressions to understand how they reference each other:  Parses CEL expressions into ASTs - Converts each expression into its abstract syntax tree representationAnalyzes references - Identifies what each expression references (schema fields, other resources, functions)Validates references - Checks that referenced resources exist in the DAG and functions are declaredBuilds the dependency graph - Creates a directed acyclic graph showing which resources depend on whichDetects circular dependencies - Identifies any cycles in the dependency graph  At this stage, kro already knows if you're referencing something that doesn't exist or using undeclared functions, and has detected any circular dependencies. See CEL AST Parsing and Dependency Detection for technical details.  ","version":"main","tagName":"h3"},{"title":"Stage 6: Expression Type Checking​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#stage-6-expression-type-checking","content":" With expressions extracted and the dependency graph built, kro now performs comprehensive type checking on each CEL expression:  Type-checks the expression - kro uses CEL's type checker to validate the expression against the typed environment containing all resource schemas. This verifies that all field accesses, function calls, and operations are valid and type-safe. Infers the expression's output type - Based on the type checking results, kro determines what type the expression will produce. For ${schema.spec.replicas}, kro infers an integer. For ${schema.spec.name + &quot;-deployment&quot;}, kro infers a string. Validates type compatibility - kro compares the inferred output type against the expected type (determined earlier from the target field's OpenAPI schema). First, it tries CEL's built-in type assignability check. If that fails, it performs deep structural compatibility checking, which handles complex cases like map/struct conversions and subset validation. See Type Compatibility Deep Dive for technical details.  Example:  # Expression: ${schema.spec.replicas} # Inferred output type: integer (from schema.spec definition) # Expected type: integer (from Deployment.spec.replicas schema) # Result: ✓ Compatible   ","version":"main","tagName":"h3"},{"title":"Stage 7: Condition Expression Validation​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#stage-7-condition-expression-validation","content":" kro validates special condition expressions used in resource lifecycle control:  Validates readyWhen expressions - Ensures readiness conditions are valid CEL expressions that return boolean valuesValidates includeWhen expressions - Ensures conditional inclusion expressions are valid CEL expressions that return boolean values  These conditions control when resources are considered ready and whether they should be created at all, so they must always return true or false.  ","version":"main","tagName":"h3"},{"title":"Stage 8: RGD Activation​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#stage-8-rgd-activation","content":" If all validation stages pass, kro activates the ResourceGraphDefinition:  Infers topological order - Computes the order in which resources will be created based on the dependency graphRegisters the CRD - Creates the Custom Resource Definition in the cluster for your new APIStarts the microcontroller - Registers the controller that will reconcile instances of your custom resourceBegins serving instances - Your ResourceGraphDefinition is now ready to accept instance creation requests  At this point, the RGD is fully validated and operational. When users create instances of your custom API, kro will orchestrate the resources according to the validated graph.  ","version":"main","tagName":"h3"},{"title":"CEL AST Parsing and Dependency Detection​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#cel-ast-parsing-and-dependency-detection","content":" During Stage 5, kro parses every CEL expression into an Abstract Syntax Tree (AST) and analyzes how expressions reference each other. This enables kro to build a complete dependency graph and detect issues before any resources are created.  ","version":"main","tagName":"h2"},{"title":"How AST Parsing Works​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#how-ast-parsing-works","content":" When kro encounters a CEL expression like ${deployment.spec.replicas}, it:  Parses the expression into an AST - The CEL parser breaks down the expression into its component parts: an identifier (deployment), a field access (.spec), and another field access (.replicas). Walks the AST to find references - kro traverses the tree to identify what the expression references: Root identifiers (schema, deployment, configmap, etc.)Field accesses (.spec, .data, .status)Function calls (size(), string(), etc.)Operators (+, *, ?, etc.) Validates references exist - For each identifier found: If it's schema, kro validates the field path exists in your custom schemaIf it's a resource ID, kro checks that resource is defined in the DAGIf it's a function, kro validates it's a declared CEL function Builds dependency edges - When resource B references resource A, kro adds an edge A → B in the dependency graph  ","version":"main","tagName":"h3"},{"title":"Dependency Graph Construction​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#dependency-graph-construction","content":" kro builds a directed acyclic graph (DAG) showing which resources depend on which:  resources: - id: configmap template: data: key: ${schema.spec.value} # depends on: schema - id: deployment template: spec: replicas: ${schema.spec.replicas} # depends on: schema env: - value: ${configmap.data.key} # depends on: configmap   kro builds this dependency graph:  schema ├─→ configmap └─→ deployment └─→ configmap   This graph determines:  Creation order: configmap before deploymentEvaluation dependencies: deployment expressions can only be evaluated after configmap existsCircular dependency detection: kro validates there are no cycles  ","version":"main","tagName":"h3"},{"title":"Reference Validation​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#reference-validation","content":" kro validates all references during AST analysis:  Resource references:  # ✓ Valid: deployment exists value: ${deployment.spec.replicas} # ✗ Invalid: typo in resource ID value: ${deployent.spec.replicas} # Error: resource 'deployent' not found   Function references:  # ✓ Valid: size() is a CEL builtin condition: ${schema.spec.items.size() &gt; 0} # ✗ Invalid: undefined function condition: ${schema.spec.items.length()} # Error: function 'length' not declared   ","version":"main","tagName":"h3"},{"title":"Circular Dependency Detection​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#circular-dependency-detection","content":" kro detects circular dependencies by checking for cycles in the DAG:  # ✗ This fails validation resources: - id: serviceA template: spec: port: ${serviceB.spec.targetPort} # A → B - id: serviceB template: spec: targetPort: ${serviceA.spec.port} # B → A (cycle!)   Error: circular dependency detected: serviceA → serviceB → serviceA  ","version":"main","tagName":"h3"},{"title":"Type Compatibility Deep Dive​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#type-compatibility-deep-dive","content":" During Stage 6, kro performs deep structural type compatibility checking. This goes beyond simple type matching to handle complex Kubernetes schemas through recursive comparison of type structures.  ","version":"main","tagName":"h2"},{"title":"Structural Compatibility​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#structural-compatibility","content":" kro doesn't just check if types have the same name—it performs deep structural comparison:  For primitives: Checks kind equality (int, string, bool, etc.)  For lists: Recursively checks element type compatibility  # Expression returns: list&lt;int&gt; # Field expects: list&lt;int&gt; # Result: ✓ Compatible # Expression returns: list&lt;string&gt; # Field expects: list&lt;int&gt; # Result: ✗ Incompatible - element types don't match   For maps: Recursively checks key and value type compatibility  # Expression returns: map&lt;string, int&gt; # Field expects: map&lt;string, int&gt; # Result: ✓ Compatible # Expression returns: map&lt;string, string&gt; # Field expects: map&lt;string, int&gt; # Result: ✗ Incompatible - value types don't match   For structs: Validates that the output struct is a subset of the expected struct (subset semantics)  # Expression returns: {name: string, replicas: int} # Field expects: {name: string, replicas: int} # Result: ✓ Compatible (exact match) # Expression returns: {name: string} # Field expects: {name: string, replicas: int} # Result: ✓ Compatible (output is subset - missing fields are OK) # Expression returns: {name: string, replicas: int, extra: string} # Field expects: {name: string, replicas: int} # Result: ✗ Incompatible (output has extra field 'extra' not in expected)   ","version":"main","tagName":"h3"},{"title":"Map/Struct Compatibility​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#mapstruct-compatibility","content":" Kubernetes often treats maps and structs interchangeably (like labels, annotations, data fields). kro handles this intelligently:  Map → Struct assignment:  # Expression: ${schema.spec.labels} (type: map&lt;string, string&gt;) # Target field: labels (type: struct with string fields) # kro validates: map keys are strings, map values match struct field types # Result: ✓ Compatible if all struct fields accept strings   Struct → Map assignment:  # Expression: ${configmap.data} (type: struct with dynamic fields) # Target field: data (type: map&lt;string, string&gt;) # kro validates: all struct fields are string-compatible # Result: ✓ Compatible if struct → map conversion is valid   ","version":"main","tagName":"h3"},{"title":"Nested Field Type Checking​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#nested-field-type-checking","content":" kro validates types at any depth by recursively walking the type structure:  spec: template: spec: containers: - env: - name: PORT # Expression returns: int # Field path: spec.template.spec.containers[].env[].value # Field expects: string # kro resolves the full nested path and checks compatibility value: ${schema.spec.port} # ✗ Type error: int → string   ","version":"main","tagName":"h3"},{"title":"PreserveUnknownFields Handling​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#preserveunknownfields-handling","content":" For fields with x-kubernetes-preserve-unknown-fields: true, kro uses permissive validation:  # ConfigMap.data has PreserveUnknownFields configmap: data: # kro cannot validate structure at build time # Any expression type is accepted DATABASE_URL: ${schema.spec.dbUrl} PORT: ${string(schema.spec.port)}   kro still validates:  Expression syntax is correctReferenced resources existTypes are internally consistent  But it cannot validate:  Field names are correctField types match (since schema is unknown)  ","version":"main","tagName":"h3"},{"title":"Next Steps​","type":1,"pageTitle":"Static Analysis","url":"/next/docs/concepts/rgd/static-type-checking#next-steps","content":" Resource Basics - See how templates are validatedCEL Expressions - Learn CEL type systemSimpleSchema - Define typed schemas ","version":"main","tagName":"h2"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/next/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, ResourceGraphDefinitions can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your ResourceGraphDefinition. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your ResourceGraphDefinitions by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp ResourceGraphDefinition that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB ResourceGraphDefinition by combining the existingWebApp resources with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource. You are now ready to create instances of your new custom resource, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. What should I know about API changes? kro's API is currently at v1alpha1. As kro evolves, we may introduce breaking changes to improve the API. We are committed to providing clear migration paths, deprecation notices, and comprehensive support to help users adapt to any breaking changes. Our goal is to ensure smooth transitions as the project continues to improve. How do I use kro resources with ArgoCD? To use kro resources with ArgoCD, you need to add a specific tracking annotation to all templated resources in your ResourceGraphDefinition. The following code needs to be added to each templated resource: metadata: ownerReferences: - apiVersion: kro.run/v1alpha1 kind: ${schema.kind} name: ${schema.metadata.name} uid: ${schema.metadata.uid} blockOwnerDeletion: true controller: false annotations: argocd.argoproj.io/tracking-id: ${schema.metadata.?annotations[&quot;argocd.argoproj.io/tracking-id&quot;]} This annotation allows ArgoCD to properly track and manage the resources created by kro instances. Note that the example shown above depicts ArgoCD's default resource tracking via annotations. You may choose to use annotation+label or just label and if so the example has to be modified to support your configuration. For more detailed information about ArgoCD resource tracking, please see theArgoCD documentation.","keywords":"","version":"main"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/next/api/specifications/simple-schema","content":"","keywords":"","version":"main"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#type-definitions","content":" ","version":"main","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesfloat: Decimal numbers  For example:  name: string age: integer enabled: boolean price: float   ","version":"main","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"main","tagName":"h3"},{"title":"Unstructured Objects​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#unstructured-objects","content":" Unstructured objects are declared using object as a type.  warning This disables the field-validation normally offered by kro, and forwards the values to your RGD as-is. This is generally discouraged and should therefore be used with caution. In most cases, using a structured object is a better approach.  kind: ResourceGraphDefintion metadata: {} spec: schema: spec: additionalHelmChartValues: object   This allows you to pass data to your CRDs directly in cases where the schema is not known in advance. This type supports any valid object, and can mix and match different primitives as well as structured types.  apiVersion: kro.run/v1alpha1 kind: CRDWithUnstructuredObjects metadata: name: test-instance spec: additionalHelmChartValues: boolean-value: true numeric-value: 42 structural-type: with-additional: nested: fields string-value: my-string mapping-value: - item1 - item2 - item3   ","version":"main","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"main","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]float&quot;   ","version":"main","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#custom-types","content":" Custom types are specified in the separate types section. They provide a map of names to type specifications that follow the simple schema.  Example:  schema: types: Person: name: string age: integer spec: people: '[]Person | required=true`   ","version":"main","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"main","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbersimmutable=true: Field cannot be changed after creationpattern=&quot;regex&quot;: Regular expression pattern for string validationminLength=number: Minimum length for stringsmaxLength=number: Maximum length for stringsuniqueItems=true: Ensures array elements are uniqueminItems=number: Minimum number of items in arraysmaxItems=number: Maximum number of items in arrays  Multiple markers can be combined using the | separator.  ","version":"main","tagName":"h3"},{"title":"String Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#string-validation-markers","content":" String fields support additional validation markers:  pattern=&quot;regex&quot;: Validates the string against a regular expression patternminLength=number: Sets the minimum number of charactersmaxLength=number: Sets the maximum number of characters  Examples:  # Email validation email: string | pattern=&quot;^[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w+$&quot; required=true # Username with length constraints and pattern username: string | minLength=3 maxLength=15 pattern=&quot;^[a-zA-Z0-9_]+$&quot; # Country code format countryCode: string | pattern=&quot;^[A-Z]{2}$&quot; minLength=2 maxLength=2 # Password with minimum length password: string | minLength=8 description=&quot;Password must be at least 8 characters&quot;   ","version":"main","tagName":"h3"},{"title":"Array Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#array-validation-markers","content":" Array fields support validation markers to ensure data quality:  uniqueItems=true: Ensures all elements in the array are uniqueuniqueItems=false: Allows duplicate elements (default behavior)minItems=number: Sets the minimum number of elements required in the arraymaxItems=number: Sets the maximum number of elements allowed in the array  Examples:  # Unique tags with size constraints tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot; # Unique port numbers with minimum requirement ports: &quot;[]integer&quot; | uniqueItems=true minItems=1 description=&quot;At least one unique port&quot; # Allow duplicate comments with size limits comments: &quot;[]string&quot; | uniqueItems=false maxItems=50 description=&quot;Up to 50 comments&quot; # Complex validation with multiple markers roles: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=5 required=true description=&quot;1-5 unique user roles&quot; # Optional array with size constraints priorities: &quot;[]integer&quot; | minItems=0 maxItems=3 description=&quot;Up to 3 priority levels&quot;   For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; id: string | required=true immutable=true description=&quot;Unique identifier&quot; replicas: integer | default=3 minimum=1 maximum=10 price: float | minimum=0.01 maximum=999.99 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot; email: string | pattern=&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$&quot; description=&quot;Valid email address&quot; username: string | minLength=3 maxLength=20 pattern=&quot;^[a-zA-Z0-9_]+$&quot; tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot;   Floating Point Precision When using float or double types in CEL expressions (particularly in readyWhen or includeWhen conditions), be aware of floating point precision issues that could cause unexpected behavior. Avoid comparing floating point values for equality in conditional logic. Prefer using string, integer, or boolean types whenever possible to avoid precision-related oscillations in resource state.  ","version":"main","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources exist at ResourceGraphDefinition creation timeUpdates values when the underlying resources changeValidates type compatibility using CEL's native type system  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} # integer endpoint: ${service.status.loadBalancer.ingress[0].hostname} # string metadata: ${deployment.metadata} # object   ","version":"main","tagName":"h2"},{"title":"Single vs Multi-Expression Fields​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#single-vs-multi-expression-fields","content":" Status fields can contain either a single CEL expression or multiple expressions concatenated together:  Single Expression Fields can be any type:  status: replicas: ${deployment.status.replicas} # integer metadata: ${deployment.metadata} # object name: ${deployment.metadata.name} # string ready: ${deployment.status.conditions.exists(c, c.type == 'Available')} # boolean   Multi-Expression Fields (string templating) must contain only string expressions:  status: # ✓ Valid - all expressions return strings endpoint: &quot;https://${service.metadata.name}.${service.metadata.namespace}.svc.cluster.local&quot; # ✓ Valid - explicit string conversion summary: &quot;Replicas: ${string(deployment.status.replicas)}, Ready: ${string(deployment.status.ready)}&quot; # ✗ Invalid - concatenating non-string types invalid: &quot;${deployment.status.replicas}-${deployment.metadata}&quot; # Will fail validation   Multi-expression fields are useful for string templating scenarios like constructing URLs, connection strings, or IAM policies:  status: iamPolicy: | { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Resource&quot;: &quot;arn:aws:s3:::${bucket.metadata.name}/*&quot;, &quot;Principal&quot;: &quot;${serviceAccount.metadata.name}&quot; }   tip Use explicit string() conversions when concatenating non-string values to ensure type compatibility. Alternatively, you can use CEL's built-in format() function for string formatting: status: endpoint: ${&quot;https://%s.%s.svc.cluster.local&quot;.format([service.metadata.name, service.metadata.namespace])} The ${...}${...} templating syntax is a kro convenience feature that makes common string concatenation patterns more readable.  ","version":"main","tagName":"h3"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"main","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;InstanceManaged&quot;, &quot;GraphResolved&quot;, &quot;ResourcesReady&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string observedGeneration: integer reason: string message: string   kro provides a hierarchical condition structure:  Ready: Top-level condition indicating the instance is fully operational InstanceManaged: Instance finalizers and labels are properly setGraphResolved: Runtime graph has been created and resources resolvedResourcesReady: All resources in the graph are created and ready  The Ready condition aggregates the state of all sub-conditions and only becomes True when all sub-conditions are True. Each condition includes an observedGeneration field that tracks which generation of the instance the condition reflects.  ","version":"main","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # ACTIVE, IN_PROGRESS, FAILED, DELETING, ERROR   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values.  ","version":"main","tagName":"h3"},{"title":"Additional Printer Columns​","type":1,"pageTitle":"Simple Schema","url":"/next/api/specifications/simple-schema#additional-printer-columns","content":" You can define additionalPrinterColumns for the created CRD through the ResourceGraphDefinition by setting them on spec.schema.additionalPrinterColumns.  schema: spec: image: string | default=&quot;nginx&quot; status: availableReplicas: ${deployment.status.availableReplicas} additionalPrinterColumns: - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string  ","version":"main","tagName":"h2"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/next/docs/getting-started/Installation","content":"","keywords":"","version":"main"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/next/docs/getting-started/Installation#prerequisites","content":" Helm 3.x installedkubectl configured to access your cluster  ","version":"main","tagName":"h2"},{"title":"Installation​","type":1,"pageTitle":"Installing kro","url":"/next/docs/getting-started/Installation#installation","content":" Quick StartPinned Version Install the latest version: helm install kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --create-namespace   ","version":"main","tagName":"h2"},{"title":"Verify Installation​","type":1,"pageTitle":"Installing kro","url":"/next/docs/getting-started/Installation#verify-installation","content":" Check the Helm release:  helm list -n kro   Expected output:  NAME NAMESPACE REVISION STATUS kro kro 1 deployed   Check the kro pod is running:  kubectl get pods -n kro   Expected output:  NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 30s   ","version":"main","tagName":"h2"},{"title":"Upgrade​","type":1,"pageTitle":"Installing kro","url":"/next/docs/getting-started/Installation#upgrade","content":" Latest VersionSpecific Version helm upgrade kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro   info Helm does not update CRDs automatically. If a new version includes CRD changes, you may need to manually apply them. Check the release notes for CRD updates.  ","version":"main","tagName":"h2"},{"title":"Uninstall​","type":1,"pageTitle":"Installing kro","url":"/next/docs/getting-started/Installation#uninstall","content":" helm uninstall kro -n kro   info This removes the kro controller but preserves your RGDs and deployed instances. To fully clean up, manually delete instances and RGDs before uninstalling. ","version":"main","tagName":"h2"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/next/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"main"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/next/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"main"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/next/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"main"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/next/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"main"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/next/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"main"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/next/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"main"},{"title":"Optional Values & External References","type":0,"sectionRef":"#","url":"/next/examples/basic/optionals","content":"","keywords":"","version":"main"},{"title":"Config Map​","type":1,"pageTitle":"Optional Values & External References","url":"/next/examples/basic/optionals#config-map","content":" This example shows how to reference an existing ConfigMap and use the optional accessor ? to safely extract values.  config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: ECHO_VALUE: &quot;Hello, World!&quot;   deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: input externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $MY_VALUE &amp;&amp; sleep 3600&quot;] env: - name: MY_VALUE value: ${input.data.?ECHO_VALUE}   ","version":"main","tagName":"h2"},{"title":"Secret​","type":1,"pageTitle":"Optional Values & External References","url":"/next/examples/basic/optionals#secret","content":" This example demonstrates referencing an existing Secret and transforming its base64-encoded data using CEL expressions with the optional accessor and base64 decoding functions.  secret.yaml apiVersion: v1 kind: Secret metadata: name: test stringData: uri: api.test.com   secret-transformation-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: secret-transformation spec: schema: apiVersion: v1alpha1 kind: test spec: name: string resources: - id: test externalRef: apiVersion: v1 kind: Secret metadata: name: test namespace: &quot;&quot; - id: secret template: apiVersion: v1 kind: Secret metadata: name: &quot;${schema.spec.name}&quot; stringData: token: &quot;${ string(base64.decode(string(test.data.uri))) }/oauth/token&quot;  ","version":"main","tagName":"h2"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/next/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"main"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/api/","content":"API Reference API reference documentation for this version is not available.","keywords":"","version":"0.6.3"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/next/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"main"},{"title":"Access Control","type":0,"sectionRef":"#","url":"/docs/concepts/access-control","content":"","keywords":"","version":"0.6.3"},{"title":"unrestricted Access​","type":1,"pageTitle":"Access Control","url":"/docs/concepts/access-control#unrestricted-access","content":" In the unrestricted access mode, the chart includes a ClusterRole grantingkro full control to every resource type in your cluster. This can be useful for experimenting in a test environment, where access control is not necessary, but is not recommended in a production environment.  In this mode, anyone with access to create ResourceGraphDefinition resources, effectively also has admin access to the cluster.  ","version":"0.6.3","tagName":"h2"},{"title":"aggregation Access​","type":1,"pageTitle":"Access Control","url":"/docs/concepts/access-control#aggregation-access","content":" In the aggregation access mode, the chart includes an aggregated ClusterRolewhich dynamically includes all rules from all ClusterRoles that have the labelrbac.kro.run/aggregate-to-controller: &quot;true&quot;.  There is a very minimal set of permissions provisioned by the chart itself, just enough to let kro run at all: full permissions for ResourceGraphDefinitions and its subresources, and full permissions for CustomResourceDefinitions askro will create them in response to the existence of an RGD.  However, this does not automatically set up permissions for kro to actually reconcile those generated CRDs! In other words, when using this mode, you will need to provision additional access for kro for every new resource type you define.  ","version":"0.6.3","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"Access Control","url":"/docs/concepts/access-control#example","content":" If you want to create a ResourceGraphDefinition that specifies a new resource type with kind: Foo, and where the graph includes an apps/v1/Deployment and a v1/ConfigMap, you will need to create the following ClusterRole to ensurekro has enough access to reconcile your resources:  apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: rbac.kro.run/aggregate-to-controller: &quot;true&quot; name: kro:controller:foos rules: - apiGroups: - kro.run resources: - foos verbs: - &quot;*&quot; - apiGroups: - apps resources: - deployments verbs: - &quot;*&quot; - apiGroups: - &quot;&quot; resources: - configmaps verbs: - &quot;*&quot;  ","version":"0.6.3","tagName":"h3"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/docs/faq","content":"FAQ What is kro? Kube Resource Orchestrator (kro) is a new operator for Kubernetes that simplifies the creation of complex Kubernetes resource configurations. kro lets you create and manage custom groups of Kubernetes resources by defining them as a ResourceGraphDefinition, the project's fundamental custom resource. ResourceGraphDefinition specifications define a set of resources and how they relate to each other functionally. Once defined, resource groups can be applied to a Kubernetes cluster where the kro controller is running. Once validated by kro, you can create instances of your resource group. kro translates your ResourceGraphDefinition instance and its parameters into specific Kubernetes resources and configurations which it then manages for you. How does kro work? kro is designed to use core Kubernetes primitives to make resource grouping, customization, and dependency management simpler. When a ResourceGraphDefinition is applied to the cluster, the kro controller verifies its specification, then dynamically creates a new CRD and registers it with the API server. kro then deploys a dedicated controller to respond to instance events on the CRD. This microcontroller is responsible for managing the lifecycle of resources defined in the ResourceGraphDefinition for each instance that is created. How do I use kro? First, you define your custom resource groups by creating ResourceGraphDefinitionspecifications. These specify one or more Kubernetes resources, and can include specific configuration for each resource. For example, you can define a WebApp resource group that is composed of aDeployment, pre-configured to deploy your web server backend, and aService configured to run on a specific port. You can just as easily create a more complex WebAppWithDB resource group by combining the existingWebApp resource group with a Table custom resource to provision a cloud managed database instance for your web app to use. Once you have defined a ResourceGraphDefinition, you can apply it to a Kubernetes cluster where the kro controller is running. kro will take care of the heavy lifting of creating CRDs and deploying dedicated controllers in order to manage instances of your new custom resource group. You are now ready to create instances of your new custom resource group, and kro will respond by dynamically creating, configuring, and managing the underlying Kubernetes resources for you. Why did you build this project? We want to help streamline and simplify building with Kubernetes. Building with Kubernetes means dealing with resources that need to operate and work together, and orchestrating this can get complex and difficult at scale. With this project, we're taking a first step in reducing the complexity of resource dependency management and customization, paving the way for a simple and scalable way to create complex custom resources for Kubernetes. How do I use KRO resources with ArgoCD? To use KRO resources with ArgoCD, you need to add a specific tracking annotation to all templated resources in your ResourceGraphDefinition. The following code needs to be added to each templated resource: metadata: ownerReferences: - apiVersion: kro.run/v1alpha1 kind: ${schema.kind} name: ${schema.metadata.name} uid: ${schema.metadata.uid} blockOwnerDeletion: true controller: false annotations: argocd.argoproj.io/tracking-id: ${schema.metadata.?annotations[&quot;argocd.argoproj.io/tracking-id&quot;]} This annotation allows ArgoCD to properly track and manage the resources created by KRO instances. Note that the example shown above depicts ArgoCD's default resource tracking via annotations. You may choose to use annotation+label or just label and if so the example has to be modified to support your configuration. For more detailed information about ArgoCD resource tracking, please see theArgoCD documentation. Can I use this in production? This project is in active development and not yet intended for production use. The ResourceGraphDefinition CRD and other APIs used in this project are not solidified and highly subject to change.","keywords":"","version":"0.6.3"},{"title":"Instances","type":0,"sectionRef":"#","url":"/docs/concepts/instances","content":"","keywords":"","version":"0.6.3"},{"title":"Understanding Instances​","type":1,"pageTitle":"Instances","url":"/docs/concepts/instances#understanding-instances","content":" An instance represents your deployed application. When you create an instance, you're telling kro &quot;I want this set of resources running in my cluster&quot;. The instance contains your configuration values and serves as the single source of truth for your application's desired state. Here's an example instance of our WebApplication API:  apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-app spec: name: web-app image: nginx:latest ingress: enabled: true   When you create this instance, kro:  Creates all required resources (Deployment, Service, Ingress)Configures them according to your specificationManages them as a single unitKeeps their status up to date  ","version":"0.6.3","tagName":"h2"},{"title":"How kro Manages Instances​","type":1,"pageTitle":"Instances","url":"/docs/concepts/instances#how-kro-manages-instances","content":" kro uses the standard Kubernetes reconciliation pattern to manage instances:  Observe: Watches for changes to your instance or its resourcesCompare: Checks if current state matches desired stateAct: Creates, updates, or deletes resources as neededReport: Updates status to reflect current state  This continuous loop ensures your resources stay in sync with your desired state, providing features like:  Self-healingAutomatic updatesConsistent state managementStatus tracking  ","version":"0.6.3","tagName":"h2"},{"title":"Reactive Reconciliation​","type":1,"pageTitle":"Instances","url":"/docs/concepts/instances#reactive-reconciliation","content":" kro automatically watches all resources managed by an instance and triggers reconciliation when any of them change. This means:  Child Resource Changes: When a managed resource (like a Deployment or Service) is modified, kro detects the change and reconciles the instance to ensure it matches the desired state defined in your ResourceGraphDefinition. Drift Detection: If a resource is manually modified or deleted, kro will detect the drift and automatically restore it to the desired state. Dependency Updates: Changes to resources propagate through the dependency graph, ensuring all dependent resources are updated accordingly.  This reactive behavior ensures your instances maintain consistency without requiring manual intervention or periodic full reconciliations.  ","version":"0.6.3","tagName":"h3"},{"title":"Monitoring Your Instances​","type":1,"pageTitle":"Instances","url":"/docs/concepts/instances#monitoring-your-instances","content":" KRO provides rich status information for every instance:  $ kubectl get webapplication my-app NAME STATUS SYNCED AGE my-app ACTIVE true 30s   For detailed status, check the instance's YAML:  status: state: ACTIVE # High-level instance state availableReplicas: 3 # Status from Deployment conditions: # Detailed status conditions - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: instance is properly managed with finalizers and labels observedGeneration: 1 reason: Managed status: &quot;True&quot; type: InstanceManaged - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: runtime graph created and all resources resolved observedGeneration: 1 reason: Resolved status: &quot;True&quot; type: GraphResolved - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: all resources are created and ready observedGeneration: 1 reason: AllResourcesReady status: &quot;True&quot; type: ResourcesReady - lastTransitionTime: &quot;2025-08-08T00:03:46Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready   ","version":"0.6.3","tagName":"h2"},{"title":"Understanding Status​","type":1,"pageTitle":"Instances","url":"/docs/concepts/instances#understanding-status","content":" Every instance includes:  State: High-level status ACTIVE: Indicates that the instance is successfully running and active.IN_PROGRESS: Indicates that the instance is currently being processed or reconciled.FAILED: Indicates that the instance has failed to be properly reconciled.DELETING: Indicates that the instance is in the process of being deleted.ERROR: Indicates that an error occurred during instance processing. Conditions: Detailed status information structured hierarchically kro provides a top-level Ready condition that reflects the overall instance health. This condition is supported by three sub-conditions that track different phases of the reconciliation process: InstanceManaged: Instance finalizers and labels are properly set Ensures the instance is under kro's managementTracks whether cleanup handlers (finalizers) are configuredConfirms instance is labeled with ownership and version information GraphResolved: Runtime graph has been created and resources resolved Validates that the resource graph has been successfully parsedConfirms all resource templates have been resolvedEnsures dependencies between resources are properly understood ResourcesReady: All resources in the graph are created and ready Tracks the creation and readiness of all managed resourcesMonitors the health of resources in topological orderReports when all resources have reached their ready state Ready: Instance is fully operational (top-level condition) Aggregates the state of all sub-conditionsOnly becomes True when all sub-conditions are TrueThe primary condition to monitor and wait on for instance healthUse this condition in automation, CI/CD, and health checks tip Always use the Ready condition to determine instance health. The sub-conditions (InstanceManaged, GraphResolved, ResourcesReady) are provided for debugging purposes and may change in future versions. kro reserves the right to add, remove, or modify sub-conditions without breaking compatibility as long as the Ready condition behavior remains stable. Each condition includes: observedGeneration: Tracks which generation of the instance this condition reflectslastTransitionTime: When the condition last changed statereason: A programmatic identifier for the condition statemessage: A human-readable description of the current state Resource Status: Status from your resources Values you defined in your ResourceGraphDefinition's status sectionAutomatically updated as resources change  ","version":"0.6.3","tagName":"h3"},{"title":"Debugging Instance Issues​","type":1,"pageTitle":"Instances","url":"/docs/concepts/instances#debugging-instance-issues","content":" When an instance is not in the expected state, the condition hierarchy helps you quickly identify where the problem occurred:  Check the Ready condition first kubectl get &lt;your-kind&gt; &lt;instance-name&gt; -o jsonpath='{.status.conditions[?(@.type==&quot;Ready&quot;)]}' If Ready is False, check the sub-conditions to identify which phase failed: If InstanceManaged is False: Check if there are issues with finalizers or instance labelsIf GraphResolved is False: The resource graph could not be created - check the ResourceGraphDefinition for syntax errors or invalid CEL expressionsIf ResourcesReady is False: One or more managed resources failed to become ready - check the error message for which resource failed Use kubectl describe to see all conditions and recent events: kubectl describe &lt;your-kind&gt; &lt;instance-name&gt; Check the observedGeneration field in conditions: If observedGeneration is less than metadata.generation, the controller hasn't processed the latest changes yetIf they match, the conditions reflect the current state of your instance  ","version":"0.6.3","tagName":"h2"},{"title":"Best Practices​","type":1,"pageTitle":"Instances","url":"/docs/concepts/instances#best-practices","content":" Version Control: Keep your instance definitions in version control alongside your application code. This helps track changes, rollback when needed, and maintain configuration history. Use Labels Effectively: Add meaningful labels to your instances for better organization, filtering, and integration with other tools. kro propagates labels to the sub resources for easy identification. Active Monitoring: Regularly check instance status beyond just &quot;Running&quot;. Watch conditions, resource status, and events to catch potential issues early and understand your application's health. Focus on the Ready condition and its sub-conditions to understand the reconciliation state. Monitor observedGeneration: When making changes to an instance, verify thatobservedGeneration in the conditions matches metadata.generation to ensure kro has processed your changes. Leverage Reactive Reconciliation: kro automatically detects and corrects drift in managed resources. If you need to make manual changes to resources, update the instance specification instead to ensure changes persist and align with your desired state. Regular Reviews: Periodically review your instance configurations to ensure they reflect current requirements and best practices. Update resource requests, limits, and other configurations as your application needs evolve. ","version":"0.6.3","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/examples/","content":"","keywords":"","version":"0.6.3"},{"title":"Basic Examples​","type":1,"pageTitle":"Examples","url":"/examples/#basic-examples","content":" Empty ResourceGraphDefinition (Noop) Explore the simplest form of a ResourceGraphDefinition that doesn't define any resources, serving as a reference for the basic structure. Simple Web Application Deploy a basic web application with a Deployment and Service. Web Application with Ingress Extend the basic web application example to include an optional Ingress resource for external access.  ","version":"0.6.3","tagName":"h2"},{"title":"Advanced Examples​","type":1,"pageTitle":"Examples","url":"/examples/#advanced-examples","content":" Deploying CoreDNS Learn how to deploy CoreDNS in a Kubernetes cluster using kro ResourceGraphDefinitions, including the necessary Deployment, Service, and ConfigMap. ","version":"0.6.3","tagName":"h2"},{"title":"Installing kro","type":0,"sectionRef":"#","url":"/docs/getting-started/Installation","content":"","keywords":"","version":"0.6.3"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing kro","url":"/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"0.6.3","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing kro","url":"/docs/getting-started/Installation#installation-steps","content":" Alpha Stage kro is currently in alpha stage. While the images are publicly available, please note that the software is still under active development and APIs may change.  ","version":"0.6.3","tagName":"h2"},{"title":"Install kro using Helm​","type":1,"pageTitle":"Installing kro","url":"/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install kro using the Helm chart:  Fetch the latest release version from GitHub  export KRO_VERSION=$(curl -sL \\ https://api.github.com/repos/kubernetes-sigs/kro/releases/latest | \\ jq -r '.tag_name | ltrimstr(&quot;v&quot;)' )   Validate KRO_VERSION populated with a version  echo $KRO_VERSION   Install kro using Helm  helm install kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   ","version":"0.6.3","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing kro","url":"/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm -n kro list Expected result: You should see the &quot;kro&quot; release listed. NAME\tNAMESPACE\tREVISION\tSTATUS kro kro 1 deployed Check the kro pods: kubectl get pods -n kro Expected result: You should see kro-related pods running. NAME READY STATUS RESTARTS AGE kro-7d98bc6f46-jvjl5 1/1 Running 0 1s   ","version":"0.6.3","tagName":"h2"},{"title":"Upgrading kro​","type":1,"pageTitle":"Installing kro","url":"/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of kro, use the Helm upgrade command:  Replace &lt;new-version&gt; with the version you want to upgrade to.  export KRO_VERSION=&lt;new-version&gt;   Upgrade the controller  helm upgrade kro oci://registry.k8s.io/kro/charts/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove and reapply kro related CRDs. For more information, refer to the Helm documentation.  ","version":"0.6.3","tagName":"h2"},{"title":"Uninstalling kro​","type":1,"pageTitle":"Installing kro","url":"/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall kro, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all kro resources from your cluster, except for the ResourceGraphDefinition CRD and any other custom resources you may have created. ","version":"0.6.3","tagName":"h2"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/next/examples/gcp/gke-cluster","content":"","keywords":"","version":"main"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/next/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"main","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/next/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"main","tagName":"h2"},{"title":"Deploy Your First ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/docs/getting-started/deploy-a-resource-graph-definition","content":"","keywords":"","version":"0.6.3"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/docs/getting-started/deploy-a-resource-graph-definition#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. In this example, we’ll create aResourceGraphDefinition that packages a reusable set of resources, including aDeployment, Service, and Ingress. These resources are available in any Kubernetes cluster. Users can then call the API to deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGraphDefinition, kro:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  ","version":"0.6.3","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/docs/getting-started/deploy-a-resource-graph-definition#prerequisites","content":" Before you begin, make sure you have the following:  kro installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"0.6.3","tagName":"h2"},{"title":"Create your Application ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-resourcegraphdefinition","content":" Let's create a Resource Graph Definition that combines a Deployment, a Service andIngress. Save this as resourcegraphdefinition.yaml:  resourcegraphdefinition.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"0.6.3","tagName":"h2"},{"title":"Deploy the ResourceGraphDefinition​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/docs/getting-started/deploy-a-resource-graph-definition#deploy-the-resourcegraphdefinition","content":" Create a ResourceGraphDefinition manifest file: Create a new file with theResourceGraphDefinition definition. You can use the example above. Apply the ResourceGraphDefinition: Use the kubectl command to deploy the ResourceGraphDefinition to your Kubernetes cluster: kubectl apply -f resourcegraphdefinition.yaml Inspect the ResourceGraphDefinition: Check the status of the resources created by the ResourceGraphDefinition using the kubectl command: kubectl get rgd my-application -owide You should see the ResourceGraphDefinition in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"0.6.3","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/docs/getting-started/deploy-a-resource-graph-definition#create-your-application-instance","content":" Now that your ResourceGraphDefinition is created, kro has generated a new API (Application) that orchestrates the creation of a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"0.6.3","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGraphDefinition","url":"/docs/getting-started/deploy-a-resource-graph-definition#delete-the-application-instance","content":" kro can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"0.6.3","tagName":"h3"},{"title":"What is kro?","type":0,"sectionRef":"#","url":"/docs/overview","content":"","keywords":"","version":"0.6.3"},{"title":"Developer interface​","type":1,"pageTitle":"What is kro?","url":"/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Figure 1: End user interface - Custom API  ","version":"0.6.3","tagName":"h3"},{"title":"ResourceGraphDefinition​","type":1,"pageTitle":"What is kro?","url":"/docs/overview#resourcegraphdefinition","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGraphDefinition (RG). The Platform, Security, and Compliance teams can collaborate to create custom APIs by defining Custom Resources for the ResourceGraphDefinition CRD.  In the depicted example, the Platform Team has created a RG with arbitrary name &quot;Application Stack&quot; that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. When the RGD is applied to the cluster, a new API of kind ApplicationStack is created and available for the Developer to interact with. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Figure 2: ResourceGraphDefinition (RG) - Platform Team Interface  ","version":"0.6.3","tagName":"h3"},{"title":"ResourceGraphDefinition Instance​","type":1,"pageTitle":"What is kro?","url":"/docs/overview#resourcegraphdefinition-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Figure 3: ResourceGraphDefinition Instance (RGI)  Why kro?  ","version":"0.6.3","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is kro?","url":"/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using kro, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"0.6.3","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is kro?","url":"/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using kro. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"0.6.3","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is kro?","url":"/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity. ","version":"0.6.3","tagName":"h3"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/next/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployment on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"main"},{"title":"ResourceGraphDefinitions","type":0,"sectionRef":"#","url":"/docs/concepts/resource-group-definitions","content":"","keywords":"","version":"0.6.3"},{"title":"What is a ResourceGraphDefinition?​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/docs/concepts/resource-group-definitions#what-is-a-resourcegraphdefinition","content":" A ResourceGraphDefinition is a custom resource that lets you create new Kubernetes APIs for deploying multiple resources together. It acts as a blueprint, defining:  What users can configure (schema)What resources to create (resources)How resources reference each other (dependencies)When resources should be included (conditions)What status to expose (status)  When you create a ResourceGraphDefinition, kro generates a new API (a.k.a Custom Resource Definition) in your cluster that others can use to deploy resources in a consistent, controlled way.  ","version":"0.6.3","tagName":"h2"},{"title":"Anatomy of a ResourceGraphDefinition​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/docs/concepts/resource-group-definitions#anatomy-of-a-resourcegraphdefinition","content":" A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:  Metadata: name, labels, etc.Spec: Defines the structure and properties of the ResourceGraphDefinitionStatus: Reflects the current state of the ResourceGraphDefinition  The spec section of a ResourceGraphDefinition contains two main components:  Schema: Defines what an instance of your API looks like: What users can configure during creation and updateWhat status information they can viewDefault values and validation rules Resources: Specifies the Kubernetes resources to create: Resource templatesDependencies between resourcesConditions for inclusionReadiness criteriaExternal References  This structure translates to YAML as follows:  apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-resourcegraphdefinition # Metadata section spec: schema: # Define your API apiVersion: v1alpha1 # API version kind: MyAPI # API kind spec: {} # fields users can configure status: {} # fields kro will populate # Define the resources kro will manage resources: - id: resource1 # declare your resources along with default values and variables template: {}   Let's look at each component in detail...  ","version":"0.6.3","tagName":"h2"},{"title":"Understanding the Schema​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/docs/concepts/resource-group-definitions#understanding-the-schema","content":" The schema section defines your new API's structure. It determines:  What fields users can configure when creating instancesWhat status information they can viewType validation and default values  Here's an example schema:  schema: apiVersion: v1alpha1 kind: WebApplication # This becomes your new API type spec: # Fields users can configure using a simple, straightforward syntax name: string image: string | default=&quot;nginx&quot; replicas: integer | default=3 ingress: enabled: boolean | default=false status: # Fields kro will populate automatically from your resources # Types are inferred from these CEL expressions availableReplicas: ${deployment.status.availableReplicas} conditions: ${deployment.status.conditions} validation: # Validating admission policies added to the new API type's CRD - expression: &quot;${ self.image == 'nginx' || !self.ingress.enabled }&quot; message: &quot;Only nginx based applications can have ingress enabled&quot; additionalPrinterColumns: # Printer columns shown for the created custom resource - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string   kro follows a different approach for defining your API schema and shapes. It leverages a human-friendly and readable syntax that is OpenAPI spec compatible. No need to write complex OpenAPI schemas - just define your fields and types in a straightforward way. For the complete specification of this format, check out the Simple Schema specification. Status fields use CEL expressions to reference fields from resources defined in your ResourceGraphDefinition. kro automatically:  Infers the correct types from your expressionsValidates that referenced resources existUpdates these fields as your resources change  ","version":"0.6.3","tagName":"h2"},{"title":"Processing​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/docs/concepts/resource-group-definitions#processing","content":" When you create a ResourceGraphDefinition, kro processes it in several steps to ensure correctness and set up the necessary components:  Validation: kro validates your ResourceGraphDefinition to ensure it's well formed and follows the correct syntax, maximizing the chances of successful deployment, and catching as many errors as possible early on. It: Validates your schema definition follows the simple schema formatEnsures all resource templates are valid Kubernetes manifestsChecks that referenced values exist and are of the correct typeConfirms resource dependencies form a valid Directed Acyclic Graph(DAG) without cyclesValidates all CEL expressions in status fields and conditions using CEL's native type system Validates field references exist in the actual resource schemasEnsures expressions return types compatible with their target fieldsValidates that CEL functions called in expressions exist and are used correctlyChecks expression correctness and type compatibility statically without executing expressions API Generation: kro generates and registers a new CRD in your cluster based on your schema. For example, if your ResourceGraphDefinition defines aWebApplication API, kro creates a CRD that: Provides API validation based on your schema definitionAutomatically applies default values you've definedMakes status information available to users and other systemsIntegrates seamlessly with kubectl and other Kubernetes tools Controller Configuration: kro configures itself to watch for instances of your new API and their managed resources: Creates all required resources following the dependency orderManages references and value passing between resourcesHandles the complete lifecycle for create, update, and delete operationsKeeps status information up to date based on actual resource statesAutomatically detects and reconciles drift in managed resourcesTriggers reconciliation when any managed resource changes  For instance, when you create a WebApplication ResourceGraphDefinition, kro generates the webapplications.kro.run CRD. When users create instances of this API, kro manages all the underlying resources (Deployments, Services, Custom Resources, etc.) automatically.  kro continuously monitors your ResourceGraphDefinition for changes, updating the API and its behavior accordingly.  ","version":"0.6.3","tagName":"h2"},{"title":"Instance Example​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/docs/concepts/resource-group-definitions#instance-example","content":" After the ResourceGraphDefinition is validated and registered in the cluster, users can create instances of it. Here's an example of how an instance for theWebApplication might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   ","version":"0.6.3","tagName":"h2"},{"title":"More about Resources​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/docs/concepts/resource-group-definitions#more-about-resources","content":" Users can specify more controls in resources in .spec.resources[]  spec: resources: - id: my-resource template || externalRef: {} # users can either template resources or reference objects outside the graph readyWhen: # users can specify CEL expressions to determine when a resource is ready - ${deployment.status.conditions.exists(x, x.type == 'Available' &amp;&amp; x.status == &quot;True&quot;)} includeWhen: # users can specify CEL expressions to determine when a resource should be included in the graph - ${schema.spec.value.enabled}   ","version":"0.6.3","tagName":"h2"},{"title":"Using externalRef to reference Objects outside the ResourceGraphDefinition.​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/docs/concepts/resource-group-definitions#using-externalref-to-reference-objects-outside-the-resourcegraphdefinition","content":" Users can specify if the object is something that is created out-of-band and needs to be referenced in the RGD. An external reference could be specified like this:  resources: id: projectConfig externalRef: apiVersion: corp.platform.com/v1 kind: Project metadata: name: default-project namespace: # optional, if empty uses instance namespace   As part of processing the Resource Graph, the instance reconciler waits for the externalRef object to be present and reads the object from the cluster as a node in the graph. Subsequent resources can use data from this node.  ","version":"0.6.3","tagName":"h3"},{"title":"Using Conditional CEL Expressions (?)​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/docs/concepts/resource-group-definitions#using-conditional-cel-expressions-","content":" KRO can make use of CEL Expressions (see this proposal for details or look at the CEL Implementation Reference) to define optional runtime conditions for resources based on the conditional operator ?.  This allows you to optionally define values that have no predefined schema or are not hard dependencies in the Graph.  Using ? for referencing schema-less objects like ConfigMap or Secret​  You can use the optional operator to reference objects that do not have a predefined schema in the ResourceGraphDefinition. This is useful for referencing objects that may or may not exist at runtime.  ⚠️ ? removes the ability of KRO to introspect the schema of the referenced object. Thus, it cannot wait for fields after the ? to be present. It is recommended to use conditional expressions only for objects that are not critical to the ResourceGraphDefinition's operation or when the schema cannot be known at design time.  A config map can be referenced like this:  config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: VALUE: &quot;foobar&quot;   external reference in ResourceGraphDefinition - id: external externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default   With this reference, you can access the data in your schema:  CEL Expression ${external.data.?VALUE}   ⚠️ KRO will only wait for the external reference to be present in the cluster, but it will not validate the schema of the referenced config. If the config map does not have the VALUE field, the expression will evaluate to null and might result in unexpected behavior in your application if not handled properly.  For a more detailed example, see the Optional Values &amp; External References documentation.  ","version":"0.6.3","tagName":"h3"},{"title":"Status Reporting​","type":1,"pageTitle":"ResourceGraphDefinitions","url":"/docs/concepts/resource-group-definitions#status-reporting","content":" The status section of a ResourceGraphDefinition provides information about the state of the graph and it's generated CustomResourceDefinition and controller.  status includes a stable Ready condition (as well as a set of technical status.conditions that provide more detailed information about the state of the graph and its resources).  info When the Ready condition status is True, it indicates that the ResourceGraphDefinition is valid and you can use it to create instances.  warning Try to only rely on the Ready condition, as other condition types may change frequently and are more technical in nature, can change their API over time and are generally more indicative of KRO's internal state.  Additionally, the ResourceGraphDefinition contains a topologicalOrder field that provides a list of resources in the order they should be processed. This is useful for understanding the dependencies between resources and their apply order.  Generally a status in ResourceGraphDefinition may look like  status: conditions: - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: resource graph and schema are valid observedGeneration: 1 reason: Valid status: &quot;True&quot; type: ResourceGraphAccepted - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: kind DeploymentService has been accepted and ready observedGeneration: 1 reason: Ready status: &quot;True&quot; type: KindReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: controller is running observedGeneration: 1 reason: Running status: &quot;True&quot; type: ControllerReady - lastTransitionTime: &quot;2025-08-06T17:26:41Z&quot; message: &quot;&quot; observedGeneration: 1 reason: Ready status: &quot;True&quot; type: Ready state: Active topologicalOrder: - configmap - deployment  ","version":"0.6.3","tagName":"h2"},{"title":"Simple Schema","type":0,"sectionRef":"#","url":"/docs/concepts/simple-schema","content":"","keywords":"","version":"0.6.3"},{"title":"Type Definitions​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#type-definitions","content":" ","version":"0.6.3","tagName":"h2"},{"title":"Basic Types​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#basic-types","content":" kro supports these foundational types:  string: Text valuesinteger: Whole numbersboolean: True/False valuesfloat: Decimal numbers  For example:  name: string age: integer enabled: boolean price: float   ","version":"0.6.3","tagName":"h3"},{"title":"Structure Types​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#structure-types","content":" You can create complex objects by nesting fields. Each field can use any type, including other structures:  # Simple structure address: street: string city: string zipcode: string # Nested structures user: name: string address: # Nested object street: string city: string contacts: &quot;[]string&quot; # Array of strings   ","version":"0.6.3","tagName":"h3"},{"title":"Unstructured Objects​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#unstructured-objects","content":" Unstructured objects are declared using object as a type.  warning This disables the field-validation normally offered by kro, and forwards the values to your RGD as-is. This is generally discouraged and should therefore be used with caution. In most cases, using a structured object is a better approach.  kind: ResourceGraphDefintion metadata: {} spec: schema: spec: additionalHelmChartValues: object   This allows you to pass data to your CRDs directly in cases where the schema is not known in advance. This type supports any valid object, and can mix and match different primitives as well as structured types.  apiVersion: kro.run/v1alpha1 kind: CRDWithUnstructuredObjects metadata: name: test-instance spec: additionalHelmChartValues: boolean-value: true numeric-value: 42 structural-type: with-additional: nested: fields string-value: my-string mapping-value: - item1 - item2 - item3   ","version":"0.6.3","tagName":"h3"},{"title":"Array Types​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#array-types","content":" Arrays are denoted using [] syntax:  Basic arrays: []string, []integer, []boolean  Examples:  tags: []string ports: []integer   ","version":"0.6.3","tagName":"h3"},{"title":"Map Types​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#map-types","content":" Maps are key-value pairs denoted as map[keyType]valueType:  map[string]string: String to string mappingmap[string]integer: String to integer mapping  Examples:  labels: &quot;map[string]string&quot; metrics: &quot;map[string]float&quot;   ","version":"0.6.3","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#custom-types","content":" Custom types are specified in the separate types section. They provide a map of names to type specifications that follow the simple schema.  Example:  schema: types: Person: name: string age: integer spec: people: '[]Person | required=true`   ","version":"0.6.3","tagName":"h3"},{"title":"Validation and Documentation​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#validation-and-documentation","content":" Fields can have multiple markers for validation and documentation:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; replicas: integer | default=3 minimum=1 maximum=10 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot;   ","version":"0.6.3","tagName":"h2"},{"title":"Supported Markers​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#supported-markers","content":" required=true: Field must be provideddefault=value: Default value if not specifieddescription=&quot;...&quot;: Field documentationenum=&quot;value1,value2&quot;: Allowed valuesminimum=value: Minimum value for numbersmaximum=value: Maximum value for numbersimmutable=true: Field cannot be changed after creationpattern=&quot;regex&quot;: Regular expression pattern for string validationminLength=number: Minimum length for stringsmaxLength=number: Maximum length for stringsuniqueItems=true: Ensures array elements are uniqueminItems=number: Minimum number of items in arraysmaxItems=number: Maximum number of items in arrays  Multiple markers can be combined using the | separator.  ","version":"0.6.3","tagName":"h3"},{"title":"String Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#string-validation-markers","content":" String fields support additional validation markers:  pattern=&quot;regex&quot;: Validates the string against a regular expression patternminLength=number: Sets the minimum number of charactersmaxLength=number: Sets the maximum number of characters  Examples:  # Email validation email: string | pattern=&quot;^[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w+$&quot; required=true # Username with length constraints and pattern username: string | minLength=3 maxLength=15 pattern=&quot;^[a-zA-Z0-9_]+$&quot; # Country code format countryCode: string | pattern=&quot;^[A-Z]{2}$&quot; minLength=2 maxLength=2 # Password with minimum length password: string | minLength=8 description=&quot;Password must be at least 8 characters&quot;   ","version":"0.6.3","tagName":"h3"},{"title":"Array Validation Markers​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#array-validation-markers","content":" Array fields support validation markers to ensure data quality:  uniqueItems=true: Ensures all elements in the array are uniqueuniqueItems=false: Allows duplicate elements (default behavior)minItems=number: Sets the minimum number of elements required in the arraymaxItems=number: Sets the maximum number of elements allowed in the array  Examples:  # Unique tags with size constraints tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot; # Unique port numbers with minimum requirement ports: &quot;[]integer&quot; | uniqueItems=true minItems=1 description=&quot;At least one unique port&quot; # Allow duplicate comments with size limits comments: &quot;[]string&quot; | uniqueItems=false maxItems=50 description=&quot;Up to 50 comments&quot; # Complex validation with multiple markers roles: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=5 required=true description=&quot;1-5 unique user roles&quot; # Optional array with size constraints priorities: &quot;[]integer&quot; | minItems=0 maxItems=3 description=&quot;Up to 3 priority levels&quot;   For example:  name: string | required=true default=&quot;app&quot; description=&quot;Application name&quot; id: string | required=true immutable=true description=&quot;Unique identifier&quot; replicas: integer | default=3 minimum=1 maximum=10 price: float | minimum=0.01 maximum=999.99 mode: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot; email: string | pattern=&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$&quot; description=&quot;Valid email address&quot; username: string | minLength=3 maxLength=20 pattern=&quot;^[a-zA-Z0-9_]+$&quot; tags: &quot;[]string&quot; | uniqueItems=true minItems=1 maxItems=10 description=&quot;1-10 unique tags&quot;   Floating Point Precision When using float or double types in CEL expressions (particularly in readyWhen or includeWhen conditions), be aware of floating point precision issues that could cause unexpected behavior. Avoid comparing floating point values for equality in conditional logic. Prefer using string, integer, or boolean types whenever possible to avoid precision-related oscillations in resource state.  ","version":"0.6.3","tagName":"h3"},{"title":"Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#status-fields","content":" Status fields use CEL expressions to reference values from resources. kro automatically:  Infers the correct types from the expressionsValidates that referenced resources exist at ResourceGraphDefinition creation timeUpdates values when the underlying resources changeValidates type compatibility using CEL's native type system  status: # Types are inferred from the referenced fields availableReplicas: ${deployment.status.availableReplicas} # integer endpoint: ${service.status.loadBalancer.ingress[0].hostname} # string metadata: ${deployment.metadata} # object   ","version":"0.6.3","tagName":"h2"},{"title":"Single vs Multi-Expression Fields​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#single-vs-multi-expression-fields","content":" Status fields can contain either a single CEL expression or multiple expressions concatenated together:  Single Expression Fields can be any type:  status: replicas: ${deployment.status.replicas} # integer metadata: ${deployment.metadata} # object name: ${deployment.metadata.name} # string ready: ${deployment.status.conditions.exists(c, c.type == 'Available')} # boolean   Multi-Expression Fields (string templating) must contain only string expressions:  status: # ✓ Valid - all expressions return strings endpoint: &quot;https://${service.metadata.name}.${service.metadata.namespace}.svc.cluster.local&quot; # ✓ Valid - explicit string conversion summary: &quot;Replicas: ${string(deployment.status.replicas)}, Ready: ${string(deployment.status.ready)}&quot; # ✗ Invalid - concatenating non-string types invalid: &quot;${deployment.status.replicas}-${deployment.metadata}&quot; # Will fail validation   Multi-expression fields are useful for string templating scenarios like constructing URLs, connection strings, or IAM policies:  status: iamPolicy: | { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Resource&quot;: &quot;arn:aws:s3:::${bucket.metadata.name}/*&quot;, &quot;Principal&quot;: &quot;${serviceAccount.metadata.name}&quot; }   tip Use explicit string() conversions when concatenating non-string values to ensure type compatibility. Alternatively, you can use CEL's built-in format() function for string formatting: status: endpoint: ${&quot;https://%s.%s.svc.cluster.local&quot;.format([service.metadata.name, service.metadata.namespace])} The ${...}${...} templating syntax is a kro convenience feature that makes common string concatenation patterns more readable.  ","version":"0.6.3","tagName":"h3"},{"title":"Default Status Fields​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#default-status-fields","content":" kro automatically injects two fields to every instance's status:  ","version":"0.6.3","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#1-conditions","content":" An array of condition objects tracking the instance's state:  status: conditions: - type: string # e.g., &quot;Ready&quot;, &quot;InstanceManaged&quot;, &quot;GraphResolved&quot;, &quot;ResourcesReady&quot; status: string # &quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot; lastTransitionTime: string observedGeneration: integer reason: string message: string   kro provides a hierarchical condition structure:  Ready: Top-level condition indicating the instance is fully operational InstanceManaged: Instance finalizers and labels are properly setGraphResolved: Runtime graph has been created and resources resolvedResourcesReady: All resources in the graph are created and ready  The Ready condition aggregates the state of all sub-conditions and only becomes True when all sub-conditions are True. Each condition includes an observedGeneration field that tracks which generation of the instance the condition reflects.  ","version":"0.6.3","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#2-state","content":" A high-level summary of the instance's status:  status: state: string # ACTIVE, IN_PROGRESS, FAILED, DELETING, ERROR   tip conditions and state are reserved words. If defined in your schema, kro will override them with its own values.  ","version":"0.6.3","tagName":"h3"},{"title":"Additional Printer Columns​","type":1,"pageTitle":"Simple Schema","url":"/docs/concepts/simple-schema#additional-printer-columns","content":" You can define additionalPrinterColumns for the created CRD through the ResourceGraphDefinition by setting them on spec.schema.additionalPrinterColumns.  schema: spec: image: string | default=&quot;nginx&quot; status: availableReplicas: ${deployment.status.availableReplicas} additionalPrinterColumns: - jsonPath: .status.availableReplicas name: Available replicas type: integer - jsonPath: .spec.image name: Image type: string  ","version":"0.6.3","tagName":"h2"},{"title":"Networking Stack","type":0,"sectionRef":"#","url":"/examples/aws/ack-networking-stack","content":"Networking Stack networking-stack.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: networkingstack.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: NetworkingStack spec: name: string status: networkingInfo: vpcID: ${vpc.status.vpcID} subnetAZA: ${subnetAZA.status.subnetID} subnetAZB: ${subnetAZB.status.subnetID} subnetAZC: ${subnetAZC.status.subnetID} securityGroup: ${securityGroup.status.id} # resources resources: - id: vpc template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - id: subnetAZA template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${vpc.status.vpcID} - id: subnetAZC template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: subnet-c-${schema.spec.name} spec: availabilityZone: us-west-2c cidrBlock: 192.168.128.0/18 vpcID: ${vpc.status.vpcID} - id: securityGroup template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${vpc.status.vpcID} name: my-sg-${schema.spec.name} description: something something ","keywords":"","version":"0.6.3"},{"title":"Valkey cluster","type":0,"sectionRef":"#","url":"/examples/aws/ack-valkey-cachecluster","content":"Valkey cluster valkey-cachecluster.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: valkey.kro.run spec: schema: apiVersion: v1alpha1 kind: Valkey spec: name: string status: csgARN: ${cacheSubnetGroup.status.ackResourceMetadata.arn} subnets: ${cacheSubnetGroup.status.subnets} clusterARN: ${valkey.status.ackResourceMetadata.arn} resources: - id: networkingStack template: apiVersion: kro.run/v1alpha1 kind: NetworkingStack metadata: name: ${schema.spec.name}-networking-stack spec: name: ${schema.spec.name}-networking-stack - id: cacheSubnetGroup template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheSubnetGroup metadata: name: ${schema.spec.name}-valkey-subnet-group spec: cacheSubnetGroupDescription: &quot;Valkey ElastiCache subnet group&quot; cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group subnetIDs: - ${networkingStack.status.networkingInfo.subnetAZA} - ${networkingStack.status.networkingInfo.subnetAZB} - ${networkingStack.status.networkingInfo.subnetAZC} - id: sg template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: ${schema.spec.name}-valkey-sg spec: name: ${schema.spec.name}-valkey-sg description: &quot;Valkey ElastiCache security group&quot; vpcID: ${networkingStack.status.networkingInfo.vpcID} ingressRules: - fromPort: 6379 toPort: 6379 ipProtocol: tcp ipRanges: - cidrIP: 0.0.0.0/0 - id: valkey template: apiVersion: elasticache.services.k8s.aws/v1alpha1 kind: CacheCluster metadata: name: ${schema.spec.name}-valkey spec: cacheClusterID: vote-valkey-cluster cacheNodeType: cache.t3.micro cacheSubnetGroupName: ${schema.spec.name}-valkey-subnet-group engine: valkey engineVersion: &quot;8.x&quot; numCacheNodes: 1 port: 6379 securityGroupIDs: - ${sg.status.id} ","keywords":"","version":"0.6.3"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/next/examples/gcp/cloud-sql","content":"","keywords":"","version":"main"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/next/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"main","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/next/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"main","tagName":"h2"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/next/examples/gcp/eventarc","content":"","keywords":"","version":"main"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/next/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"main","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/next/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"main","tagName":"h2"},{"title":"AWS Examples","type":0,"sectionRef":"#","url":"/examples/aws/aws-examples","content":"ACK controllers Dependency Most examples below will need ACK controllers to be running in the cluster either through kro or other means. AWS Examples Deploying a Controller Discover how to deploy a Kubernetes controller using kro ResourceGraphDefinitions, including the necessary Deployment, ServiceAccount, and CRDs. AWS Networking Stack Learn how to define and manage an AWS networking stack using kro ResourceGraphDefinitions, including VPCs, subnets, and security groups. EKS Cluster with ACK CRDs Explore how to define and manage an EKS cluster using AWS Controllers for Kubernetes (ACK) CRDs within a kro ResourceGraphDefinition. Valkey CacheCluster with ACK CRDs Learn how to create and configure a Valkey CacheCluster using ACK CRDs in a kro ResourceGraphDefinition. Pod and RDS DBInstance Deploy a Pod and an RDS DBInstance in a kro ResourceGraphDefinition, showcasing the use of multiple resources with dependencies.","keywords":"","version":"0.6.3"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/next/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"main"},{"title":"Controller Deployment","type":0,"sectionRef":"#","url":"/examples/aws/deploying-controller","content":"Controller Deployment controller-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscontrollers.kro.run spec: schema: apiVersion: v1alpha1 kind: EKSController spec: name: string | default=eks-controller namespace: string | default=default values: aws: accountID: string | required=true region: string | default=us-west-2 deployment: containerPort: integer | default=8080 replicas: integer | default=1 iamRole: maxSessionDuration: integer | default=3600 oidcProvider: string | required=true roleDescription: string | default=IRSA role for ACK EKS controller deployment on EKS cluster using kro Resource group iamPolicy: # would prefer to add a policyDocument here, need to support multiline string here description: string | default=&quot;policy for eks controller&quot; image: deletePolicy: string | default=delete repository: string | default=public.ecr.aws/aws-controllers-k8s/eks-controller tag: string | default=1.4.7 resources: requests: memory: string | default=64Mi cpu: string | default=50m limits: memory: string | default=128Mi cpu: string | default=100m log: enabled: boolean | default=false level: string | default=info serviceAccount: name: string | default=eks-controller-sa resources: - id: eksCRDGroup template: apiVersion: kro.run/v1alpha1 kind: EKSCRDGroup metadata: name: ${schema.spec.name}-crd-group spec: name: ${schema.spec.name}-crd-group - id: eksControllerIamPolicy template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Policy metadata: name: ${schema.spec.name}-iam-policy spec: name: ${schema.spec.name}-iam-policy description: ${schema.spec.values.iamPolicy.description} policyDocument: &gt; { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;VisualEditor0&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;eks:*&quot;, &quot;iam:GetRole&quot;, &quot;iam:PassRole&quot;, &quot;iam:ListAttachedRolePolicies&quot;, &quot;ec2:DescribeSubnets&quot; ], &quot;Resource&quot;: &quot;*&quot; } ] } - id: eksControllerIamRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: ${schema.spec.name}-iam-role namespace: ${schema.spec.namespace} spec: name: ${schema.spec.name}-iam-role description: ${schema.spec.values.iamRole.roleDescription} maxSessionDuration: ${schema.spec.values.iamRole.maxSessionDuration} policies: - ${eksControllerIamPolicy.status.ackResourceMetadata.arn} assumeRolePolicyDocument: &gt; { &quot;Version&quot;:&quot;2012-10-17&quot;, &quot;Statement&quot;: [{ &quot;Effect&quot;:&quot;Allow&quot;, &quot;Principal&quot;: {&quot;Federated&quot;: &quot;arn:aws:iam::${schema.spec.values.aws.accountID}:oidc-provider/${schema.spec.values.iamRole.oidcProvider}&quot;}, &quot;Action&quot;: [&quot;sts:AssumeRoleWithWebIdentity&quot;], &quot;Condition&quot;: { &quot;StringEquals&quot;: {&quot;${schema.spec.values.iamRole.oidcProvider}:sub&quot;: &quot;system:serviceaccount:${schema.spec.namespace}:${schema.spec.values.serviceAccount.name}&quot;} } }] } - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.values.serviceAccount.name} namespace: ${schema.spec.namespace} annotations: eks.amazonaws.com/role-arn : ${eksControllerIamRole.status.ackResourceMetadata.arn} - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name}-deployment namespace: ${schema.spec.namespace} labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} template: metadata: labels: app.kubernetes.io.name: ${schema.spec.name}-deployment app.kubernetes.io.instance: ${schema.spec.name} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - command: - ./bin/controller args: - --aws-region - ${schema.spec.values.aws.region} - --enable-development-logging=${schema.spec.values.log.enabled} - --log-level - ${schema.spec.values.log.level} - --deletion-policy - ${schema.spec.values.image.deletePolicy} - --watch-namespace - ${schema.spec.namespace} image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} name: controller ports: - name: http containerPort: ${schema.spec.values.deployment.containerPort} resources: requests: memory: ${schema.spec.values.image.resources.requests.memory} cpu: ${schema.spec.values.image.resources.requests.cpu} limits: memory: ${schema.spec.values.image.resources.limits.memory} cpu: ${schema.spec.values.image.resources.limits.cpu} env: - name: ACK_SYSTEM_NAMESPACE value: ${schema.spec.namespace} - name: AWS_REGION value: ${schema.spec.values.aws.region} - name: DELETE_POLICY value: ${schema.spec.values.image.deletePolicy} - name: ACK_LOG_LEVEL value: ${schema.spec.values.log.level} ports: - containerPort: 80 - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name}-clusterrolebinding roleRef: kind: ClusterRole apiGroup: rbac.authorization.k8s.io name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name}-clusterrole rules: - apiGroups: - &quot;&quot; resources: - configmaps - secrets verbs: - get - list - patch - watch - apiGroups: - &quot;&quot; resources: - namespaces verbs: - get - list - watch - apiGroups: - ec2.services.k8s.aws resources: - securitygroups - securitygroups/status - subnets - subnets/status verbs: - get - list - apiGroups: - eks.services.k8s.aws resources: - accessentries - addons - clusters - fargateprofiles - identityproviderconfigs - nodegroups - podidentityassociations verbs: - create - delete - get - list - patch - update - watch - apiGroups: - eks.services.k8s.aws resources: - accessentries/status - addons/status - clusters/status - fargateprofiles/status - identityproviderconfigs/status - nodegroups/status - podidentityassociations/status verbs: - get - patch - update - apiGroups: - iam.services.k8s.aws resources: - roles - roles/status verbs: - get - list - apiGroups: - kms.services.k8s.aws resources: - keys - keys/status verbs: - get - list - apiGroups: - services.k8s.aws resources: - adoptedresources - fieldexports verbs: - create - delete - get - list - patch - update - watch - apiGroups: - services.k8s.aws resources: - adoptedresources/status - fieldexports/status verbs: - get - patch - update ","keywords":"","version":"0.6.3"},{"title":"Pod with RDS DBInstance","type":0,"sectionRef":"#","url":"/examples/aws/pod-rds-dbinstance","content":"Pod with RDS DBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentandawspostgres spec: # CRD Definition schema: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres spec: applicationName: string image: string location: string # Resources resources: - id: dbinstance template: apiVersion: rds.services.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - id: pod template: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRES_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"0.6.3"},{"title":"Empty ResourceGraphDefinition","type":0,"sectionRef":"#","url":"/examples/basic/noop","content":"Empty ResourceGraphDefinition noop.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: noop spec: schema: apiVersion: v1alpha1 kind: NoOp spec: name: string | required=true resources: [] ","keywords":"","version":"0.6.3"},{"title":"Optional Values & External References","type":0,"sectionRef":"#","url":"/examples/basic/optionals","content":"Optional Values &amp; External References config-map.yaml apiVersion: v1 kind: ConfigMap metadata: name: demo data: ECHO_VALUE: &quot;Hello, World!&quot; deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: input externalRef: apiVersion: v1 kind: ConfigMap metadata: name: demo namespace: default - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-busybox image: busybox command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo $MY_VALUE &amp;&amp; sleep 3600&quot;] env: - name: MY_VALUE value: ${input.data.?ECHO_VALUE} ","keywords":"","version":"0.6.3"},{"title":"Web Application","type":0,"sectionRef":"#","url":"/examples/basic/web-app","content":"Web Application deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: deploymentservice spec: schema: apiVersion: v1alpha1 kind: DeploymentService spec: name: string resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"0.6.3"},{"title":"Web Application w/ Ingress","type":0,"sectionRef":"#","url":"/examples/basic/web-app-ingress","content":"Web Application w/ Ingress webapp-ingress.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: my-application spec: # kro uses this simple schema to create your CRD schema and apply it # The schema defines what users can provide when they instantiate the RGD (create an instance). schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - id: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80 ","keywords":"","version":"0.6.3"},{"title":"GCSBucketWithFinalizerTrigger","type":0,"sectionRef":"#","url":"/examples/gcp/eventarc","content":"","keywords":"","version":"0.6.3"},{"title":"End User: GCSBucketWithFinalizerTrigger​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/examples/gcp/eventarc#end-user-gcsbucketwithfinalizertrigger","content":" The administrator needs to install the RGD first. The end user creates a GCSBucketWithFinalizerTrigger resource something like this:  apiVersion: kro.run/v1alpha1 kind: GCSBucketWithFinalizerTrigger metadata: name: gcsevent-test namespace: config-connector spec: name: demo-gcs # used as name or prefix for KCC objects workflowName: gcs-finalizer-workflow # Replace with your workflow path location: us-central1 # desired location project: my-project-name # Replace with your project name   They can then check the status of the applied resource:  kubectl get gcsbucketwithfinalizertrigger -n config-connector kubectl get gcsbucketwithfinalizertrigger gcsevent-test -n config-connector -o yaml   Navigate to GCS page in the GCP Console and verify the bucket creation. Also verify that the Triggers are setup correctly in the EventArc page.  Once done, the user can delete the GCSBucketWithFinalizerTrigger instance:  kubectl delete gcsbucketwithfinalizertrigger gcsevent-test -n config-connector   ","version":"0.6.3","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GCSBucketWithFinalizerTrigger","url":"/examples/gcp/eventarc#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gcsbucketwithfinalizertrigger.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gcsbucketwithfinalizertrigger.kro.run spec: schema: apiVersion: v1alpha1 kind: GCSBucketWithFinalizerTrigger spec: name: string workflowName: string location: string project: string status: url: ${bucket.status.url} resources: - id: storageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: storage-enablement spec: resourceID: storage.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: pubsubEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: pubsub-enablement spec: resourceID: pubsub.googleapis.com - id: eventarcEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: eventarc-enablement spec: resourceID: eventarc.googleapis.com - id: iamsa template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMServiceAccount metadata: labels: enabled-service: ${iamEnable.metadata.name} #annotations: # cnrm.cloud.google.com/project-id: ${schema.spec.project} name: ${schema.spec.name} spec: displayName: ${schema.spec.name}-eventarc-workflow - id: iampmEventarc template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-eventarc spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/eventarc.admin resourceRef: kind: Project external: ${schema.spec.project} - id: iampmWorkflow template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: ${schema.spec.name}-workflow spec: memberFrom: serviceAccountRef: name: ${iamsa.metadata.name} role: roles/workflows.admin resourceRef: kind: Project external: ${schema.spec.project} - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: enabled-service: ${pubsubEnable.metadata.name} name: ${schema.spec.name}-gcs-finalizer-topic - id: bucket template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageBucket metadata: labels: enabled-service: ${storageEnable.metadata.name} name: ${schema.spec.name}-${schema.spec.project} spec: uniformBucketLevelAccess: true - id: eventTrigger template: apiVersion: eventarc.cnrm.cloud.google.com/v1beta1 kind: EventarcTrigger metadata: labels: enabled-service: ${eventarcEnable.metadata.name} name: ${schema.spec.name}-gcsfinalizer spec: destination: workflowRef: external: &quot;projects/${schema.spec.project}/locations/${schema.spec.location}/workflows/${schema.spec.workflowName}&quot; location: ${schema.spec.location} serviceAccountRef: name: ${iamsa.metadata.name} transport: pubsub: topicRef: name: ${topic.metadata.name} namespace: config-connector matchingCriteria: - attribute: &quot;type&quot; value: &quot;google.cloud.pubsub.topic.v1.messagePublished&quot; projectRef: external: &quot;projects/${schema.spec.project}&quot; - id: storageNotification template: apiVersion: storage.cnrm.cloud.google.com/v1beta1 kind: StorageNotification metadata: name: ${schema.spec.name}-gcs spec: bucketRef: name: ${bucket.metadata.name} topicRef: name: ${topic.metadata.name} eventTypes: - &quot;OBJECT_FINALIZE&quot; payloadFormat: JSON_API_V1  ","version":"0.6.3","tagName":"h2"},{"title":"CloudSQL","type":0,"sectionRef":"#","url":"/examples/gcp/cloud-sql","content":"","keywords":"","version":"0.6.3"},{"title":"End User: CloudSQL​","type":1,"pageTitle":"CloudSQL","url":"/examples/gcp/cloud-sql#end-user-cloudsql","content":" The administrator needs to install the RGD first. The end user creates a CloudSQL resource that looks like this:  apiVersion: kro.run/v1alpha1 kind: CloudSQL metadata: name: demo namespace: config-connector spec: name: demo project: my-gcp-project primaryRegion: us-central1 replicaRegion: us-west1   The status of the applied resource can be checked using:  kubectl get cloudsqls kubectl get cloudsql demo -n config-connector -o yaml   Navigate to CloudSQL page in the GCP Console and verify the creation of primary and replica instances.  Once done, the user can delete the CloudSQL instance:  kubectl delete cloudsql demo -n config-connector   ","version":"0.6.3","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"CloudSQL","url":"/examples/gcp/cloud-sql#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  &gt; kubectl get rgd cloudsql.kro.run NAME APIVERSION KIND STATE AGE cloudsql.kro.run v1alpha1 CloudSQL Active 44m   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: cloudsql.kro.run spec: schema: apiVersion: v1alpha1 kind: CloudSQL spec: name: string project: string primaryRegion: string replicaRegion: string status: connectionName: ${sqlPrimary.status.connectionName} ipAddress: ${sqlPrimary.status.firstIpAddress} resources: - id: cloudkmsEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: cloudkms-enablement spec: resourceID: cloudkms.googleapis.com - id: iamEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: iam-enablement spec: resourceID: iam.googleapis.com - id: serviceUsageEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: serviceusage-enablement spec: resourceID: serviceusage.googleapis.com - id: sqlAdminEnable template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: Service metadata: annotations: cnrm.cloud.google.com/deletion-policy: &quot;abandon&quot; cnrm.cloud.google.com/disable-dependent-services: &quot;false&quot; name: sqladmin-enablement spec: resourceID: sqladmin.googleapis.com - id: serviceidentity template: apiVersion: serviceusage.cnrm.cloud.google.com/v1beta1 kind: ServiceIdentity metadata: labels: enabled-service: ${serviceUsageEnable.metadata.name} name: sqladmin.googleapis.com spec: projectRef: external: ${schema.spec.project} - id: keyringPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-primary spec: location: ${schema.spec.primaryRegion} - id: keyringReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} name: ${schema.spec.name}-replica spec: location: ${schema.spec.replicaRegion} - id: kmskeyPrimary template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.primaryRegion} name: ${schema.spec.name}-primary spec: keyRingRef: name: ${keyringPrimary.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: kmskeyReplica template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: enabled-service: ${cloudkmsEnable.metadata.name} failure-zone: ${schema.spec.replicaRegion} name: ${schema.spec.name}-replica spec: keyRingRef: name: ${keyringReplica.metadata.name} #namespace: {{ cloudsqls.metadata.namespace }} purpose: ENCRYPT_DECRYPT versionTemplate: algorithm: GOOGLE_SYMMETRIC_ENCRYPTION protectionLevel: SOFTWARE importOnly: false - id: iampolicymemberPrimary template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: labels: enabled-service: ${iamEnable.metadata.name} name: sql-kms-${schema.spec.primaryRegion}-policybinding spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyPrimary.metadata.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} - id: iampolicymemberReplica template: apiVersion: iam.cnrm.cloud.google.com/v1beta1 kind: IAMPolicyMember metadata: name: sql-kms-${schema.spec.replicaRegion}-policybinding labels: enabled-service: ${iamEnable.metadata.name} spec: member: serviceAccount:${serviceidentity.status.email} role: roles/cloudkms.cryptoKeyEncrypterDecrypter resourceRef: kind: KMSCryptoKey name: ${kmskeyReplica.metadata.name}-replica #namespace: {{ cloudsqls.metadata.namespace }} - id: sqlPrimary template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.primaryRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-primary spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.primaryRegion}/keyRings/${keyringPrimary.metadata.name}/cryptoKeys/${kmskeyPrimary.metadata.name} region: ${schema.spec.primaryRegion} settings: availabilityType: REGIONAL backupConfiguration: backupRetentionSettings: retainedBackups: 6 enabled: true location: us diskSize: 50 diskType: PD_SSD maintenanceWindow: day: 7 hour: 3 tier: db-custom-8-30720 - id: sqlReplica template: apiVersion: sql.cnrm.cloud.google.com/v1beta1 kind: SQLInstance metadata: annotations: cnrm.cloud.google.com/deletion-policy: abandon labels: failure-zone: ${schema.spec.replicaRegion} enabled-service: ${sqlAdminEnable.metadata.name} name: ${schema.spec.name}-replica spec: databaseVersion: POSTGRES_13 encryptionKMSCryptoKeyRef: external: projects/${schema.spec.project}/locations/${schema.spec.replicaRegion}/keyRings/${keyringReplica.metadata.name}/cryptoKeys/${kmskeyReplica.metadata.name} masterInstanceRef: name: ${schema.spec.name}-primary #namespace: {{ cloudsqls.metadata.namespace }} region: ${schema.spec.replicaRegion} settings: availabilityType: REGIONAL diskSize: 50 diskType: PD_SSD tier: db-custom-8-30720  ","version":"0.6.3","tagName":"h2"},{"title":"EKS Cluster","type":0,"sectionRef":"#","url":"/examples/aws/ack-eks-cluster","content":"EKS Cluster eks.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: ekscluster.kro.run spec: # CRD Schema schema: apiVersion: v1alpha1 kind: EKSCluster spec: name: string version: string status: networkingInfo: vpcID: ${clusterVPC.status.vpcID} subnetAZA: ${clusterSubnetA.status.subnetID} subnetAZB: ${clusterSubnetB.status.subnetID} clusterARN: ${cluster.status.ackResourceMetadata.arn} # resources resources: - id: clusterVPC readyWhen: - ${clusterVPC.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: kro-cluster-vpc spec: cidrBlocks: - 192.168.0.0/16 enableDNSSupport: true enableDNSHostnames: true - id: clusterElasticIPAddress template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: ElasticIPAddress metadata: name: kro-cluster-eip spec: {} - id: clusterInternetGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: InternetGateway metadata: name: kro-cluster-igw spec: vpc: ${clusterVPC.status.vpcID} - id: clusterRouteTable template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: RouteTable metadata: name: kro-cluster-public-route-table spec: vpcID: ${clusterVPC.status.vpcID} routes: - destinationCIDRBlock: 0.0.0.0/0 gatewayID: ${clusterInternetGateway.status.internetGatewayID} - id: clusterSubnetA readyWhen: - ${clusterSubnetA.status.state == &quot;available&quot;} template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet1 spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterSubnetB template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: kro-cluster-public-subnet2 spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} routeTables: - ${clusterRouteTable.status.routeTableID} mapPublicIPOnLaunch: true - id: clusterNATGateway template: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: NATGateway metadata: name: kro-cluster-natgateway1 spec: subnetID: ${clusterSubnetB.status.subnetID} allocationID: ${clusterElasticIPAddress.status.allocationID} - id: clusterRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-role spec: name: kro-cluster-role description: &quot;kro created cluster cluster role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterNodeRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-node-role spec: name: kro-cluster-node-role description: &quot;kro created cluster node role&quot; policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - id: clusterAdminRole template: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: kro-cluster-pia-role spec: name: kro-cluster-pia-role description: &quot;kro created cluster admin pia role&quot; policies: - arn:aws:iam::aws:policy/AdministratorAccess assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;AllowEksAuthToAssumeRoleForPodIdentity&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;pods.eks.amazonaws.com&quot; }, &quot;Action&quot;: [ &quot;sts:AssumeRole&quot;, &quot;sts:TagSession&quot; ] } ] } - id: cluster readyWhen: - ${cluster.status.status == &quot;ACTIVE&quot;} template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: ${schema.spec.name} spec: name: ${schema.spec.name} accessConfig: authenticationMode: API_AND_CONFIG_MAP roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: endpointPrivateAccess: false endpointPublicAccess: true subnetIDs: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} - id: clusterNodeGroup template: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: kro-cluster-nodegroup spec: name: kro-cluster-ng diskSize: 100 clusterName: ${cluster.spec.name} subnets: - ${clusterSubnetA.status.subnetID} - ${clusterSubnetB.status.subnetID} nodeRole: ${clusterNodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: 1 maxSize: 1 desiredSize: 1 ","keywords":"","version":"0.6.3"},{"title":"GKECluster","type":0,"sectionRef":"#","url":"/examples/gcp/gke-cluster","content":"","keywords":"","version":"0.6.3"},{"title":"End User: GKECluster​","type":1,"pageTitle":"GKECluster","url":"/examples/gcp/gke-cluster#end-user-gkecluster","content":" The administrator needs to install the RGD first. The end user creates a GKECluster resource something like this:  apiVersion: kro.run/v1alpha1 kind: GKECluster metadata: name: krodemo namespace: config-connector spec: name: krodemo # Name used for all resources created as part of this RGD location: us-central1 # Region where the GCP resources are created maxnodes: 4 # Max scaling limit for the nodes in the new nodepool   They can then check the status of the applied resource:  kubectl get gkeclusters kubectl get gkeclusters krodemo -n config-connector -o yaml   Navigate to GKE Cluster page in the GCP Console and verify the cluster creation.  Once done, the user can delete the GKECluster instance:  kubectl delete gkecluster krodemo -n config-connector   ","version":"0.6.3","tagName":"h2"},{"title":"Administrator: ResourceGraphDefinition​","type":1,"pageTitle":"GKECluster","url":"/examples/gcp/gke-cluster#administrator-resourcegraphdefinition","content":" The administrator needs to install the RGD in the cluster first before the user can consume it:  kubectl apply -f rgd.yaml   Validate the RGD is installed correctly:  kubectl get rgd gkecluster.kro.run   Once all user created instances are deleted, the administrator can choose to deleted the RGD.  ResourceGraphDefinition rgd.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: gkecluster.kro.run spec: schema: apiVersion: v1alpha1 kind: GKECluster spec: name: string nodepool: string maxnodes: integer location: string status: masterVersion: ${cluster.status.masterVersion} resources: - id: network template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeNetwork metadata: labels: source: &quot;gkecluster&quot; name: ${schema.spec.name} spec: #routingMode: GLOBAL #deleteDefaultRoutesOnCreate: false routingMode: REGIONAL autoCreateSubnetworks: false - id: subnet template: apiVersion: compute.cnrm.cloud.google.com/v1beta1 kind: ComputeSubnetwork metadata: labels: source: &quot;gkecluster&quot; name: ${network.metadata.name} spec: ipCidrRange: 10.2.0.0/16 #ipCidrRange: 10.10.90.0/24 region: ${schema.spec.location} networkRef: name: ${schema.spec.name} #privateIpGoogleAccess: true - id: topic template: apiVersion: pubsub.cnrm.cloud.google.com/v1beta1 kind: PubSubTopic metadata: labels: source: &quot;gkecluster&quot; name: ${subnet.metadata.name} - id: keyring template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSKeyRing metadata: labels: source: &quot;gkecluster&quot; name: ${topic.metadata.name} spec: location: ${schema.spec.location} - id: key template: apiVersion: kms.cnrm.cloud.google.com/v1beta1 kind: KMSCryptoKey metadata: labels: source: &quot;gkecluster&quot; name: ${keyring.metadata.name} spec: keyRingRef: name: ${schema.spec.name} purpose: ASYMMETRIC_SIGN versionTemplate: algorithm: EC_SIGN_P384_SHA384 protectionLevel: SOFTWARE importOnly: false - id: nodepool template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerNodePool metadata: labels: source: &quot;gkecluster&quot; name: ${cluster.metadata.name} spec: location: ${schema.spec.location} autoscaling: minNodeCount: 1 maxNodeCount: ${schema.spec.maxnodes} nodeConfig: machineType: n1-standard-1 diskSizeGb: 100 diskType: pd-standard #taint: #- effect: NO_SCHEDULE # key: originalKey # value: originalValue clusterRef: name: ${schema.spec.name} - id: cluster template: apiVersion: container.cnrm.cloud.google.com/v1beta1 kind: ContainerCluster metadata: #annotations: # cnrm.cloud.google.com/remove-default-node-pool: &quot;false&quot; labels: source: &quot;gkecluster&quot; name: ${key.metadata.name} spec: location: ${schema.spec.location} initialNodeCount: 1 networkRef: name: ${schema.spec.name} subnetworkRef: name: ${schema.spec.name} ipAllocationPolicy: clusterIpv4CidrBlock: /20 servicesIpv4CidrBlock: /20 #masterAuth: # clientCertificateConfig: # issueClientCertificate: false #workloadIdentityConfig: # # Workload Identity supports only a single namespace based on your project name. # # Replace ${PROJECT_ID?} below with your project ID. # workloadPool: ${PROJECT_ID?}.svc.id.goog notificationConfig: pubsub: enabled: true topicRef: name: ${schema.spec.name} loggingConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;WORKLOADS&quot; monitoringConfig: enableComponents: - &quot;SYSTEM_COMPONENTS&quot; - &quot;APISERVER&quot; managedPrometheus: enabled: true clusterAutoscaling: enabled: true autoscalingProfile: BALANCED resourceLimits: - resourceType: cpu maximum: 100 minimum: 10 - resourceType: memory maximum: 1000 minimum: 100 autoProvisioningDefaults: bootDiskKMSKeyRef: name: ${schema.spec.name} nodeConfig: linuxNodeConfig: sysctls: net.core.somaxconn: &quot;4096&quot; cgroupMode: &quot;CGROUP_MODE_UNSPECIFIED&quot;  ","version":"0.6.3","tagName":"h2"},{"title":"CoreDNS Deployment","type":0,"sectionRef":"#","url":"/examples/kubernetes/deploying-coredns","content":"CoreDNS Deployment coredns-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGraphDefinition metadata: name: coredns.kro.run spec: schema: apiVersion: v1alpha1 kind: CoreDNSDeployment spec: name: string | default=mycoredns namespace: string | default=default values: clusterRole: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/bootstrapping&quot;: &quot;rbac-defaults&quot;}' clusterRoleBinding: annotations: 'map[string]string | default={&quot;rbac.authorization.kubernetes.io/autoupdate&quot;: &quot;\\&quot;true\\&quot;&quot;}' configMap: labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;}' deployment: annotations: 'map[string]string | default={&quot;deployment.kubernetes.io/revision&quot;: &quot;\\&quot;1\\&quot;&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;coredns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' replicas: integer | default=2 image: repository: string | default=coredns/coredns tag: string | default=1.11.3 resources: limits: cpu: string | default=100m memory: string | default=128Mi requests: cpu: string | default=100m memory: string | default=128Mi service: annotations: 'map[string]string | default={&quot;prometheus.io/port&quot;: &quot;9153&quot;, &quot;prometheus.io/scrape&quot;: &quot;true&quot;}' labels: 'map[string]string | default={&quot;eks.amazonaws.com/component&quot;: &quot;kube-dns&quot;, &quot;k8s-app&quot;: &quot;kube-dns&quot;, &quot;kubernetes.io/cluster-service&quot;: &quot;true&quot;, &quot;kubernetes.io/name&quot;: &quot;CoreDNS&quot;}' clusterIP: string | default=10.100.123.45 clusterIPs: '[]string | default=[&quot;10.100.123.45&quot;]' ipFamilies: '[]string | default=[&quot;IPv4&quot;]' type: string | default=ClusterIP serviceAccount: secrets: 'map[string]string | default={&quot;name&quot;: &quot;coredns-token-pvcnf&quot;}' resources: - id: clusterRole template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} rules: - apiGroups: - &quot;&quot; resources: - endpoints - services - pods - namespaces verbs: - list - watch - apiGroups: - discovery.k8s.io resources: - endpointslices verbs: - list - watch - apiGroups: - &quot;&quot; resources: - nodes verbs: - get - id: clusterRoleBinding template: apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: ${schema.spec.name} labels: ${schema.spec.values.clusterRole.labels} annotations: ${schema.spec.values.clusterRoleBinding.annotations} roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: ${clusterRole.metadata.name} subjects: - kind: ServiceAccount name: ${serviceAccount.metadata.name} namespace: ${serviceAccount.metadata.namespace} - id: configMap template: apiVersion: v1 kind: ConfigMap metadata: name: ${schema.spec.name} labels: ${schema.spec.values.configMap.labels} data: Corefile: |- .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } - id: deployment template: apiVersion: apps/v1 kind: Deployment metadata: annotations: ${schema.spec.values.deployment.annotations} labels: ${schema.spec.values.deployment.labels} name: ${schema.spec.name} spec: replicas: ${schema.spec.values.deployment.replicas} selector: matchLabels: ${schema.spec.values.configMap.labels} template: metadata: labels: ${schema.spec.values.configMap.labels} spec: serviceAccountName: ${serviceAccount.metadata.name} containers: - name: &quot;coredns&quot; image: ${schema.spec.values.image.repository}:${schema.spec.values.image.tag} args: [&quot;-conf&quot;, &quot;/etc/coredns/Corefile&quot;] resources: ${schema.spec.values.resources} volumeMounts: - name: config-volume mountPath: /etc/coredns volumes: - name: config-volume configMap: name: ${schema.spec.name} items: - key: Corefile path: Corefile - id: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} labels: ${schema.spec.values.service.labels} annotations: ${schema.spec.values.service.annotations} spec: selector: k8s-app: kube-dns clusterIP: ${schema.spec.values.service.clusterIP} clusterIPs: ${schema.spec.values.service.clusterIPs} internalTrafficPolicy: Cluster ipFamilies: ${schema.spec.values.service.ipFamilies} ports: - name: dns port: 53 protocol: UDP targetPort: 53 - name: dns-tcp port: 53 protocol: TCP targetPort: 53 selector: k8s-app: kube-dns sessionAffinity: None - id: serviceAccount template: apiVersion: v1 kind: ServiceAccount metadata: name: ${schema.spec.name} namespace: ${schema.spec.namespace} labels: ${schema.spec.values.configMap.labels} secrets: - ${schema.spec.values.serviceAccount.secrets} ","keywords":"","version":"0.6.3"}],"options":{"id":"default"}}