"use strict";(self.webpackChunkkro_docs=self.webpackChunkkro_docs||[]).push([[8121],{87292:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"docs/concepts/rgd/dependencies-ordering","title":"Graph Inference","description":"kro automatically infers dependencies from CEL expressions. You don\'t specify the order - you describe relationships, and kro figures out the rest.","source":"@site/versioned_docs/version-0.7.0/docs/concepts/rgd/04-dependencies-ordering.md","sourceDirName":"docs/concepts/rgd","slug":"/docs/concepts/rgd/dependencies-ordering","permalink":"/kro/0.7.0/docs/concepts/rgd/dependencies-ordering","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-sigs/kro/tree/main/website/versioned_docs/version-0.7.0/docs/concepts/rgd/04-dependencies-ordering.md","tags":[],"version":"0.7.0","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"CEL Expressions","permalink":"/kro/0.7.0/docs/concepts/rgd/cel-expressions"},"next":{"title":"Static Analysis","permalink":"/kro/0.7.0/docs/concepts/rgd/static-type-checking"}}');var a=r(74848),t=r(28453),i=r(11470),c=r(19365);const o={sidebar_position:4},l="Graph Inference",d={},p=[{value:"How It Works",id:"how-it-works",level:2},{value:"Dependency Graph (DAG)",id:"dependency-graph-dag",level:2},{value:"Common Patterns",id:"common-patterns",level:3},{value:"Topological Order",id:"topological-order",level:2},{value:"Circular Dependencies",id:"circular-dependencies",level:2},{value:"What Happens at Runtime",id:"what-happens-at-runtime",level:2},{value:"Next Steps",id:"next-steps",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"graph-inference",children:"Graph Inference"})}),"\n",(0,a.jsx)(n.p,{children:"kro automatically infers dependencies from CEL expressions. You don't specify the order - you describe relationships, and kro figures out the rest."}),"\n",(0,a.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,a.jsx)(n.p,{children:"When you reference one resource from another using a CEL expression, you create a dependency:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"resources:\n  - id: configmap\n    template:\n      apiVersion: v1\n      kind: ConfigMap\n      metadata:\n        name: app-config\n      data:\n        DATABASE_URL: ${schema.spec.dbUrl}\n\n  - id: deployment\n    template:\n      apiVersion: apps/v1\n      kind: Deployment\n      spec:\n        containers:\n          - env:\n              - name: DATABASE_URL\n                value: ${configmap.data.DATABASE_URL}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The expression ",(0,a.jsx)(n.code,{children:"${configmap.data.DATABASE_URL}"})," creates a dependency: ",(0,a.jsx)(n.code,{children:"deployment"})," depends on ",(0,a.jsx)(n.code,{children:"configmap"}),". kro will create the configmap first, wait for the expression to be resolvable, then create the deployment."]}),"\n",(0,a.jsx)(n.h2,{id:"dependency-graph-dag",children:"Dependency Graph (DAG)"}),"\n",(0,a.jsx)(n.p,{children:"kro builds a Directed Acyclic Graph (DAG) where:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Nodes"})," are resources"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Edges"})," are dependencies (created by CEL references)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Directed"})," means dependencies have direction (A depends on B)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Acyclic"})," means no circular dependencies"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,a.jsx)(n.p,{children:"Dependency graphs follow common patterns that you'll encounter in most RGDs. Understanding these patterns helps you design effective resource relationships. Real-world RGDs often combine multiple patterns - a complex application might have parallel branches that converge into a diamond, followed by a linear chain."}),"\n","\n",(0,a.jsxs)(i.A,{children:[(0,a.jsxs)(c.A,{value:"linear",label:"Linear Chain",default:!0,children:[(0,a.jsx)(n.p,{children:"In a linear chain, each resource depends on the previous one. This pattern is common when you have a sequence of resources where each step requires data from the previous step - like a ConfigMap that feeds into a Deployment, which then informs a Service."}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"configmap \u2500\u2500\u25b6 deployment \u2500\u2500\u25b6 service\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"resources:\n  - id: configmap\n    template:\n      apiVersion: v1\n      kind: ConfigMap\n      data:\n        key: ${schema.spec.value}\n\n  - id: deployment\n    template:\n      apiVersion: apps/v1\n      kind: Deployment\n      spec:\n        template:\n          spec:\n            containers:\n              - envFrom:\n                  - configMapRef:\n                      name: ${configmap.metadata.name}\n\n  - id: service\n    template:\n      apiVersion: v1\n      kind: Service\n      spec:\n        selector: ${deployment.spec.selector.matchLabels}\n"})}),(0,a.jsxs)(n.p,{children:["The deployment references ",(0,a.jsx)(n.code,{children:"${configmap.metadata.name}"}),", creating a dependency. The service references ",(0,a.jsx)(n.code,{children:"${deployment.spec.selector.matchLabels}"}),", adding another link. kro creates them in sequence: configmap first, then deployment, then service."]})]}),(0,a.jsxs)(c.A,{value:"diamond",label:"Diamond",children:[(0,a.jsx)(n.p,{children:"In a diamond pattern, multiple independent resources converge into a single dependent resource. This is typical for applications that need multiple backing services - like an app that requires both a database and a cache before it can start."}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  schema  \u2502\n       \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u25bc             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502database \u2502   \u2502  cache  \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n     \u2502             \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u25bc\n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502   app   \u2502\n       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"resources:\n  - id: database\n    template:\n      apiVersion: databases.example.com/v1\n      kind: PostgreSQL\n      spec:\n        name: ${schema.spec.name}-db\n\n  - id: cache\n    template:\n      apiVersion: caches.example.com/v1\n      kind: Redis\n      spec:\n        name: ${schema.spec.name}-cache\n\n  - id: app\n    template:\n      apiVersion: apps/v1\n      kind: Deployment\n      spec:\n        template:\n          spec:\n            containers:\n              - env:\n                  - name: DATABASE_URL\n                    value: ${database.status.endpoint}\n                  - name: CACHE_URL\n                    value: ${cache.status.endpoint}\n"})}),(0,a.jsxs)(n.p,{children:["Both ",(0,a.jsx)(n.code,{children:"database"})," and ",(0,a.jsx)(n.code,{children:"cache"})," only reference ",(0,a.jsx)(n.code,{children:"schema"}),", so kro creates them in parallel. The ",(0,a.jsx)(n.code,{children:"app"})," references both ",(0,a.jsx)(n.code,{children:"${database.status.endpoint}"})," and ",(0,a.jsx)(n.code,{children:"${cache.status.endpoint}"}),", so it waits for both to be ready before being created."]})]}),(0,a.jsxs)(c.A,{value:"parallel",label:"Parallel Branches",children:[(0,a.jsxs)(n.p,{children:["When resources only reference ",(0,a.jsx)(n.code,{children:"schema"})," (not each other), they have no interdependencies and kro creates them concurrently. This maximizes deployment speed for independent components like multiple microservices or worker pools."]}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502  schema  \u2502\n       \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u25bc         \u25bc         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 api \u2502 \u2502worker \u2502 \u2502 cron \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"resources:\n  - id: api\n    template:\n      apiVersion: apps/v1\n      kind: Deployment\n      metadata:\n        name: ${schema.spec.name}-api\n\n  - id: worker\n    template:\n      apiVersion: apps/v1\n      kind: Deployment\n      metadata:\n        name: ${schema.spec.name}-worker\n\n  - id: cron\n    template:\n      apiVersion: batch/v1\n      kind: CronJob\n      metadata:\n        name: ${schema.spec.name}-cron\n"})}),(0,a.jsxs)(n.p,{children:["All three resources only reference ",(0,a.jsx)(n.code,{children:"${schema.spec.name}"}),", meaning they have no dependencies on each other. kro creates all of them simultaneously, reducing overall deployment time."]})]})]}),"\n",(0,a.jsx)(n.admonition,{title:"Combining Patterns",type:"tip",children:(0,a.jsx)(n.p,{children:"Real-world RGDs typically combine multiple patterns. A complex application might have parallel branches (independent microservices), a diamond (services converging into a gateway), and linear chains (each service with its own config \u2192 deployment \u2192 service sequence). kro handles any valid DAG structure - these patterns are just common building blocks."})}),"\n",(0,a.jsx)(n.h2,{id:"topological-order",children:"Topological Order"}),"\n",(0,a.jsx)(n.p,{children:"kro computes a topological order - the sequence resources can be processed such that all dependencies are satisfied."}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Creation:"})," Resources created in topological order\n",(0,a.jsx)(n.strong,{children:"Deletion:"})," Resources deleted in reverse order"]}),"\n",(0,a.jsx)(n.p,{children:"View the computed order:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"kubectl get rgd my-app -o jsonpath='{.status.topologicalOrder}'\n"})}),"\n",(0,a.jsx)(n.p,{children:"Example output:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"status:\n  topologicalOrder:\n    - configmap\n    - deployment\n    - service\n"})}),"\n",(0,a.jsx)(n.h2,{id:"circular-dependencies",children:"Circular Dependencies"}),"\n",(0,a.jsx)(n.p,{children:"Circular dependencies are not allowed and will cause validation to fail:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"# \u2717 This will fail\nresources:\n  - id: serviceA\n    template:\n      spec:\n        targetPort: ${serviceB.spec.port}  # A \u2192 B\n\n  - id: serviceB\n    template:\n      spec:\n        targetPort: ${serviceA.spec.port}  # B \u2192 A (circular!)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Fix:"})," Break the cycle by using ",(0,a.jsx)(n.code,{children:"schema.spec"})," instead:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"resources:\n  - id: serviceA\n    template:\n      spec:\n        targetPort: ${schema.spec.portA}  # Use schema\n\n  - id: serviceB\n    template:\n      spec:\n        targetPort: ${serviceA.spec.port}  # This is fine\n"})}),"\n",(0,a.jsx)(n.h2,{id:"what-happens-at-runtime",children:"What Happens at Runtime"}),"\n",(0,a.jsx)(n.p,{children:"When kro reconciles an instance:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Evaluate static expressions"})," - Expressions referencing only ",(0,a.jsx)(n.code,{children:"schema.spec"})," are evaluated once"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Process in topological order"})," - For each resource:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Wait for all dependency expressions to be resolvable"}),"\n",(0,a.jsx)(n.li,{children:"Create or update the resource"}),"\n",(0,a.jsx)(n.li,{children:"Move to next resource in order"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Delete in reverse order"})," - During deletion, process resources backwards"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["kro waits for CEL expressions to be ",(0,a.jsx)(n.strong,{children:"resolvable"})," before proceeding. This means the referenced resource exists and has the field being accessed."]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/kro/0.7.0/docs/concepts/rgd/resource-definitions/readiness",children:"Readiness"})})," - Control when resources are considered ready with ",(0,a.jsx)(n.code,{children:"readyWhen"})]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/kro/0.7.0/docs/concepts/rgd/cel-expressions",children:"CEL Expressions"})})," - Learn more about writing expressions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.a,{href:"/kro/0.7.0/docs/concepts/rgd/resource-definitions/resource-basics",children:"Resource Basics"})})," - Learn about resource templates"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},19365:(e,n,r)=>{r.d(n,{A:()=>i});r(96540);var s=r(34164);const a={tabItem:"tabItem_Ymn6"};var t=r(74848);function i({children:e,hidden:n,className:r}){return(0,t.jsx)("div",{role:"tabpanel",className:(0,s.A)(a.tabItem,r),hidden:n,children:e})}},11470:(e,n,r)=>{r.d(n,{A:()=>w});var s=r(96540),a=r(34164),t=r(17559),i=r(23104),c=r(56347),o=r(205),l=r(57485),d=r(31682),p=r(70679);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:r}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return h(e).map((({props:{value:e,label:n,attributes:r,default:s}})=>({value:e,label:n,attributes:r,default:s})))}(r);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,r])}function m({value:e,tabValues:n}){return n.some((n=>n.value===e))}function x({queryString:e=!1,groupId:n}){const r=(0,c.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(a),(0,s.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(r.location.search);n.set(a,e),r.replace({...r.location,search:n.toString()})}),[a,r])]}function g(e){const{defaultValue:n,queryString:r=!1,groupId:a}=e,t=u(e),[i,c]=(0,s.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:t}))),[l,d]=x({queryString:r,groupId:a}),[h,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[r,a]=(0,p.Dv)(n);return[r,(0,s.useCallback)((e=>{n&&a.set(e)}),[n,a])]}({groupId:a}),f=(()=>{const e=l??h;return m({value:e,tabValues:t})?e:null})();(0,o.A)((()=>{f&&c(f)}),[f]);return{selectedValue:i,selectValue:(0,s.useCallback)((e=>{if(!m({value:e,tabValues:t}))throw new Error(`Can't select invalid tab value=${e}`);c(e),d(e),g(e)}),[d,g,t]),tabValues:t}}var f=r(92303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=r(74848);function j({className:e,block:n,selectedValue:r,selectValue:s,tabValues:t}){const c=[],{blockElementScrollPositionUntilNextRender:o}=(0,i.a_)(),l=e=>{const n=e.currentTarget,a=c.indexOf(n),i=t[a].value;i!==r&&(o(n),s(i))},d=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const r=c.indexOf(e.currentTarget)+1;n=c[r]??c[0];break}case"ArrowLeft":{const r=c.indexOf(e.currentTarget)-1;n=c[r]??c[c.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:t.map((({value:e,label:n,attributes:s})=>(0,b.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{c.push(e)},onKeyDown:d,onClick:l,...s,className:(0,a.A)("tabs__item",v.tabItem,s?.className,{"tabs__item--active":r===e}),children:n??e},e)))})}function y({lazy:e,children:n,selectedValue:r}){const t=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=t.find((e=>e.props.value===r));return e?(0,s.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:t.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function k(e){const n=g(e);return(0,b.jsxs)("div",{className:(0,a.A)(t.G.tabs.container,"tabs-container",v.tabList),children:[(0,b.jsx)(j,{...n,...e}),(0,b.jsx)(y,{...n,...e})]})}function w(e){const n=(0,f.A)();return(0,b.jsx)(k,{...e,children:h(e.children)},String(n))}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>c});var s=r(96540);const a={},t=s.createContext(a);function i(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);