"use strict";(self.webpackChunkkro_docs=self.webpackChunkkro_docs||[]).push([[9198],{38316:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"docs/concepts/resource-group-definitions","title":"ResourceGraphDefinitions","description":"ResourceGraphDefinitions are the fundamental building blocks in kro. They provide a","source":"@site/versioned_docs/version-0.2.1/docs/concepts/00-resource-group-definitions.md","sourceDirName":"docs/concepts","slug":"/docs/concepts/resource-group-definitions","permalink":"/kro/0.2.1/docs/concepts/resource-group-definitions","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-sigs/kro/tree/main/website/versioned_docs/version-0.2.1/docs/concepts/00-resource-group-definitions.md","tags":[],"version":"0.2.1","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Concepts"},"next":{"title":"Simple Schema","permalink":"/kro/0.2.1/docs/concepts/simple-schema"}}');var r=s(74848),o=s(28453);const t={sidebar_position:1},a="ResourceGraphDefinitions",c={},l=[{value:"What is a ResourceGraphDefinition?",id:"what-is-a-resourcegraphdefinition",level:2},{value:"Anatomy of a ResourceGraphDefinition",id:"anatomy-of-a-resourcegraphdefinition",level:2},{value:"Understanding the Schema",id:"understanding-the-schema",level:2},{value:"ResourceGraphDefinition Processing",id:"resourcegraphdefinition-processing",level:2},{value:"ResourceGraphDefinition Instance Example",id:"resourcegraphdefinition-instance-example",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"resourcegraphdefinitions",children:"ResourceGraphDefinitions"})}),"\n",(0,r.jsxs)(n.p,{children:["ResourceGraphDefinitions are the fundamental building blocks in ",(0,r.jsx)(n.strong,{children:"kro"}),". They provide a\nway to define, organize, and manage sets of related Kubernetes resources as a\nsingle, reusable unit."]}),"\n",(0,r.jsx)(n.h2,{id:"what-is-a-resourcegraphdefinition",children:"What is a ResourceGraphDefinition?"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"})," is a custom resource that lets you create new Kubernetes\nAPIs for deploying multiple resources together. It acts as a blueprint,\ndefining:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"What users can configure (schema)"}),"\n",(0,r.jsx)(n.li,{children:"What resources to create (resources)"}),"\n",(0,r.jsx)(n.li,{children:"How resources reference each other (dependencies)"}),"\n",(0,r.jsx)(n.li,{children:"When resources should be included (conditions)"}),"\n",(0,r.jsx)(n.li,{children:"What status to expose (status)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["When you create a ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"}),", kro generates a new API (a.k.a Custom\nResource Definition) in your cluster that others can use to deploy resources in a\nconsistent, controlled way."]}),"\n",(0,r.jsx)(n.h2,{id:"anatomy-of-a-resourcegraphdefinition",children:"Anatomy of a ResourceGraphDefinition"}),"\n",(0,r.jsx)(n.p,{children:"A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Metadata"}),": name, namespace, labels, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Spec"}),": Defines the structure and properties of the ResourceGraphDefinition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Status"}),": Reflects the current state of the ResourceGraphDefinition"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"spec"})," section of a ResourceGraphDefinition contains two main components:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Schema"}),": Defines what an instance of your API looks like:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"What users can configure during creation and update"}),"\n",(0,r.jsx)(n.li,{children:"What status information they can view"}),"\n",(0,r.jsx)(n.li,{children:"Default values and validation rules"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resources"}),": Specifies the Kubernetes resources to create:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Resource templates"}),"\n",(0,r.jsx)(n.li,{children:"Dependencies between resources"}),"\n",(0,r.jsx)(n.li,{children:"Conditions for inclusion"}),"\n",(0,r.jsx)(n.li,{children:"Readiness criteria"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This structure translates to YAML as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"apiVersion: kro.run/v1alpha1\nkind: ResourceGraphDefinition\nmetadata:\n  name: my-resourcegraphdefinition # Metadata section\nspec:\n  schema: # Define your API\n    apiVersion: v1alpha1 # API version\n    kind: MyAPI # API kind\n    spec: {} # fields users can configure\n    status: {} # fields kro will populate\n\n  # Define the resources kro will manage\n  resources:\n    - id: resource1\n      # declare your resources along with default values and variables\n      template: {}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Let's look at each component in detail..."}),"\n",(0,r.jsx)(n.h2,{id:"understanding-the-schema",children:"Understanding the Schema"}),"\n",(0,r.jsx)(n.p,{children:"The schema section defines your new API's structure. It determines:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"What fields users can configure when creating instances"}),"\n",(0,r.jsx)(n.li,{children:"What status information they can view"}),"\n",(0,r.jsx)(n.li,{children:"Type validation and default values"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Here's an example schema:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'schema:\n  apiVersion: v1alpha1\n  kind: WebApplication # This becomes your new API type\n  spec:\n    # Fields users can configure using a simple, straightforward syntax\n    name: string\n    image: string | default="nginx"\n    replicas: integer | default=3\n    ingress:\n      enabled: boolean | default=false\n\n  status:\n    # Fields kro will populate automatically from your resources\n    # Types are inferred from these CEL expressions\n    availableReplicas: ${deployment.status.availableReplicas}\n    conditions: ${deployment.status.conditions}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"kro"})," follows a different approach for defining your API schema and shapes. It\nleverages a human-friendly and readable syntax that is OpenAPI spec compatible.\nNo need to write complex OpenAPI schemas - just define your fields and types in\na straightforward way. For the complete specification of this format, check out\nthe ",(0,r.jsx)(n.a,{href:"/kro/0.2.1/docs/concepts/simple-schema",children:"Simple Schema specification"}),". Status fields use CEL\nexpressions to reference fields from resources defined in your ResourceGraphDefinition.\nkro automatically:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Infers the correct types from your expressions"}),"\n",(0,r.jsx)(n.li,{children:"Validates that referenced resources exist"}),"\n",(0,r.jsx)(n.li,{children:"Updates these fields as your resources change"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"resourcegraphdefinition-processing",children:"ResourceGraphDefinition Processing"}),"\n",(0,r.jsxs)(n.p,{children:["When you create a ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"}),", kro processes it in several steps to ensure\ncorrectness and set up the necessary components:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Validation"}),": kro validates your ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"})," to ensure it's well\nformed and follows the correct syntax, maximizing the chances of successful\ndeployment, and catching as many errors as possible early on. It:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Validates your schema definition follows the simple schema format"}),"\n",(0,r.jsx)(n.li,{children:"Ensures all resource templates are valid Kubernetes manifests"}),"\n",(0,r.jsx)(n.li,{children:"Checks that referenced values exist and are of the correct type"}),"\n",(0,r.jsx)(n.li,{children:"Confirms resource dependencies form a valid Directed Acycled Graph(DAG)\nwithout cycles"}),"\n",(0,r.jsx)(n.li,{children:"Validates all CEL expressions in status fields and conditions"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"API Generation"}),": kro generates and registers a new CRD in your cluster\nbased on your schema. For example, if your ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"})," defines a\n",(0,r.jsx)(n.code,{children:"WebApplication"})," API, kro creates a CRD that:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Provides API validation based on your schema definition"}),"\n",(0,r.jsx)(n.li,{children:"Automatically applies default values you've defined"}),"\n",(0,r.jsx)(n.li,{children:"Makes status information available to users and other systems"}),"\n",(0,r.jsx)(n.li,{children:"Integrates seamlessly with kubectl and other Kubernetes tools"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Controller Configuration"}),": kro configures itself to watch for instances of\nyour new API and:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Creates all required resources following the dependency order"}),"\n",(0,r.jsx)(n.li,{children:"Manages references and value passing between resources"}),"\n",(0,r.jsx)(n.li,{children:"Handles the complete lifecycle for create, update, and delete operations"}),"\n",(0,r.jsx)(n.li,{children:"Keeps status information up to date based on actual resource states"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For instance, when you create a ",(0,r.jsx)(n.code,{children:"WebApplication"})," ResourceGraphDefinition, kro generates\nthe ",(0,r.jsx)(n.code,{children:"webapplications.kro.run"})," CRD. When users create instances of this API, kro\nmanages all the underlying resources (Deployments, Services, Custom Resources,\netc.) automatically."]}),"\n",(0,r.jsx)(n.p,{children:"kro continuously monitors your ResourceGraphDefinition for changes, updating the API and\nits behavior accordingly."}),"\n",(0,r.jsx)(n.h2,{id:"resourcegraphdefinition-instance-example",children:"ResourceGraphDefinition Instance Example"}),"\n",(0,r.jsxs)(n.p,{children:["After the ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"})," is validated and registered in the cluster, users\ncan can create instances of it. Here's an example of how an instance for the\n",(0,r.jsx)(n.code,{children:"SimpleWebApp"})," might look:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="my-web-app-instance.yaml"',children:"apiVersion: kro.run/v1alpha1\nkind: SimpleWebApp\nmetadata:\n  name: my-web-app\nspec:\n  appName: awesome-app\n  image: nginx:latest\n  replicas: 3\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(96540);const r={},o=i.createContext(r);function t(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);