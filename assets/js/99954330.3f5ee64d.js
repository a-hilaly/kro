"use strict";(self.webpackChunkkro_docs=self.webpackChunkkro_docs||[]).push([[1865],{59809:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"docs/concepts/resource-group-definitions","title":"ResourceGraphDefinitions","description":"ResourceGraphDefinitions are the fundamental building blocks in kro. They provide a","source":"@site/versioned_docs/version-0.5.0/docs/concepts/00-resource-group-definitions.md","sourceDirName":"docs/concepts","slug":"/docs/concepts/resource-group-definitions","permalink":"/0.5.0/docs/concepts/resource-group-definitions","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-sigs/kro/tree/main/website/versioned_docs/version-0.5.0/docs/concepts/00-resource-group-definitions.md","tags":[],"version":"0.5.0","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Deploy Your First ResourceGraphDefinition","permalink":"/0.5.0/docs/getting-started/deploy-a-resource-graph-definition"},"next":{"title":"Simple Schema","permalink":"/0.5.0/docs/concepts/simple-schema"}}');var r=s(74848),t=s(28453);const o={sidebar_position:1},a="ResourceGraphDefinitions",c={},l=[{value:"What is a ResourceGraphDefinition?",id:"what-is-a-resourcegraphdefinition",level:2},{value:"Anatomy of a ResourceGraphDefinition",id:"anatomy-of-a-resourcegraphdefinition",level:2},{value:"Understanding the Schema",id:"understanding-the-schema",level:2},{value:"Processing",id:"processing",level:2},{value:"Instance Example",id:"instance-example",level:2},{value:"More about Resources",id:"more-about-resources",level:2},{value:"Using <code>externalRef</code> to reference Objects outside the ResourceGraphDefinition.",id:"using-externalref-to-reference-objects-outside-the-resourcegraphdefinition",level:3},{value:"Using Conditional CEL Expressions (<code>?</code>)",id:"using-conditional-cel-expressions-",level:3},{value:"Using <code>?</code> for referencing schema-less objects like <code>ConfigMap</code> or <code>Secret</code>",id:"using--for-referencing-schema-less-objects-like-configmap-or-secret",level:4},{value:"Status Reporting",id:"status-reporting",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"resourcegraphdefinitions",children:"ResourceGraphDefinitions"})}),"\n",(0,r.jsxs)(n.p,{children:["ResourceGraphDefinitions are the fundamental building blocks in ",(0,r.jsx)(n.strong,{children:"kro"}),". They provide a\nway to define, organize, and manage sets of related Kubernetes resources as a\nsingle, reusable unit."]}),"\n",(0,r.jsx)(n.h2,{id:"what-is-a-resourcegraphdefinition",children:"What is a ResourceGraphDefinition?"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"})," is a custom resource that lets you create new Kubernetes\nAPIs for deploying multiple resources together. It acts as a blueprint,\ndefining:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"What users can configure (schema)"}),"\n",(0,r.jsx)(n.li,{children:"What resources to create (resources)"}),"\n",(0,r.jsx)(n.li,{children:"How resources reference each other (dependencies)"}),"\n",(0,r.jsx)(n.li,{children:"When resources should be included (conditions)"}),"\n",(0,r.jsx)(n.li,{children:"What status to expose (status)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["When you create a ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"}),", kro generates a new API (a.k.a Custom\nResource Definition) in your cluster that others can use to deploy resources in a\nconsistent, controlled way."]}),"\n",(0,r.jsx)(n.h2,{id:"anatomy-of-a-resourcegraphdefinition",children:"Anatomy of a ResourceGraphDefinition"}),"\n",(0,r.jsx)(n.p,{children:"A ResourceGraphDefinition, like any Kubernetes resource, consists of three main parts:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Metadata"}),": name, labels, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Spec"}),": Defines the structure and properties of the ResourceGraphDefinition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Status"}),": Reflects the current state of the ResourceGraphDefinition"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"spec"})," section of a ResourceGraphDefinition contains two main components:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Schema"}),": Defines what an instance of your API looks like:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"What users can configure during creation and update"}),"\n",(0,r.jsx)(n.li,{children:"What status information they can view"}),"\n",(0,r.jsx)(n.li,{children:"Default values and validation rules"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resources"}),": Specifies the Kubernetes resources to create:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Resource templates"}),"\n",(0,r.jsx)(n.li,{children:"Dependencies between resources"}),"\n",(0,r.jsx)(n.li,{children:"Conditions for inclusion"}),"\n",(0,r.jsx)(n.li,{children:"Readiness criteria"}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#using-externalref-to-reference-objects-outside-the-resourcegraphdefinition",children:"External References"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This structure translates to YAML as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"apiVersion: kro.run/v1alpha1\nkind: ResourceGraphDefinition\nmetadata:\n  name: my-resourcegraphdefinition # Metadata section\nspec:\n  schema: # Define your API\n    apiVersion: v1alpha1 # API version\n    kind: MyAPI # API kind\n    spec: {} # fields users can configure\n    status: {} # fields kro will populate\n\n  # Define the resources kro will manage\n  resources:\n    - id: resource1\n      # declare your resources along with default values and variables\n      template: {}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Let's look at each component in detail..."}),"\n",(0,r.jsx)(n.h2,{id:"understanding-the-schema",children:"Understanding the Schema"}),"\n",(0,r.jsx)(n.p,{children:"The schema section defines your new API's structure. It determines:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"What fields users can configure when creating instances"}),"\n",(0,r.jsx)(n.li,{children:"What status information they can view"}),"\n",(0,r.jsx)(n.li,{children:"Type validation and default values"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Here's an example schema:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'schema:\n  apiVersion: v1alpha1\n  kind: WebApplication # This becomes your new API type\n  spec:\n    # Fields users can configure using a simple, straightforward syntax\n    name: string\n    image: string | default="nginx"\n    replicas: integer | default=3\n    ingress:\n      enabled: boolean | default=false\n\n  status:\n    # Fields kro will populate automatically from your resources\n    # Types are inferred from these CEL expressions\n    availableReplicas: ${deployment.status.availableReplicas}\n    conditions: ${deployment.status.conditions}\n\n  validation:\n    # Validating admission policies added to the new API type\'s CRD\n    - expression: "${ self.image == \'nginx\' || !self.ingress.enabled }"\n      message: "Only nginx based applications can have ingress enabled"\n\n  additionalPrinterColumns:\n    # Printer columns shown for the created custom resource\n    - jsonPath: .status.availableReplicas\n      name: Available replicas\n      type: integer\n    - jsonPath: .spec.image\n      name: Image\n      type: string\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"kro"})," follows a different approach for defining your API schema and shapes. It\nleverages a human-friendly and readable syntax that is OpenAPI spec compatible.\nNo need to write complex OpenAPI schemas - just define your fields and types in\na straightforward way. For the complete specification of this format, check out\nthe ",(0,r.jsx)(n.a,{href:"/0.5.0/docs/concepts/simple-schema",children:"Simple Schema specification"}),". Status fields use CEL\nexpressions to reference fields from resources defined in your ResourceGraphDefinition.\nkro automatically:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Infers the correct types from your expressions"}),"\n",(0,r.jsx)(n.li,{children:"Validates that referenced resources exist"}),"\n",(0,r.jsx)(n.li,{children:"Updates these fields as your resources change"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"processing",children:"Processing"}),"\n",(0,r.jsxs)(n.p,{children:["When you create a ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"}),", kro processes it in several steps to ensure\ncorrectness and set up the necessary components:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Validation"}),": kro validates your ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"})," to ensure it's well\nformed and follows the correct syntax, maximizing the chances of successful\ndeployment, and catching as many errors as possible early on. It:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Validates your schema definition follows the simple schema format"}),"\n",(0,r.jsx)(n.li,{children:"Ensures all resource templates are valid Kubernetes manifests"}),"\n",(0,r.jsx)(n.li,{children:"Checks that referenced values exist and are of the correct type"}),"\n",(0,r.jsx)(n.li,{children:"Confirms resource dependencies form a valid Directed Acyclic Graph(DAG)\nwithout cycles"}),"\n",(0,r.jsx)(n.li,{children:"Validates all CEL expressions in status fields and conditions"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"API Generation"}),": kro generates and registers a new CRD in your cluster\nbased on your schema. For example, if your ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"})," defines a\n",(0,r.jsx)(n.code,{children:"WebApplication"})," API, kro creates a CRD that:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Provides API validation based on your schema definition"}),"\n",(0,r.jsx)(n.li,{children:"Automatically applies default values you've defined"}),"\n",(0,r.jsx)(n.li,{children:"Makes status information available to users and other systems"}),"\n",(0,r.jsx)(n.li,{children:"Integrates seamlessly with kubectl and other Kubernetes tools"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Controller Configuration"}),": kro configures itself to watch for instances of\nyour new API and:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Creates all required resources following the dependency order"}),"\n",(0,r.jsx)(n.li,{children:"Manages references and value passing between resources"}),"\n",(0,r.jsx)(n.li,{children:"Handles the complete lifecycle for create, update, and delete operations"}),"\n",(0,r.jsx)(n.li,{children:"Keeps status information up to date based on actual resource states"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For instance, when you create a ",(0,r.jsx)(n.code,{children:"WebApplication"})," ResourceGraphDefinition, kro generates\nthe ",(0,r.jsx)(n.code,{children:"webapplications.kro.run"})," CRD. When users create instances of this API, kro\nmanages all the underlying resources (Deployments, Services, Custom Resources,\netc.) automatically."]}),"\n",(0,r.jsx)(n.p,{children:"kro continuously monitors your ResourceGraphDefinition for changes, updating the API and\nits behavior accordingly."}),"\n",(0,r.jsx)(n.h2,{id:"instance-example",children:"Instance Example"}),"\n",(0,r.jsxs)(n.p,{children:["After the ",(0,r.jsx)(n.strong,{children:"ResourceGraphDefinition"})," is validated and registered in the cluster, users\ncan create instances of it. Here's an example of how an instance for the\n",(0,r.jsx)(n.code,{children:"WebApplication"})," might look:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="my-web-app-instance.yaml"',children:"apiVersion: kro.run/v1alpha1\nkind: WebApplication\nmetadata:\n  name: my-web-app\nspec:\n  appName: awesome-app\n  image: nginx:latest\n  replicas: 3\n"})}),"\n",(0,r.jsx)(n.h2,{id:"more-about-resources",children:"More about Resources"}),"\n",(0,r.jsxs)(n.p,{children:["Users can specify more controls in resources in ",(0,r.jsx)(n.code,{children:".spec.resources[]"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"spec:\n  resources:\n    - id: my-resource\n      template || externalRef: {} # users can either template resources or reference objects outside the graph\n      readyWhen:\n      # users can specify CEL expressions to determine when a resource is ready\n      - ${deployment.status.conditions.exists(x, x.type == 'Available' && x.status == \"True\")}\n      includeWhen:\n      # users can specify CEL expressions to determine when a resource should be included in the graph\n      - ${schema.spec.value.enabled}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"using-externalref-to-reference-objects-outside-the-resourcegraphdefinition",children:["Using ",(0,r.jsx)(n.code,{children:"externalRef"})," to reference Objects outside the ResourceGraphDefinition."]}),"\n",(0,r.jsx)(n.p,{children:"Users can specify if the object is something that is created out-of-band and needs to be referenced in the RGD.\nAn external reference could be specified like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"resources:\n   id: projectConfig\n   externalRef:\n     apiVersion: corp.platform.com/v1\n     kind: Project\n     metadata:\n       name: default-project\n       namespace: # optional, if empty uses instance namespace\n"})}),"\n",(0,r.jsxs)(n.p,{children:["As part of processing the Resource Graph, the instance reconciler waits for the ",(0,r.jsx)(n.code,{children:"externalRef"})," object to be present and reads the object from the cluster as a node in the graph. Subsequent resources can use data from this node."]}),"\n",(0,r.jsxs)(n.h3,{id:"using-conditional-cel-expressions-",children:["Using Conditional CEL Expressions (",(0,r.jsx)(n.code,{children:"?"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["KRO can make use of CEL Expressions (see ",(0,r.jsx)(n.a,{href:"https://github.com/google/cel-spec/wiki/proposal-246",children:"this proposal for details"})," or look at the ",(0,r.jsx)(n.a,{href:"https://pkg.go.dev/github.com/google/cel-go/cel#hdr-Syntax_Changes-OptionalTypes",children:"CEL Implementation Reference"}),") to define optional runtime conditions for resources based on the conditional operator ",(0,r.jsx)(n.code,{children:"?"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"This allows you to optionally define values that have no predefined schema or are not hard dependencies in the Graph."}),"\n",(0,r.jsxs)(n.h4,{id:"using--for-referencing-schema-less-objects-like-configmap-or-secret",children:["Using ",(0,r.jsx)(n.code,{children:"?"})," for referencing schema-less objects like ",(0,r.jsx)(n.code,{children:"ConfigMap"})," or ",(0,r.jsx)(n.code,{children:"Secret"})]}),"\n",(0,r.jsxs)(n.p,{children:["You can use the ",(0,r.jsx)(n.code,{children:"optional"})," operator to reference objects that do not have a predefined schema in the ResourceGraphDefinition. This is useful for referencing objects that may or may not exist at runtime."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["\u26a0\ufe0f"," ",(0,r.jsx)(n.code,{children:"?"})," removes the ability of KRO to introspect the schema of the referenced object. Thus, it cannot wait for fields after the ",(0,r.jsx)(n.code,{children:"?"})," to be present. It is recommended to use conditional expressions only for objects that are not critical to the ResourceGraphDefinition's operation or when the schema cannot be known at design time."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"A config map can be referenced like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="config-map.yaml"',children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: demo\ndata:\n  VALUE: "foobar"\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'title="external reference in ResourceGraphDefinition"',children:"- id: external\n  externalRef:\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: demo\n      namespace: default\n"})}),"\n",(0,r.jsx)(n.p,{children:"With this reference, you can access the data in your schema:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",metastring:'title="CEL Expression"',children:"${external.data.?VALUE}\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["\u26a0\ufe0f"," KRO will only wait for the external reference to be present in the cluster, but it will not validate the schema of the referenced config. If the config map does not have the ",(0,r.jsx)(n.code,{children:"VALUE"})," field, the expression will evaluate to ",(0,r.jsx)(n.code,{children:"null"})," and might result in unexpected behavior in your application if not handled properly."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["For a more detailed example, see the ",(0,r.jsx)(n.a,{href:"/0.5.0/examples/basic/optionals",children:"Optional Values & External References"})," documentation."]})}),"\n",(0,r.jsx)(n.h2,{id:"status-reporting",children:"Status Reporting"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"status"})," section of a ",(0,r.jsx)(n.code,{children:"ResourceGraphDefinition"})," provides information about the state of the graph and it's generated ",(0,r.jsx)(n.code,{children:"CustomResourceDefinition"})," and controller."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"status"})," includes a stable ",(0,r.jsx)(n.code,{children:"Ready"})," condition (as well as a set of technical ",(0,r.jsx)(n.code,{children:"status.conditions"})," that provide more detailed information about the state of the graph and its resources)."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["When the ",(0,r.jsx)(n.code,{children:"Ready"})," condition ",(0,r.jsx)(n.code,{children:"status"})," is ",(0,r.jsx)(n.code,{children:"True"}),", it indicates that the ResourceGraphDefinition is valid and you can use it to create ",(0,r.jsx)(n.a,{href:"/0.5.0/docs/concepts/instances",children:"instances"}),"."]})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Try to only rely on the ",(0,r.jsx)(n.code,{children:"Ready"})," condition, as other condition types may change frequently and are more technical in nature, can change their API over time and are generally more indicative of KRO's internal state."]})}),"\n",(0,r.jsxs)(n.p,{children:["Additionally, the ResourceGraphDefinition contains a ",(0,r.jsx)(n.code,{children:"topologicalOrder"})," field that provides a list of resources in the order they should be processed. This is useful for understanding the dependencies between resources and their apply order."]}),"\n",(0,r.jsxs)(n.p,{children:["Generally a status in ",(0,r.jsx)(n.code,{children:"ResourceGraphDefinition"})," may look like"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'status:\n  conditions:\n    - lastTransitionTime: "2025-08-06T17:26:41Z"\n      message: resource graph and schema are valid\n      observedGeneration: 1\n      reason: Valid\n      status: "True"\n      type: ResourceGraphAccepted\n    - lastTransitionTime: "2025-08-06T17:26:41Z"\n      message: kind DeploymentService has been accepted and ready\n      observedGeneration: 1\n      reason: Ready\n      status: "True"\n      type: KindReady\n    - lastTransitionTime: "2025-08-06T17:26:41Z"\n      message: controller is running\n      observedGeneration: 1\n      reason: Running\n      status: "True"\n      type: ControllerReady\n    - lastTransitionTime: "2025-08-06T17:26:41Z"\n      message: ""\n      observedGeneration: 1\n      reason: Ready\n      status: "True"\n      type: Ready\n  state: Active\n  topologicalOrder:\n    - configmap\n    - deployment\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var i=s(96540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);