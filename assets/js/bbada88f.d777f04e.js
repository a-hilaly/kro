"use strict";(self.webpackChunkkro_docs=self.webpackChunkkro_docs||[]).push([[989],{14705:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"docs/concepts/rgd/static-type-checking","title":"Static Analysis","description":"One of kro\'s most powerful features is static analysis. When you create or update a ResourceGraphDefinition, kro performs extensive validation before accepting it. This analysis happens at the API level\u2014before any instances of your custom resource are created or reconciled.","source":"@site/docs/docs/concepts/rgd/05-static-type-checking.md","sourceDirName":"docs/concepts/rgd","slug":"/docs/concepts/rgd/static-type-checking","permalink":"/kro/next/docs/concepts/rgd/static-type-checking","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-sigs/kro/tree/main/website/docs/docs/concepts/rgd/05-static-type-checking.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Graph Inference","permalink":"/kro/next/docs/concepts/rgd/dependencies-ordering"},"next":{"title":"Instances","permalink":"/kro/next/docs/concepts/instances"}}');var r=n(74848),t=n(28453);const a={sidebar_position:7},c="Static Analysis",l={},d=[{value:"The Validation Process",id:"the-validation-process",level:2},{value:"Stage 1: Schema Validation",id:"stage-1-schema-validation",level:3},{value:"Stage 2: Status Schema Inference",id:"stage-2-status-schema-inference",level:3},{value:"Stage 3: Resource Naming Validation",id:"stage-3-resource-naming-validation",level:3},{value:"Stage 4: Resource Template Validation",id:"stage-4-resource-template-validation",level:3},{value:"Stage 5: AST Analysis and Dependency Graph Building",id:"stage-5-ast-analysis-and-dependency-graph-building",level:3},{value:"Stage 6: Expression Type Checking",id:"stage-6-expression-type-checking",level:3},{value:"Stage 7: Condition Expression Validation",id:"stage-7-condition-expression-validation",level:3},{value:"Stage 8: RGD Activation",id:"stage-8-rgd-activation",level:3},{value:"CEL AST Parsing and Dependency Detection",id:"cel-ast-parsing-and-dependency-detection",level:2},{value:"How AST Parsing Works",id:"how-ast-parsing-works",level:3},{value:"Dependency Graph Construction",id:"dependency-graph-construction",level:3},{value:"Reference Validation",id:"reference-validation",level:3},{value:"Circular Dependency Detection",id:"circular-dependency-detection",level:3},{value:"Type Compatibility Deep Dive",id:"type-compatibility-deep-dive",level:2},{value:"Structural Compatibility",id:"structural-compatibility",level:3},{value:"Map/Struct Compatibility",id:"mapstruct-compatibility",level:3},{value:"Nested Field Type Checking",id:"nested-field-type-checking",level:3},{value:"PreserveUnknownFields Handling",id:"preserveunknownfields-handling",level:3},{value:"Next Steps",id:"next-steps",level:2}];function o(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"static-analysis",children:"Static Analysis"})}),"\n",(0,r.jsxs)(s.p,{children:["One of kro's most powerful features is ",(0,r.jsx)(s.strong,{children:"static analysis"}),". When you create or update a ResourceGraphDefinition, kro performs extensive validation before accepting it. This analysis happens at the API level\u2014before any instances of your custom resource are created or reconciled."]}),"\n",(0,r.jsx)(s.p,{children:"Static analysis catches errors early: invalid CEL syntax, references to non-existent resources or fields, type mismatches, circular dependencies, and schema violations. Without this upfront validation, these errors would only surface during reconciliation when kro attempts to create resources in your cluster. This means immediate feedback during development instead of runtime failures."}),"\n",(0,r.jsx)(s.p,{children:"kro achieves this by integrating directly with Kubernetes OpenAPI schemas. For every resource in your graph\u2014whether built-in types like Deployments or custom CRDs\u2014kro fetches the schema and validates your templates against it. This ensures CEL expressions reference actual fields, output types match target field expectations, and your entire resource graph is structurally sound."}),"\n",(0,r.jsx)(s.h2,{id:"the-validation-process",children:"The Validation Process"}),"\n",(0,r.jsx)(s.p,{children:"When you create or update a ResourceGraphDefinition, kro performs validation in multiple stages:"}),"\n",(0,r.jsx)("div",{style:{marginTop:"3rem",marginBottom:"3rem"},children:(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"kro validation pipeline stages",src:n(56561).A+"",width:"2797",height:"1157"})})}),"\n",(0,r.jsx)(s.h3,{id:"stage-1-schema-validation",children:"Stage 1: Schema Validation"}),"\n",(0,r.jsx)(s.p,{children:"kro starts by validating your custom API schema:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Parses your SimpleSchema definition"})," - Reads the schema from ",(0,r.jsx)(s.code,{children:"spec.schema"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Converts to OpenAPI schema"})," - Transforms SimpleSchema to standard OpenAPI format"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Validates the CRD spec"})," - Ensures the generated CRD specification is valid"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"spec:\n  schema:\n    spec:\n      # kro validates this schema definition\n      replicas: integer | default=3\n      ports: array\n      labels: object\n"})}),"\n",(0,r.jsx)(s.h3,{id:"stage-2-status-schema-inference",children:"Stage 2: Status Schema Inference"}),"\n",(0,r.jsxs)(s.p,{children:["For your custom API's ",(0,r.jsx)(s.code,{children:"status"})," field, kro automatically infers the schema from CEL expressions:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"status:\n  endpoint: ${service.status.loadBalancer.ingress[0].hostname}\n  replicas: ${deployment.status.availableReplicas}\n"})}),"\n",(0,r.jsx)(s.p,{children:"kro inspects these expressions, determines their output types, and generates the OpenAPI schema for your status field automatically. This means you don't need to manually define status field types\u2014kro figures them out from your CEL expressions."}),"\n",(0,r.jsx)(s.h3,{id:"stage-3-resource-naming-validation",children:"Stage 3: Resource Naming Validation"}),"\n",(0,r.jsx)(s.p,{children:"kro validates that all resource IDs are valid CEL identifiers. Resource IDs must be valid variable names in CEL\u2014no hyphens, special characters, or starting with numbers."}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Why?"})," CEL uses resource IDs as variables (like ",(0,r.jsx)(s.code,{children:"${deployment.spec.replicas}"}),"). Invalid identifiers would cause CEL syntax errors."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# \u2713 Valid IDs\nresources:\n  - id: deployment\n  - id: configMap\n  - id: servicePrimary\n\n# \u2717 Invalid IDs\nresources:\n  - id: my-deployment  # Hyphens not allowed (CEL subtraction operator)\n  - id: 1st-service    # Can't start with number\n"})}),"\n",(0,r.jsx)(s.h3,{id:"stage-4-resource-template-validation",children:"Stage 4: Resource Template Validation"}),"\n",(0,r.jsx)(s.p,{children:"For each resource template, kro:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Validates basic Kubernetes object structure"})," - Ensures the template has required fields like ",(0,r.jsx)(s.code,{children:"apiVersion"}),", ",(0,r.jsx)(s.code,{children:"kind"}),", and ",(0,r.jsx)(s.code,{children:"metadata"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Resolves the OpenAPI schema"})," - Gets the schema from the API server for the resource type. This works for both built-in Kubernetes resources (like Deployments and Services) and Custom Resource Definitions installed in your cluster."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Extracts CEL expressions and determines expected types"})," - For each field in the template:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"If the field contains a CEL expression"}),": kro extracts the expression and determines what type the target field expects based on the OpenAPI schema"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"If the field is a literal value"}),": kro performs standard OpenAPI validation, just like the kube-api-server does"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"resources:\n  - id: deployment\n    template:\n      apiVersion: apps/v1  # kro fetches Deployment schema\n      kind: Deployment\n      # ... validates template against Deployment schema\n"})}),"\n",(0,r.jsx)(s.h3,{id:"stage-5-ast-analysis-and-dependency-graph-building",children:"Stage 5: AST Analysis and Dependency Graph Building"}),"\n",(0,r.jsx)(s.p,{children:"kro analyzes the Abstract Syntax Tree (AST) of all CEL expressions to understand how they reference each other:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Parses CEL expressions into ASTs"})," - Converts each expression into its abstract syntax tree representation"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Analyzes references"})," - Identifies what each expression references (schema fields, other resources, functions)"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Validates references"})," - Checks that referenced resources exist in the DAG and functions are declared"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Builds the dependency graph"})," - Creates a directed acyclic graph showing which resources depend on which"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Detects circular dependencies"})," - Identifies any cycles in the dependency graph"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["At this stage, kro already knows if you're referencing something that doesn't exist or using undeclared functions, and has detected any circular dependencies. See ",(0,r.jsx)(s.a,{href:"#cel-ast-parsing-and-dependency-detection",children:"CEL AST Parsing and Dependency Detection"})," for technical details."]}),"\n",(0,r.jsx)(s.h3,{id:"stage-6-expression-type-checking",children:"Stage 6: Expression Type Checking"}),"\n",(0,r.jsx)(s.p,{children:"With expressions extracted and the dependency graph built, kro now performs comprehensive type checking on each CEL expression:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Type-checks the expression"})," - kro uses CEL's type checker to validate the expression against the typed environment containing all resource schemas. This verifies that all field accesses, function calls, and operations are valid and type-safe."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Infers the expression's output type"})," - Based on the type checking results, kro determines what type the expression will produce. For ",(0,r.jsx)(s.code,{children:"${schema.spec.replicas}"}),", kro infers an integer. For ",(0,r.jsx)(s.code,{children:'${schema.spec.name + "-deployment"}'}),", kro infers a string."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Validates type compatibility"})," - kro compares the inferred output type against the expected type (determined earlier from the target field's OpenAPI schema). First, it tries CEL's built-in type assignability check. If that fails, it performs deep structural compatibility checking, which handles complex cases like map/struct conversions and subset validation. See ",(0,r.jsx)(s.a,{href:"#type-compatibility-deep-dive",children:"Type Compatibility Deep Dive"})," for technical details."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.strong,{children:"Example:"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# Expression: ${schema.spec.replicas}\n# Inferred output type: integer (from schema.spec definition)\n# Expected type: integer (from Deployment.spec.replicas schema)\n# Result: \u2713 Compatible\n"})}),"\n",(0,r.jsx)(s.h3,{id:"stage-7-condition-expression-validation",children:"Stage 7: Condition Expression Validation"}),"\n",(0,r.jsx)(s.p,{children:"kro validates special condition expressions used in resource lifecycle control:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:["Validates ",(0,r.jsx)(s.code,{children:"readyWhen"})," expressions"]})," - Ensures readiness conditions are valid CEL expressions that return boolean values"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsxs)(s.strong,{children:["Validates ",(0,r.jsx)(s.code,{children:"includeWhen"})," expressions"]})," - Ensures conditional inclusion expressions are valid CEL expressions that return boolean values"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["These conditions control when resources are considered ready and whether they should be created at all, so they must always return ",(0,r.jsx)(s.code,{children:"true"})," or ",(0,r.jsx)(s.code,{children:"false"}),"."]}),"\n",(0,r.jsx)(s.h3,{id:"stage-8-rgd-activation",children:"Stage 8: RGD Activation"}),"\n",(0,r.jsx)(s.p,{children:"If all validation stages pass, kro activates the ResourceGraphDefinition:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Infers topological order"})," - Computes the order in which resources will be created based on the dependency graph"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Registers the CRD"})," - Creates the Custom Resource Definition in the cluster for your new API"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Starts the microcontroller"})," - Registers the controller that will reconcile instances of your custom resource"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Begins serving instances"})," - Your ResourceGraphDefinition is now ready to accept instance creation requests"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"At this point, the RGD is fully validated and operational. When users create instances of your custom API, kro will orchestrate the resources according to the validated graph."}),"\n",(0,r.jsx)(s.h2,{id:"cel-ast-parsing-and-dependency-detection",children:"CEL AST Parsing and Dependency Detection"}),"\n",(0,r.jsx)(s.p,{children:"During Stage 5, kro parses every CEL expression into an Abstract Syntax Tree (AST) and analyzes how expressions reference each other. This enables kro to build a complete dependency graph and detect issues before any resources are created."}),"\n",(0,r.jsx)(s.h3,{id:"how-ast-parsing-works",children:"How AST Parsing Works"}),"\n",(0,r.jsxs)(s.p,{children:["When kro encounters a CEL expression like ",(0,r.jsx)(s.code,{children:"${deployment.spec.replicas}"}),", it:"]}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Parses the expression into an AST"})," - The CEL parser breaks down the expression into its component parts: an identifier (",(0,r.jsx)(s.code,{children:"deployment"}),"), a field access (",(0,r.jsx)(s.code,{children:".spec"}),"), and another field access (",(0,r.jsx)(s.code,{children:".replicas"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Walks the AST to find references"})," - kro traverses the tree to identify what the expression references:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Root identifiers (",(0,r.jsx)(s.code,{children:"schema"}),", ",(0,r.jsx)(s.code,{children:"deployment"}),", ",(0,r.jsx)(s.code,{children:"configmap"}),", etc.)"]}),"\n",(0,r.jsxs)(s.li,{children:["Field accesses (",(0,r.jsx)(s.code,{children:".spec"}),", ",(0,r.jsx)(s.code,{children:".data"}),", ",(0,r.jsx)(s.code,{children:".status"}),")"]}),"\n",(0,r.jsxs)(s.li,{children:["Function calls (",(0,r.jsx)(s.code,{children:"size()"}),", ",(0,r.jsx)(s.code,{children:"string()"}),", etc.)"]}),"\n",(0,r.jsxs)(s.li,{children:["Operators (",(0,r.jsx)(s.code,{children:"+"}),", ",(0,r.jsx)(s.code,{children:"*"}),", ",(0,r.jsx)(s.code,{children:"?"}),", etc.)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Validates references exist"})," - For each identifier found:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["If it's ",(0,r.jsx)(s.code,{children:"schema"}),", kro validates the field path exists in your custom schema"]}),"\n",(0,r.jsx)(s.li,{children:"If it's a resource ID, kro checks that resource is defined in the DAG"}),"\n",(0,r.jsx)(s.li,{children:"If it's a function, kro validates it's a declared CEL function"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Builds dependency edges"})," - When resource B references resource A, kro adds an edge A \u2192 B in the dependency graph"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"dependency-graph-construction",children:"Dependency Graph Construction"}),"\n",(0,r.jsx)(s.p,{children:"kro builds a directed acyclic graph (DAG) showing which resources depend on which:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"resources:\n  - id: configmap\n    template:\n      data:\n        key: ${schema.spec.value}  # depends on: schema\n\n  - id: deployment\n    template:\n      spec:\n        replicas: ${schema.spec.replicas}  # depends on: schema\n        env:\n          - value: ${configmap.data.key}    # depends on: configmap\n"})}),"\n",(0,r.jsx)(s.p,{children:"kro builds this dependency graph:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"schema\n  \u251c\u2500\u2192 configmap\n  \u2514\u2500\u2192 deployment\n        \u2514\u2500\u2192 configmap\n"})}),"\n",(0,r.jsx)(s.p,{children:"This graph determines:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Creation order"}),": configmap before deployment"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Evaluation dependencies"}),": deployment expressions can only be evaluated after configmap exists"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Circular dependency detection"}),": kro validates there are no cycles"]}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"reference-validation",children:"Reference Validation"}),"\n",(0,r.jsx)(s.p,{children:"kro validates all references during AST analysis:"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Resource references"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# \u2713 Valid: deployment exists\nvalue: ${deployment.spec.replicas}\n\n# \u2717 Invalid: typo in resource ID\nvalue: ${deployent.spec.replicas}  # Error: resource 'deployent' not found\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Function references"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# \u2713 Valid: size() is a CEL builtin\ncondition: ${schema.spec.items.size() > 0}\n\n# \u2717 Invalid: undefined function\ncondition: ${schema.spec.items.length()}  # Error: function 'length' not declared\n"})}),"\n",(0,r.jsx)(s.h3,{id:"circular-dependency-detection",children:"Circular Dependency Detection"}),"\n",(0,r.jsx)(s.p,{children:"kro detects circular dependencies by checking for cycles in the DAG:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# \u2717 This fails validation\nresources:\n  - id: serviceA\n    template:\n      spec:\n        port: ${serviceB.spec.targetPort}  # A \u2192 B\n\n  - id: serviceB\n    template:\n      spec:\n        targetPort: ${serviceA.spec.port}  # B \u2192 A (cycle!)\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Error: ",(0,r.jsx)(s.code,{children:"circular dependency detected: serviceA \u2192 serviceB \u2192 serviceA"})]}),"\n",(0,r.jsx)(s.h2,{id:"type-compatibility-deep-dive",children:"Type Compatibility Deep Dive"}),"\n",(0,r.jsx)(s.p,{children:"During Stage 6, kro performs deep structural type compatibility checking. This goes beyond simple type matching to handle complex Kubernetes schemas through recursive comparison of type structures."}),"\n",(0,r.jsx)(s.h3,{id:"structural-compatibility",children:"Structural Compatibility"}),"\n",(0,r.jsx)(s.p,{children:"kro doesn't just check if types have the same name\u2014it performs deep structural comparison:"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"For primitives"}),": Checks kind equality (int, string, bool, etc.)"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"For lists"}),": Recursively checks element type compatibility"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# Expression returns: list<int>\n# Field expects: list<int>\n# Result: \u2713 Compatible\n\n# Expression returns: list<string>\n# Field expects: list<int>\n# Result: \u2717 Incompatible - element types don't match\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"For maps"}),": Recursively checks key and value type compatibility"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# Expression returns: map<string, int>\n# Field expects: map<string, int>\n# Result: \u2713 Compatible\n\n# Expression returns: map<string, string>\n# Field expects: map<string, int>\n# Result: \u2717 Incompatible - value types don't match\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"For structs"}),": Validates that the output struct is a subset of the expected struct (subset semantics)"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# Expression returns: {name: string, replicas: int}\n# Field expects: {name: string, replicas: int}\n# Result: \u2713 Compatible (exact match)\n\n# Expression returns: {name: string}\n# Field expects: {name: string, replicas: int}\n# Result: \u2713 Compatible (output is subset - missing fields are OK)\n\n# Expression returns: {name: string, replicas: int, extra: string}\n# Field expects: {name: string, replicas: int}\n# Result: \u2717 Incompatible (output has extra field 'extra' not in expected)\n"})}),"\n",(0,r.jsx)(s.h3,{id:"mapstruct-compatibility",children:"Map/Struct Compatibility"}),"\n",(0,r.jsx)(s.p,{children:"Kubernetes often treats maps and structs interchangeably (like labels, annotations, data fields). kro handles this intelligently:"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Map \u2192 Struct assignment"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# Expression: ${schema.spec.labels} (type: map<string, string>)\n# Target field: labels (type: struct with string fields)\n# kro validates: map keys are strings, map values match struct field types\n# Result: \u2713 Compatible if all struct fields accept strings\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Struct \u2192 Map assignment"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# Expression: ${configmap.data} (type: struct with dynamic fields)\n# Target field: data (type: map<string, string>)\n# kro validates: all struct fields are string-compatible\n# Result: \u2713 Compatible if struct \u2192 map conversion is valid\n"})}),"\n",(0,r.jsx)(s.h3,{id:"nested-field-type-checking",children:"Nested Field Type Checking"}),"\n",(0,r.jsx)(s.p,{children:"kro validates types at any depth by recursively walking the type structure:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"spec:\n  template:\n    spec:\n      containers:\n        - env:\n            - name: PORT\n              # Expression returns: int\n              # Field path: spec.template.spec.containers[].env[].value\n              # Field expects: string\n              # kro resolves the full nested path and checks compatibility\n              value: ${schema.spec.port}  # \u2717 Type error: int \u2192 string\n"})}),"\n",(0,r.jsx)(s.h3,{id:"preserveunknownfields-handling",children:"PreserveUnknownFields Handling"}),"\n",(0,r.jsxs)(s.p,{children:["For fields with ",(0,r.jsx)(s.code,{children:"x-kubernetes-preserve-unknown-fields: true"}),", kro uses permissive validation:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:"# ConfigMap.data has PreserveUnknownFields\nconfigmap:\n  data:\n    # kro cannot validate structure at build time\n    # Any expression type is accepted\n    DATABASE_URL: ${schema.spec.dbUrl}\n    PORT: ${string(schema.spec.port)}\n"})}),"\n",(0,r.jsx)(s.p,{children:"kro still validates:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Expression syntax is correct"}),"\n",(0,r.jsx)(s.li,{children:"Referenced resources exist"}),"\n",(0,r.jsx)(s.li,{children:"Types are internally consistent"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"But it cannot validate:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Field names are correct"}),"\n",(0,r.jsx)(s.li,{children:"Field types match (since schema is unknown)"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.a,{href:"/kro/next/docs/concepts/rgd/resource-definitions/resource-basics",children:"Resource Basics"})})," - See how templates are validated"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.a,{href:"/kro/next/docs/concepts/rgd/cel-expressions",children:"CEL Expressions"})})," - Learn CEL type system"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.a,{href:"/kro/next/api/specifications/simple-schema",children:"SimpleSchema"})})," - Define typed schemas"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},56561:(e,s,n)=>{n.d(s,{A:()=>i});const i=n.p+"assets/images/stages-eb9f2fdf6ce1ff557234ec4d34ea4c49.svg"},28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>c});var i=n(96540);const r={},t=i.createContext(r);function a(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);