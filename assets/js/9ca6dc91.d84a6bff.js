"use strict";(self.webpackChunkkro_docs=self.webpackChunkkro_docs||[]).push([[2995],{83359:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>t,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"docs/concepts/resource-groups","title":"ResourceGroups","description":"ResourceGroups are the fundamental building blocks in kro. They provide a","source":"@site/versioned_docs/version-0.1.0/docs/concepts/00-resource-groups.md","sourceDirName":"docs/concepts","slug":"/docs/concepts/resource-groups","permalink":"/0.1.0/docs/concepts/resource-groups","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-sigs/kro/tree/main/website/versioned_docs/version-0.1.0/docs/concepts/00-resource-groups.md","tags":[],"version":"0.1.0","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Concepts"},"next":{"title":"Simple Schema","permalink":"/0.1.0/docs/concepts/simple-schema"}}');var o=n(74848),i=n(28453);const a={sidebar_position:1},t="ResourceGroups",c={},l=[{value:"What is a ResourceGroup?",id:"what-is-a-resourcegroup",level:2},{value:"Anatomy of a ResourceGroup",id:"anatomy-of-a-resourcegroup",level:2},{value:"Understanding the Schema",id:"understanding-the-schema",level:2},{value:"ResourceGroup Processing",id:"resourcegroup-processing",level:2},{value:"ResourceGroup Instance Example",id:"resourcegroup-instance-example",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"resourcegroups",children:"ResourceGroups"})}),"\n",(0,o.jsxs)(s.p,{children:["ResourceGroups are the fundamental building blocks in ",(0,o.jsx)(s.strong,{children:"kro"}),". They provide a\nway to define, organize, and manage sets of related Kubernetes resources as a\nsingle, reusable unit."]}),"\n",(0,o.jsx)(s.h2,{id:"what-is-a-resourcegroup",children:"What is a ResourceGroup?"}),"\n",(0,o.jsxs)(s.p,{children:["A ",(0,o.jsx)(s.strong,{children:"ResourceGroup"})," is a custom resource that lets you create new Kubernetes\nAPIs for deploying multiple resources together. It acts as a blueprint,\ndefining:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"What users can configure (schema)"}),"\n",(0,o.jsx)(s.li,{children:"What resources to create (resources)"}),"\n",(0,o.jsx)(s.li,{children:"How resources reference each other (dependencies)"}),"\n",(0,o.jsx)(s.li,{children:"When resources should be included (conditions)"}),"\n",(0,o.jsx)(s.li,{children:"What status to expose (status)"}),"\n"]}),"\n",(0,o.jsxs)(s.p,{children:["When you create a ",(0,o.jsx)(s.strong,{children:"ResourceGroup"}),", kro generates a new API (a.k.a Custom\nResource Defintion) in your cluster that others can use to deploy resources in a\nconsistent, controlled way."]}),"\n",(0,o.jsx)(s.h2,{id:"anatomy-of-a-resourcegroup",children:"Anatomy of a ResourceGroup"}),"\n",(0,o.jsx)(s.p,{children:"A ResourceGroup, like any Kubernetes resource, consists of three main parts:"}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Metadata"}),": name, namespace, labels, etc."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Spec"}),": Defines the structure and properties of the ResourceGroup"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Status"}),": Reflects the current state of the ResourceGroup"]}),"\n"]}),"\n",(0,o.jsxs)(s.p,{children:["The ",(0,o.jsx)(s.code,{children:"spec"})," section of a ResourceGroup contains two main components:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Schema"}),": Defines what an instance of your API looks like:","\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"What users can configure during creation and update"}),"\n",(0,o.jsx)(s.li,{children:"What status information they can view"}),"\n",(0,o.jsx)(s.li,{children:"Default values and validation rules"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Resources"}),": Specifies the Kubernetes resources to create:","\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Resource templates"}),"\n",(0,o.jsx)(s.li,{children:"Dependencies between resources"}),"\n",(0,o.jsx)(s.li,{children:"Conditions for inclusion"}),"\n",(0,o.jsx)(s.li,{children:"Readiness criteria"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:"This structure translates to YAML as follows:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-yaml",children:"apiVersion: kro.run/v1alpha1\nkind: ResourceGroup\nmetadata:\n  name: my-resourcegroup # Metadata section\nspec:\n  schema: # Define your API\n    apiVersion: v1alpha1 # API version\n    kind: MyAPI # API kind\n    spec: {} # fields users can configure\n    status: {} # fields kro will populate\n\n  # Define the resources kro will manage\n  resources:\n    - id: resource1\n      # declare your resources along with default values and variables\n      template: {}\n"})}),"\n",(0,o.jsx)(s.p,{children:"Let's look at each component in detail..."}),"\n",(0,o.jsx)(s.h2,{id:"understanding-the-schema",children:"Understanding the Schema"}),"\n",(0,o.jsx)(s.p,{children:"The schema section defines your new API's structure. It determines:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"What fields users can configure when creating instances"}),"\n",(0,o.jsx)(s.li,{children:"What status information they can view"}),"\n",(0,o.jsx)(s.li,{children:"Type validation and default values"}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:"Here's an example schema:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-yaml",children:'schema:\n  apiVersion: v1alpha1\n  kind: WebApplication # This becomes your new API type\n  spec:\n    # Fields users can configure using a simple, straightforward syntax\n    name: string\n    image: string | default="nginx"\n    replicas: integer | default=3\n    ingress:\n      enabled: boolean | default=false\n\n  status:\n    # Fields kro will populate automatically from your resources\n    # Types are inferred from these CEL expressions\n    availableReplicas: ${deployment.status.availableReplicas}\n    conditions: ${deployment.status.conditions}\n'})}),"\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"kro"})," follows a different approach for defining your API schema and shapes. It\nleverages a human-friendly and readable syntax that is OpenAPI spec compatible.\nNo need to write complex OpenAPI schemas - just define your fields and types in\na straightforward way. For the complete specification of this format, check out\nthe ",(0,o.jsx)(s.a,{href:"/0.1.0/docs/concepts/simple-schema",children:"Simple Schema specification"}),". Status fields use CEL\nexpressions to reference fields from resources defined in your ResourceGroup.\nkro automatically:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Infers the correct types from your expressions"}),"\n",(0,o.jsx)(s.li,{children:"Validates that referenced resources exist"}),"\n",(0,o.jsx)(s.li,{children:"Updates these fields as your resources change"}),"\n"]}),"\n",(0,o.jsx)(s.h2,{id:"resourcegroup-processing",children:"ResourceGroup Processing"}),"\n",(0,o.jsxs)(s.p,{children:["When you create a ",(0,o.jsx)(s.strong,{children:"ResourceGroup"}),", kro processes it in several steps to ensure\ncorrectness and set up the necessary components:"]}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Validation"}),": kro validates your ",(0,o.jsx)(s.strong,{children:"ResourceGroup"})," to ensure it's well\nformed and follows the correct syntax, maximizing the chances of successful\ndeployment, and catching as many errors as possible early on. It:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Validates your schema definition follows the simple schema format"}),"\n",(0,o.jsx)(s.li,{children:"Ensures all resource templates are valid Kubernetes manifests"}),"\n",(0,o.jsx)(s.li,{children:"Checks that referenced values exist and are of the correct type"}),"\n",(0,o.jsx)(s.li,{children:"Confirms resource dependencies form a valid Directed Acycled Graph(DAG)\nwithout cycles"}),"\n",(0,o.jsx)(s.li,{children:"Validates all CEL expressions in status fields and conditions"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"API Generation"}),": kro generates and registers a new CRD in your cluster\nbased on your schema. For example, if your ",(0,o.jsx)(s.strong,{children:"ResourceGroup"})," defines a\n",(0,o.jsx)(s.code,{children:"WebApplication"})," API, kro creates a CRD that:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Provides API validation based on your schema definition"}),"\n",(0,o.jsx)(s.li,{children:"Automatically applies default values you've defined"}),"\n",(0,o.jsx)(s.li,{children:"Makes status information available to users and other systems"}),"\n",(0,o.jsx)(s.li,{children:"Integrates seamlessly with kubectl and other Kubernetes tools"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Controller Configuration"}),": kro configures itself to watch for instances of\nyour new API and:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Creates all required resources following the dependency order"}),"\n",(0,o.jsx)(s.li,{children:"Manages references and value passing between resources"}),"\n",(0,o.jsx)(s.li,{children:"Handles the complete lifecycle for create, update, and delete operations"}),"\n",(0,o.jsx)(s.li,{children:"Keeps status information up to date based on actual resource states"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(s.p,{children:["For instance, when you create a ",(0,o.jsx)(s.code,{children:"WebApplication"})," ResourceGroup, kro generates\nthe ",(0,o.jsx)(s.code,{children:"webapplications.kro.run"})," CRD. When users create instances of this API, kro\nmanages all the underlying resources (Deployments, Services, Custom Resources,\netc.) automatically."]}),"\n",(0,o.jsx)(s.p,{children:"kro continuously monitors your ResourceGroup for changes, updating the API and\nits behavior accordingly."}),"\n",(0,o.jsx)(s.h2,{id:"resourcegroup-instance-example",children:"ResourceGroup Instance Example"}),"\n",(0,o.jsxs)(s.p,{children:["After the ",(0,o.jsx)(s.strong,{children:"ResourceGroup"})," is validated and registered in the cluster, users\ncan can create instances of it. Here's an example of how an instance for the\n",(0,o.jsx)(s.code,{children:"SimpleWebApp"})," might look:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-yaml",metastring:'title="my-web-app-instance.yaml"',children:"apiVersion: kro.run/v1alpha1\nkind: SimpleWebApp\nmetadata:\n  name: my-web-app\nspec:\n  appName: awesome-app\n  image: nginx:latest\n  replicas: 3\n"})})]})}function u(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>t});var r=n(96540);const o={},i=r.createContext(o);function a(e){const s=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);