"use strict";(self.webpackChunkkro_docs=self.webpackChunkkro_docs||[]).push([[493],{24180:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"docs/concepts/rgd/resource-definitions/external-references","title":"External References","description":"Sometimes you need to reference resources that already exist in your cluster - like shared configuration, pre-provisioned infrastructure, or cluster-wide resources. External references let you read existing resources and use their data in your ResourceGraphDefinition without kro managing their lifecycle.","source":"@site/versioned_docs/version-0.7.0/docs/concepts/rgd/02-resource-definitions/04-external-references.md","sourceDirName":"docs/concepts/rgd/02-resource-definitions","slug":"/docs/concepts/rgd/resource-definitions/external-references","permalink":"/kro/0.7.0/docs/concepts/rgd/resource-definitions/external-references","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-sigs/kro/tree/main/website/versioned_docs/version-0.7.0/docs/concepts/rgd/02-resource-definitions/04-external-references.md","tags":[],"version":"0.7.0","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Readiness","permalink":"/kro/0.7.0/docs/concepts/rgd/resource-definitions/readiness"},"next":{"title":"CEL Expressions","permalink":"/kro/0.7.0/docs/concepts/rgd/cel-expressions"}}');var i=s(74848),t=s(28453);const a={sidebar_position:4},o="External References",c={},d=[{value:"Basic Example",id:"basic-example",level:2},{value:"How externalRef Works",id:"how-externalref-works",level:2},{value:"What You Can Reference",id:"what-you-can-reference",level:2},{value:"The Optional Operator (?)",id:"the-optional-operator-",level:2},{value:"Using orValue() for Defaults",id:"using-orvalue-for-defaults",level:3},{value:"Dependencies",id:"dependencies",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"external-references",children:"External References"})}),"\n",(0,i.jsx)(n.p,{children:"Sometimes you need to reference resources that already exist in your cluster - like shared configuration, pre-provisioned infrastructure, or cluster-wide resources. External references let you read existing resources and use their data in your ResourceGraphDefinition without kro managing their lifecycle."}),"\n",(0,i.jsxs)(n.p,{children:["kro provides the ",(0,i.jsx)(n.code,{children:"externalRef"})," field to reference existing resources. When you add ",(0,i.jsx)(n.code,{children:"externalRef"}),", kro reads the resource from the cluster but never creates, updates, or deletes it."]}),"\n",(0,i.jsx)(n.h2,{id:"basic-example",children:"Basic Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's a simple example where an application references a shared ConfigMap that exists in the cluster:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"resources:\n  - id: sharedConfig\n    externalRef:\n      apiVersion: v1\n      kind: ConfigMap\n      metadata:\n        name: platform-config\n        namespace: platform-system\n\n  - id: app\n    template:\n      apiVersion: apps/v1\n      kind: Deployment\n      metadata:\n        name: ${schema.spec.name}\n      spec:\n        template:\n          spec:\n            containers:\n              - name: app\n                image: ${schema.spec.image}\n                env:\n                  - name: PLATFORM_URL\n                    value: ${sharedConfig.data.?platformUrl}\n                  - name: REGION\n                    value: ${sharedConfig.data.?region}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"app"})," deployment won't be created until:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"platform-config"})," ConfigMap exists in the ",(0,i.jsx)(n.code,{children:"platform-system"})," namespace"]}),"\n",(0,i.jsx)(n.li,{children:"kro successfully reads the ConfigMap and makes its data available"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This allows multiple instances to share the same configuration without duplicating it."}),"\n",(0,i.jsx)(n.h2,{id:"how-externalref-works",children:"How externalRef Works"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"externalRef"})," defines a resource that kro reads but doesn't manage:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"kro reads the resource"})," from the cluster and makes its data available to other resources"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"kro never creates, updates, or deletes"})," the external resource"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"The resource must exist"})," for reconciliation to succeed - kro waits for it to be present"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"External resources participate in the dependency graph"})," just like managed resources"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"If namespace is omitted"}),", kro looks for the resource in the instance's namespace"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"what-you-can-reference",children:"What You Can Reference"}),"\n",(0,i.jsx)(n.p,{children:"External references require these fields:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Required fields\n- id: myExternal\n  externalRef:\n    apiVersion: v1           # Required: API version\n    kind: ConfigMap          # Required: Resource type\n    metadata:\n      name: my-config        # Required: Resource name\n      namespace: default     # Optional: Defaults to instance namespace\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can reference any Kubernetes resource:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Namespaced resources"}),": ConfigMaps, Secrets, Services (specify namespace or use instance namespace)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cluster-scoped resources"}),": StorageClasses, ClusterIssuers (omit namespace)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Custom resources"}),": Any CRD in your cluster"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"the-optional-operator-",children:"The Optional Operator (?)"}),"\n",(0,i.jsxs)(n.p,{children:["Use the optional operator ",(0,i.jsx)(n.code,{children:"?"})," when accessing fields with unknown or unstructured schemas. kro can't validate the structure at build time, so ",(0,i.jsx)(n.code,{children:"?"})," safely returns ",(0,i.jsx)(n.code,{children:"null"})," if the field doesn't exist."]}),"\n",(0,i.jsx)(n.p,{children:"Common examples include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ConfigMaps and Secrets"}),": The ",(0,i.jsx)(n.code,{children:"data"})," field has no predefined keys"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Custom resources"}),": CRDs with free-form ",(0,i.jsx)(n.code,{children:"spec"})," or ",(0,i.jsx)(n.code,{children:"status"})," fields"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Any resource with dynamic fields"}),": Fields whose structure isn't known at RGD creation time"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# \u2713 Safe: returns null if platformUrl doesn't exist\nvalue: ${config.data.?platformUrl}\n\n# \u2717 Unsafe: fails validation because kro can't verify the field exists\nvalue: ${config.data.platformUrl}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"using-orvalue-for-defaults",children:"Using orValue() for Defaults"}),"\n",(0,i.jsxs)(n.p,{children:["Combine ",(0,i.jsx)(n.code,{children:"?"})," with ",(0,i.jsx)(n.code,{children:".orValue()"})," to provide defaults when fields don't exist:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'env:\n  - name: LOG_LEVEL\n    value: ${config.data.?LOG_LEVEL.orValue("info")}\n\n  - name: MAX_CONNECTIONS\n    value: ${config.data.?MAX_CONNECTIONS.orValue("100")}\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["When you use ",(0,i.jsx)(n.code,{children:"?"}),", kro cannot validate the field exists at build time. If the resource doesn't have the expected field, the expression evaluates to ",(0,i.jsx)(n.code,{children:"null"}),". Document the expected structure and use ",(0,i.jsx)(n.code,{children:".orValue()"})," to provide sensible defaults."]})}),"\n",(0,i.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,i.jsx)(n.p,{children:"External references participate in the dependency graph just like managed resources. If you reference an external resource's data, kro automatically creates a dependency:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"resources:\n  - id: platformConfig\n    externalRef:\n      apiVersion: v1\n      kind: ConfigMap\n      metadata:\n        name: platform-config\n\n  - id: database\n    template:\n      spec:\n        region: ${platformConfig.data.?region}\n\n  - id: app\n    template:\n      spec:\n        env:\n          - name: DB_ENDPOINT\n            value: ${database.status.endpoint}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Dependency chain:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"platformConfig (external) \u2192 database \u2192 app\n"})}),"\n",(0,i.jsx)(n.p,{children:"kro will:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Wait for ",(0,i.jsx)(n.code,{children:"platformConfig"})," to exist"]}),"\n",(0,i.jsxs)(n.li,{children:["Create ",(0,i.jsx)(n.code,{children:"database"})," using the config data"]}),"\n",(0,i.jsxs)(n.li,{children:["Wait for ",(0,i.jsx)(n.code,{children:"database"})," to be ready"]}),"\n",(0,i.jsxs)(n.li,{children:["Create ",(0,i.jsx)(n.code,{children:"app"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/kro/0.7.0/docs/concepts/rgd/cel-expressions",children:"CEL Expressions"})})," - Learn more about the ",(0,i.jsx)(n.code,{children:"?"})," operator"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/kro/0.7.0/docs/concepts/rgd/dependencies-ordering",children:"Dependencies & Ordering"})})," - Understand how external refs affect dependency graphs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"/kro/0.7.0/docs/concepts/rgd/resource-definitions/readiness",children:"Readiness"})})," - Use ",(0,i.jsx)(n.code,{children:"readyWhen"})," with external references"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var r=s(96540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);