"use strict";(self.webpackChunkkro_docs=self.webpackChunkkro_docs||[]).push([[9375],{85585:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"docs/advanced/controller-tuning","title":"Controller Tuning","description":"kro has two main reconciliation loops: the RGD reconciler that processes ResourceGraphDefinitions, and the dynamic controller that manages instances. This page explains both and their tuning options.","source":"@site/versioned_docs/version-0.7.0/docs/advanced/03-controller-tuning.md","sourceDirName":"docs/advanced","slug":"/docs/advanced/controller-tuning","permalink":"/kro/0.7.0/docs/advanced/controller-tuning","draft":false,"unlisted":false,"editUrl":"https://github.com/kubernetes-sigs/kro/tree/main/website/versioned_docs/version-0.7.0/docs/advanced/03-controller-tuning.md","tags":[],"version":"0.7.0","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"RGD Chaining","permalink":"/kro/0.7.0/docs/advanced/rgd-chaining"},"next":{"title":"Controller Metrics","permalink":"/kro/0.7.0/docs/advanced/metrics"}}');var t=r(74848),s=r(28453);const c={sidebar_position:3},l="Controller Tuning",d={},o=[{value:"RGD Reconciler",id:"rgd-reconciler",level:2},{value:"Dynamic Controller",id:"dynamic-controller",level:2},{value:"Architecture",id:"architecture",level:3},{value:"Concurrency",id:"concurrency",level:3},{value:"Resync and Retries",id:"resync-and-retries",level:3},{value:"Rate Limiting",id:"rate-limiting",level:3},{value:"API Server Communication",id:"api-server-communication",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"controller-tuning",children:"Controller Tuning"})}),"\n",(0,t.jsx)(n.p,{children:"kro has two main reconciliation loops: the RGD reconciler that processes ResourceGraphDefinitions, and the dynamic controller that manages instances. This page explains both and their tuning options."}),"\n",(0,t.jsx)(n.h2,{id:"rgd-reconciler",children:"RGD Reconciler"}),"\n",(0,t.jsx)(n.p,{children:"The RGD reconciler watches ResourceGraphDefinition resources. When you create or update an RGD, it:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Validates the schema and resource templates (see ",(0,t.jsx)(n.a,{href:"/kro/0.7.0/docs/concepts/rgd/static-type-checking",children:"Static Type Checking"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"Creates or updates the generated CRD"}),"\n",(0,t.jsx)(n.li,{children:"Registers the instance handler with the dynamic controller"}),"\n"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Setting"}),(0,t.jsx)(n.th,{children:"Default"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"config.resourceGraphDefinitionConcurrentReconciles"})}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"Parallel RGD reconciles"})]})})]}),"\n",(0,t.jsx)(n.p,{children:"Increase this if you're creating many RGDs simultaneously:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"config:\n  resourceGraphDefinitionConcurrentReconciles: 3\n"})}),"\n",(0,t.jsx)(n.h2,{id:"dynamic-controller",children:"Dynamic Controller"}),"\n",(0,t.jsx)(n.p,{children:"The dynamic controller is a custom architecture designed for managing multiple resource types at runtime. Unlike traditional controllers that watch fixed resources, it adapts dynamically - when you create an RGD, it registers new watches without requiring restarts."}),"\n",(0,t.jsx)(n.h3,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"+----------------------------------------------------------+\n|                    Dynamic Controller                    |\n|                                                          |\n|  +--------------+  +--------------+  +--------------+    |\n|  |   Informer   |  |   Informer   |  |   Informer   |    |\n|  |   (WebApp)   |  | (Deployment) |  |  (Service)   |    |\n|  +------+-------+  +------+-------+  +------+-------+    |\n|         |                 |                 |            |\n|         +-----------------+-----------------+            |\n|                           |                              |\n|                           v                              |\n|                  +----------------+                      |\n|                  |  Shared Queue  |                      |\n|                  +-------+--------+                      |\n|                          |                               |\n|           +--------------+--------------+                |\n|           |              |              |                |\n|           v              v              v                |\n|      +--------+    +--------+    +--------+              |\n|      |Worker 1|    |Worker 2|    |Worker N|              |\n|      +--------+    +--------+    +--------+              |\n+----------------------------------------------------------+\n"})}),"\n",(0,t.jsx)(n.p,{children:"The controller is designed around a few core principles:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Single shared queue"})," - All resource events flow through one rate-limited queue, preventing any single RGD from overwhelming the system"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lazy informers"})," - Informers are created on-demand when an RGD is registered and stopped when deregistered"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parent-child watches"})," - The controller watches both instances (parent) and their managed resources (children). Child events trigger parent reconciliation via labels"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Metadata-only watches"})," - The dynamic controller only fetches metadata, reducing memory overhead"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"kro is in active development. This architecture may evolve - for example, the shared queue could be replaced with per-RGD queues in future versions."})}),"\n",(0,t.jsx)(n.h3,{id:"concurrency",children:"Concurrency"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Setting"}),(0,t.jsx)(n.th,{children:"Default"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsx)(n.tbody,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"config.dynamicControllerConcurrentReconciles"})}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"Workers processing instances"})]})})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"config:\n  dynamicControllerConcurrentReconciles: 10\n"})}),"\n",(0,t.jsx)(n.p,{children:"More workers increase throughput but also increase concurrent API server load."}),"\n",(0,t.jsx)(n.h3,{id:"resync-and-retries",children:"Resync and Retries"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Setting"}),(0,t.jsx)(n.th,{children:"Default"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"config.dynamicControllerDefaultResyncPeriod"})}),(0,t.jsx)(n.td,{children:"36000"}),(0,t.jsx)(n.td,{children:"Seconds between full resyncs (10 hours)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"config.dynamicControllerDefaultQueueMaxRetries"})}),(0,t.jsx)(n.td,{children:"20"}),(0,t.jsx)(n.td,{children:"Retries before dropping an item"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"The resync period triggers reconciliation for all resources periodically, even without changes. This catches any drift that might have been missed."}),"\n",(0,t.jsx)(n.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,t.jsx)(n.p,{children:"The queue uses a combined rate limiter with two strategies:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Exponential backoff"})," - Failed items are requeued with increasing delays"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bucket rate limiter"})," - Limits overall event processing rate"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These settings are only available via command-line flags:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Flag"}),(0,t.jsx)(n.th,{children:"Default"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"--dynamic-controller-rate-limiter-min-delay"})}),(0,t.jsx)(n.td,{children:"200ms"}),(0,t.jsx)(n.td,{children:"Initial retry delay"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"--dynamic-controller-rate-limiter-max-delay"})}),(0,t.jsx)(n.td,{children:"1000s"}),(0,t.jsx)(n.td,{children:"Maximum retry delay"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"--dynamic-controller-rate-limiter-rate-limit"})}),(0,t.jsx)(n.td,{children:"10"}),(0,t.jsx)(n.td,{children:"Events per second"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"--dynamic-controller-rate-limiter-burst-limit"})}),(0,t.jsx)(n.td,{children:"100"}),(0,t.jsx)(n.td,{children:"Burst capacity"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"api-server-communication",children:"API Server Communication"}),"\n",(0,t.jsx)(n.p,{children:"These settings control how kro communicates with the Kubernetes API server:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Setting"}),(0,t.jsx)(n.th,{children:"Default"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"config.clientQps"})}),(0,t.jsx)(n.td,{children:"100"}),(0,t.jsx)(n.td,{children:"Maximum queries per second"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"config.clientBurst"})}),(0,t.jsx)(n.td,{children:"150"}),(0,t.jsx)(n.td,{children:"Burst requests before throttling"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Increase for larger clusters:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"config:\n  clientQps: 200\n  clientBurst: 300\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>l});var i=r(96540);const t={},s=i.createContext(t);function c(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);